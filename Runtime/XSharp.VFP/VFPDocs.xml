<?xml version="1.0" encoding="utf-8"?>
<Runtimefunctions>
<abs>
<summary>
Returns the absolute value of the specified numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression whose absolute value ABS( ) returns.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">? ABS(-45)       &amp;&amp; Displays 45
? ABS(10-30)     &amp;&amp; Displays 20
? ABS(30-10)     &amp;&amp; Displays 20
STORE 40 TO gnNumber1
STORE 2 TO gnNumber2
? ABS(gnNumber2-gnNumber1)     &amp;&amp; Displays 38</code>
</example>
</abs>
<aclass>
<summary>
Places an object's class name and its ancestor class names into a variable array.
</summary>
<param name="ArrayName">

Specifies the name of the array into which the class names are placed. If you specify the name of an array that doesn't exist, X# automatically creates the array. If you specify the name of an existing array that isn't large enough to hold all the parent names, X# automatically increases the size of the array. If the array is larger than necessary, the array size is truncated. If you specify the name of an existing two-dimensional array, the array is redimensioned to a one-dimensional array.

</param>
<param name="oExpression">

Specifies an object whose class name and ancestor class names are placed into the array. oExpression can be any object expression, such as an object reference, an object variable, or an object array element.
</param>
<returns>
Numeric
</returns>
<remarks>
ACLASS( ) creates a one-dimensional array containing the class name of the specified object and its ancestor class names. The first array element contains the class name of the object, the second element contains the name of the object's parent class, the third element contains the name of the object's grandparent class, and so on.
ACLASS( ) returns the number of class names in the array. ACLASS( ) returns 0 if the array cannot be created.
</remarks>
<example>
 <code language="X#">CLEAR
frmMyForm = CREATEOBJECT("FormGrandChild")
FOR nCount = 1 TO ACLASS(gaNewarray, frmMyForm)    &amp;&amp; Creates an array
? gaNewarray(nCount)  &amp;&amp; Displays the names of the classes
ENDFOR
RELEASE frmMyForm
DEFINE CLASS FormChild AS FORM
ENDDEFINE
DEFINE CLASS FormGrandChild AS FormChild
ENDDEFINE</code>
</example>
</aclass>
<acopy>
<summary>
Copies elements from one array to another array.
</summary>
<param name="nFirstSourceElement">

Specifies the first element number in the source array to be copied; inclusive (element number nFirstSourceElement is included in the copying). If nFirstSourceElement isn't included, copying begins with the first element in the source array.

</param>
<param name="nNumberElements">

Specifies the number of elements copied from the source array. If nNumberElements is –1, all elements of the source array beginning with element nFirstSourceElement are copied.

</param>
<param name="nFirstDestElement">

Specifies the first element in the destination array to be replaced.
</param>
<returns>
Numeric. <b>ACOPY( )</b> returns the number of elements copied to the destination array.
</returns>
<remarks>
Copying a member array to an existing non-member array with certain dimensions using the <b>ACOPY( )</b> function might generate the error, "Subscript is outside defined range." You can avoid this error changing the dimension of the destination array to a single element before calling <b>ACOPY( )</b>. For more information, see DIMENSION Command.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer     &amp;&amp; Open customer table
SELECT DISTINCT company ;
FROM customer ;
ORDER BY company ;
WHERE country = 'Germany';
INTO ARRAY gaCompanies
= ACOPY(gaCompanies, gaCompaniesTemp)  &amp;&amp; Make a copy of the array
CLEAR
DISPLAY MEMORY LIKE gaCompaniesTemp</code>
</example>
</acopy>
<acos>
<summary>
Returns the arc cosine of a specified numeric expression.
</summary>
<param name="nExpression">

Specifies a numeric expression whose arc cosine ACOS( ) returns. The value of nExpression can range from –1 through +1. The value returned by ACOS( ) ranges from 0 through pi (3.141592). The number of decimal places ACOS( ) returns is determined by SET DECIMALS. 
Use RTOD( ) to convert radians to degrees.
</param>
<returns>
Numeric
</returns>
<remarks>
The arc cosine is returned in radians.
</remarks>
<example>
 <code language="X#">CLEAR
? RTOD(ACOS(0))  &amp;&amp; Displays 90.00
STORE -1 to gnArcAngle
? RTOD(ACOS(gnArcAngle))  &amp;&amp; Displays 180.00
? RTOD(ACOS(SQRT(2)/2))  &amp;&amp; Displays 45.00</code>
</example>
</acos>
<adatabases>
<summary>
Places the names of all open databases and their paths into a variable array.
</summary>
<param name="ArrayName">

Specifies the name of the array. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the database information, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. If the array exists and ADATABASES( ) returns 0 because no databases are open, an existing array remains unchanged. If the array doesn't exist, and ADATABASES( ) returns 0, the array is not created.
</param>
<returns>
Numeric
</returns>
<remarks>
The names of all open databases are placed into a variable array.
ADATABASES( ) creates a two-dimensional array. The first column of the array contains the names of the open databases, and the second column contains the paths to the databases.
ADATABASES( ) returns the number of database names (rows) in the array. If no databases are open, ADATABASES( ) returns 0 and the array isn't created.
</remarks>
<example>
 <code language="X#">SET PATH TO (HOME(2) + 'data\')     &amp;&amp; Sets path to database
OPEN DATABASE testdata &amp;&amp; Opens the database
CLEAR
? ADATABASES(gaDatabase)     &amp;&amp; Creates an array of open databases
DISPLAY MEMORY LIKE gadatabase  &amp;&amp; Displays the contents of the array
CLOSE DATABASES</code>
</example>
</adatabases>
<adbobjects>
<summary>
Places the names of named connections, relations, tables, or SQL views in the current database into a variable array.
</summary>
<param name="ArrayName">

Specifies the name of the array in which the names are placed. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the names, X# automatically increases the size of the array to accommodate the names. If the array is larger than necessary, X# truncates the array. If the array exists and ADBOBJECTS( ) returns 0 because no names are found, the array remains unchanged. If the array doesn't exist, and ADBOBJECTS( ) returns 0, the array is not created.
A one-dimensional array is created when you specify CONNECTION, TABLE, or VIEW for cSetting. Each row in the one-dimensional array contains the name of a connection, table, or view in the database.   
A two-dimensional array is created when you specify RELATION for cSetting. Each row in the two-dimensional array corresponds to a relationship in the database. The first column in an array row contains the name of the child table and the second column in an array row contains the name of the parent table. The third column contains the name of the index tag for the child table and the fourth column contains the name of the index tag for the parent table.   
The fifth column in an array row contains referential integrity information. This column is empty if the relation has no referential integrity rules. If the relationship does have referential integrity rules, the column contains characters corresponding to the type of referential integrity rules for updates, deletions, and insertions.   
The first character indicates the type of update rule, the second character indicates the type of deletion rule, and the third character indicates the type of insertion rule.   
Possible values for updates and deletions are "C" for cascade, "R" for restrict, and "I" for ignore. Possible values for insertions are "R" for restrict, and "I" for ignore. For example, if a relation has cascaded updates, restricted deletions, and ignores insertion referential integrity rules, the column contains "CRI". 

</param>
<param name="cSetting">

Specifies the names to place in the variable array. The following table lists the values for cSetting and the corresponding names placed in the array:
CONNECTION
Connection names
RELATION
Table relationships
TABLE
Table names
VIEW
View names
The CONNECTION, RELATION, TABLE, and VIEW settings cannot be abbreviated.
</param>
<returns>
Numeric
</returns>
<remarks>
A database must be open and current when ADBOBJECTS( ) is issued; otherwise X# generates an error message.
</remarks>
<example>
 <code language="X#">* Close any open databases
CLOSE DATABASES
* Clear desktop to prepare for displaying the array
CLEAR
* Open sample testdata database
OPEN DATABASE (HOME(2) + 'Data\testdata')
* Function call with cSetting for table names
=ADBOBJECTS(gaTables, "TABLE")
* Displays array gaTables created by ADBOBJECTS( ) function
DISPLAY MEMORY LIKE gaTables</code>
</example>
</adbobjects>
<addproperty>
<summary>
Adds a new property to an object at run time. 
You can use <b>ADDPROPERTY( )</b> to add properties and their values to valid X# objects, including those created from X# classes, COM classes, and the <b>SCATTER...NAME</b> command.
</summary>
<param name="oObjectName">

Specifies the name of the object to which the property is added. 
If oObjectName is not a valid object, X# generates the appropriate message. 

</param>
<param name="cPropertyName">

Specifies the name of the new property to add to the object.
If the property with the name you specify does not exist, the property is created and added. 

</param>
<param name="eNewValue">

Specifies the value to set for the new property. 
If you omit eNewValue, and the property exists, X# leaves the value of the property unchanged. If you omit eNewValue, and the property is new, X# sets the value of the new property to False (.F.).
</param>
<returns>
Logical data type. The following table describes the return values for <b>ADDPROPERTY( )</b> and the behavior when you attempt to add a property that already exists for an object.
True (.T.)
When <b>ADDPROPERTY( ) </b>
When the new property is an array property, and the array already exists, <b>ADDPROPERTY( )</b> redimensions the array with the dimensions specified by cPropertyName. If you specify a value with eNewValue, all elements in the array are set to that value. If you omit eNewValue, all array elements are set to False (.F.).
If the new property is not an array property, but the existing property is an array property. The property remains an array property with the same dimensions. If you specify a value with eNewValue, all elements in the array are set to that value. If you omit eNewValue, all array elements are set to False (.F.).
If the new property is not an array property, and the existing property is not an array property or is not a read-only X# native property. If you specify a value with eNewValue, the existing property is set to that value. If you omit eNewValue, the existing property value remains unchanged.
If the specified property is already a member of the object but is marked as <b>Hidden</b> or <b>Protected</b>. X# generates an error, "Property name is not found (Error 1734)", and the property is not set to the value passed to <b>ADDPROPERTY( )</b>.
False (.F.)
When <b>ADDPROPERTY( )</b> did not add the property successfully.
If the property is an array property, and the existing property is not an array property. The existing property remains unchanged.
</returns>
<remarks>
You can create property arrays using <b>ADDPROPERTY( )</b> for an object. When you do so, every element in the array is initialized with eNewValue, if provided. Otherwise, the value of each property in the array is set to False (.F.). For more information about creating a property array for an object, see the Examples section.
X# adds the new property as a <b>Public</b> property. You cannot specify the property as <b>Protected</b> or <b>Hidden</b>.
If the existing property is a read-only X# native property, such as the <b>BaseClass</b> property, X# generates an error, "Property name is read-only (Error 1743)".
If the property name is not valid, for example, the property name contains a space or other illegal characters, X# generates an error, "Incorrect property name (Error 1470)".
For object instances derived from native X# classes, <b>ADDPROPERTY( )</b> respects the visibility setting of the intrinsic <b>AddProperty</b> method. If <b>AddProperty</b> is marked as <b>Hidden</b> or <b>Protected</b>, <b>ADDPROPERTY( )</b> does not create the new property and returns False (.F.). If the <b>AddProperty</b> method is marked as <b>Public</b> (default), <b>ADDPROPERTY( )</b> creates the property and returns True (.T.). This protects the original class design.
This does not apply to COM objects created with X# OLEPUBLIC classes.

<b>ADDPROPERTY( )</b> does not work when using the <b>FOR EACH</b> command with object references. However, you can use the <b>AddProperty</b> method instead.

<b>Example 1</b>

The following example adds a new property to an object created with the <b>SCATTER</b> command.
 <code language="X#">USE customers
SCATTER NAME oCust
ADDPROPERTY(oCust,"MyProperty")</code>

<b>Example 2</b>

The following example creates a property array for the object, codeoMyForm/code, and displays its contents, code1/code and code"Two"/code.
 <code language="X#">oMyForm = CREATEOBJECT('Form')
ADDPROPERTY(oMyForm, 'MyArray(2)', 1)
oMyForm.MyArray(2) = "Two"
CLEAR
? oMyForm.MyArray(1)
? oMyForm.MyArray(2) </code>
</remarks>
</addproperty>
<adel>
<summary>
Deletes an element from a one-dimensional array, or a row or column from a two-dimensional array.
</summary>
<param name="ArrayName">

Specifies the array from which the element, row, or column is deleted.

</param>
<param name="nElementNumber">

Specifies the number of the element, row, or column to delete from the array. If the array is multidimensional, nElementNumber will specify the row. You must include the optional 2 argument to delete a column from the array. 
For more information on how to reference elements in an array, see DIMENSION Command.
2 
Deletes a column from the array.
</param>
<returns>
Numeric
</returns>
<remarks>
Deleting an element or row from an array doesn't change the size of the array; instead, the trailing elements, rows, or columns are moved towards the start of the array, and the last element, row, or column in the array is set to False (.F.). If you delete a column, values of the elements in the deleted column are set to False (.F.), but trailing elements are not moved.
If the element, row, or column is successfully deleted, 1 is returned.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer     &amp;&amp; Open customer table
SELECT company FROM customer ;
WHERE country = 'UK' ;
INTO ARRAY gaCompanies
gnCount = _TALLY
gcName = 'Seven Seas Imports'
CLEAR
DISPLAY MEMORY LIKE gaCompanies
gnPos = ASCAN(gaCompanies, gcName)   &amp;&amp; Search for company
IF gnPos != 0
* Company found, remove it from the array
= ADEL(gaCompanies, gnPos)
gnCount = gnCount - 1
ENDIF
DISPLAY MEMORY LIKE gaCompanies</code>
</example>
</adel>
<adir>
<summary>
Places information about files into an array and then returns the number of files.
</summary>
<param name="ArrayName">

Specifies the name of the array. If the array you include doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the information, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. If the array exists and <b>ADIR( )</b> returns 0 because no matching files are found, the array remains unchanged. If the array doesn't exist and <b>ADIR( )</b> returns 0, the array isn't created.
The following table describes the contents and data type of each column in the array:   
1
File names
Character
2
File sizes
Numeric
3
Dates last modified
4
Times last modified
5
File attributes
The last array column contains the file attributes of the matching files. Each file attribute is expressed by a letter; a file can have more than one attribute. The following table indicates the file attribute represented by each letter:   
Archive – Read/Write 
H
Hidden
Read-only
System
Directory

</param>
<param name="cFileSkeleton">

Specifies a file skeleton so you can store information about files with names or extensions that match a search criterion. For example, the criterion can be all tables, all text files, all files with names that have A as their first letter, and so on. Such general searches are done by including the wildcards * and ? in cFileSkeleton. A question mark represents a single character; an asterisk represents any number of characters. You can use any number of wildcards in any position within the file skeleton.
You can specify a drive and/or directory to search for matching file names. If you don't specify a drive and a directory, X# places information about files in the current directory into the array. 

</param>
<param name="cAttribute">

Specifies the inclusion of subdirectories and hidden or system files.
cAttribute can contain any combination of D, H, and S. Including D returns subdirectory names of the current directory in addition to file names that match the file skeleton specified in cFileSkeleton. Including H returns information about hidden files that match the file skeleton specified in cFileSkeleton. Including S returns information about system files that match the file skeleton specified in cFileSkeleton.   
Include an empty string in cFileSkeleton to return just subdirectory names, hidden files or system files.   
You can include V in cAttribute to return the volume name of the current drive. Only the volume name is returned to the array if V is included with D, H, or S. The volume name is stored in the first array element and the remainder of the array is truncated. 

</param>
<param name="nFlag">

Specifies whether the display provides DOS naming or actual case sensitivity.
nFlag
0
(Default) Display represents the full file name in uppercase
1
Display represents original Case in names
2
Display follows DOS 8+3 naming convention
</param>
<returns>
Numeric
</returns>
<remarks>
For each file, ADIR( ) places into the array the file name, size, date last modified, time last modified, and attributes.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
SET DEFAULT TO (HOME(2) + 'Data')
gnDbcnumber = ADIR(gaDatabase, '*.DBC')  &amp;&amp; Create array
CLEAR
FOR nCount = 1 TO gnDbcnumber  &amp;&amp; Loop for number of databases
? gaDatabase(nCount,1)  &amp;&amp; Display database names
ENDFOR
SET PATH TO HOME( )  &amp;&amp; Set path to X# directory</code>
</example>
</adir>
<adlls>
<summary>
Returns an array containing the names of functions loaded by DECLARE DLLs.
</summary>
<param name="Arrayname">

Specifies the name of the array. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the functions loaded by DECLARE DLLS, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. If no DLL functions have been declared, the array is not created, and an existing array is not modified.
</param>
<returns>
Numeric
</returns>
<remarks>
The numeric value returned by the ADLLS function specifies the number of DLL loaded functions. If no alias is provided, the 2nd element returns the same value as the 1st element (function name).
The array created by the ADLLS function has the following format:
1
Function Name
Character
2
Function Alias
Character
3
Library Name
Character
For details about how to declare functions, see DECLARE - DLL Command.
</remarks>
</adlls>
<adockstate>
<summary>
Retrieves the dock state of any dockable form, Integrated Development Environment (IDE) window, or toolbar. For forms only, you can use the GetDockState Method. <b>ADOCKSTATE( )</b> is available in the run time.
</summary>
<param name="ArrayName">

Specifies an array with one or more rows containing the dock state of dockable items. 
Both system and user-defined toolbars can appear in the array. A form appears in the array only if the form's <b>Dockable</b> property is set to a value greater than 0. 
The following table illustrates the information that the array contains.   
1
Name of the form, IDE window, or toolbar.
For user-defined toolbars, the first element contains the <b>Caption</b> property value for that toolbar. 
2
Dock state: 
1 - Docked 
0 - Undocked
3
Dock position.
For form and toolbar values, see DockPosition Property. For windows, see DOCK Command.
Target object that specified object is docked with.
This element does not apply to toolbars unless they are docked to the main X# window. For toolbars or windows docked to the main X# window, the fourth element contains the main X# window name, which you can retrieve using the _<b>VFP</b> <b>Caption</b> property. If a window or toolbar is not docked, the fourth element contains an empty string.
If a toolbar appears between the X# desktop and a window docked to the X# desktop, the fourth element contains the name of the toolbar.
Object reference to docking form or toolbar.
Applies only when docking user-defined forms or toolbars; otherwise, this element contains an empty string (IDE window).
Object reference to the target object if it is a user-defined form. If the target object is the main X# window, this element contains an object reference to the <b>_SCREEN</b> system variable. Otherwise, this element contains an empty string (IDE window). 

</param>
<param name="nType">

Specifies one or more items for which you want <b>ADOCKSTATE( )</b> to return dock state information. 
The following table lists the values for nType.   
0
Return all or no windows. (Default)
1
Return only IDE windows.
2
Return only toolbars.
3
Return only user-defined forms.

</param>
<param name="nExtended">

Specifies the number of elements to return in the array.
The following table lists the values for nExtended.   
0
Return a four-element array for windows and toolbars.
1
Return a six-element array for forms.
</param>
<returns>
Numeric data type. <b>ADOCKSTATE( )</b> returns the number of rows populated or 0 if none found.
</returns>
<remarks>
For tab-docked windows, the leftmost window is the anchor window and contains details about how the entire container is docked. X# traverses the windows from left to right. For link-docked windows, the upper left window in a link-docked container contains details about how the entire container is docked. 
The following rules determine docking order:  
X# traverses the link-docked container beginning with upper leftmost window.
X# traverses windows from top to bottom, from left to right. A link-docked container might consist of multiple inner containers. Thus, the ordering of windows in the <b>ADOCKSTATE( )</b> array might appear different.
The position contained in the third element of the array is relative to the window referenced in first element of the array.
X# traverses all link-docked windows first and tab-docked windows second. Essentially, X# makes two passes through a linked container. X# includes only the leftmost tab-docked window in the first pass for link-docked windows.
X# traverses a tab-docked container from left to right.
If the third element in the array is set to -1 (not docked), the container is not docked. If the container is docked to the desktop, the third element in the array contains the position in which the container is docked to the X# desktop as referenced in the fourth element of the array.
For example, the following code creates an array, opens and docks several windows, and produces an array as shown:
 <code language="X#">CLEAR ALL
PUBLIC aa
DIMENSION aa[1]
ACTIVATE WINDOW Command
ACTIVATE WINDOW Trace
ACTIVATE WINDOW Document
ACTIVATE WINDOW Properties
ACTIVATE WINDOW Watch
ACTIVATE WINDOW Locals
SET
DOCK WINDOW View POSITION -1
DOCK WINDOW Command POSITION -1
DOCK WINDOW Trace POSITION -1
DOCK WINDOW Document POSITION -1
DOCK WINDOW Properties POSITION -1
DOCK WINDOW Watch POSITION -1
DOCK WINDOW Command POSITION 1 WINDOW View
DOCK WINDOW Trace POSITION 1 WINDOW Command
DOCK WINDOW Document POSITION 3 WINDOW View
DOCK WINDOW Properties POSITION 3 WINDOW Trace
DOCK WINDOW Watch POSITION 4 WINDOW Command
DOCK WINDOW Locals POSITION 3 WINDOW Command
ADOCKSTATE(aa,1)</code>
The resulting array appears as follows:
1
Trace
1
-1
 
2
Properties
1
3
Trace
3
Watch
1
2
Trace
4
Locals
1
3
Watch
5
View
1
2
Watch
6
Document View
1
3
View
7
Command
1
4
Watch
X# displays docking information for debugger windows in the debugger. If a window is undocked, X# shows the name, dock state (0) and position (-1). If a window is docked, X# shows only the name, dock state (1), position, and window ("X# Debugger").
Historically, in prior versions of X#, the Data Session window has always been referred to as the View window. Additionally, language used to control this window, such as <b>HIDE WINDOW</b>, <b>ACTIVATE WINDOW</b>, <b>WONTOP(</b><b> )</b>, also refers to this window as the View window. X# continues to refer to the View window for the <b>ADOCKSTATE( )</b> function.
</remarks>
<example>
The following example shows the return results of <b>ADOCKSTATE( )</b> when no toolbars or windows have been previously docked, for example, after deleting the FoxUser resource files or when X# is newly installed. Make sure the Command window is open.
 <code language="X#">CLEAR
dockNum = ADOCKSTATE(dockState)
? dockNum   &amp;&amp; Returns 2 because Standard toolbar also exists.
? dockState(1,1)  &amp;&amp; Outputs "COMMAND".
? dockState(1,4)  &amp;&amp; Outputs an empty string because the Command
&amp;&amp; window is not docked.
? dockState(2,1)  &amp;&amp; Outputs "Standard".
? dockState(2,4)  &amp;&amp; Outputs "X#" because the
&amp;&amp; Standard toolbar is docked to the Microsoft
&amp;&amp; X# desktop.</code>
The following example shows how to use the <b>DOCK</b> command to dock the Command window to the X# desktop window and use <b>ADOCKSTATE( )</b> to obtain the dock state of the Command window. First, make sure the Command window is open. After docking the Command window, you can see that the Standard toolbar and Command windows are docked to the X# desktop window. The position of the toolbars or windows in the array returned by <b>ADOCKSTATE( )</b> can vary depending on the order in which the toolbars or windows are docked.
 <code language="X#">CLEAR
DOCK WINDOW Command POSITION 0
dockNum = ADOCKSTATE(dockState)
? dockNum   &amp;&amp; Returns 2 because Standard toolbar also exists.
? dockState(1,1)  &amp;&amp; Outputs "Standard".
? dockState(1,4)  &amp;&amp; Outputs "X#".
? dockState(2,1)  &amp;&amp; Outputs "COMMAND".
? dockState(2,4)  &amp;&amp; Outputs "X#".</code>
</example>
</adockstate>
<aelement>
<summary>
Returns the number of an array element from the element's subscripts.
</summary>
<param name="ArrayName">

Specifies the name of the array whose element number you want to return.

</param>
<param name="nRowSubscript">

Specifies the row subscript. If the array is one-dimensional, AELEMENT( ) identically returns nRowSubscript.
If you include just nRowSubscript and it is greater than the number of rows in the array, X# generates an error message. 

</param>
<param name="nColumnSubscript">

Specifies the column subscript. If the array is two-dimensional, include both nRowSubscript and nColumnSubscript.
</param>
<returns>
Numeric
</returns>
<remarks>
You can refer to an element in a two-dimensional array in one of two ways. The first method uses two subscripts to specify the row and column position of the element in the array, and the second method uses a single-element number. AELEMENT( ) returns the element number when supplied with an element's row and column subscripts.
The X# functions ADEL( ), ADIR( ), AFIELDS( ), AINS( ), ALEN( ), ASCAN( ), ASORT( ), and ASUBSCRIPT( ) can manipulate two-dimensional arrays and require that elements be referred to by their element number. AELEMENT( ) facilitates conversion from subscripts to an element number for use by these functions. The corresponding row and column subscripts can be returned from an element number with ASUBSCRIPT( ).
The following example illustrates the creation of an array with two rows and three columns. DISPLAY MEMORY shows the contents of the elements of the array listed in element number order.
 <code language="X#">DIMENSION gaMyArray(2,3)
DISPLAY MEMORY LIKE gaMyArray
gaMyArray   Pub  A
( 1, 1)   L  .F. (element number 1)
( 1, 2)   L  .F. (element number 2)
( 1, 3)   L  .F. (element number 3)
( 2, 1)   L  .F. (element number 4)
( 2, 2)   L  .F. (element number 5)
( 2, 3)   L  .F. (element number 6)</code>
An element can be referred to by its subscripts or its element number. The commands codeSTORE 'INVOICE' TO gaMyArray(2, 1)/code and codeSTORE 'INVOICE' TO gaMyArray(4)/code both store the character string INVOICE to the same array element.
In one-dimensional arrays, an element number is identical to its single-row subscript. It isn't necessary to use AELEMENT( ) with one-dimensional arrays.
</remarks>
</aelement>
<aerror>
<summary>
Creates a variable array containing information about the most recent X#, OLE, or ODBC error.
</summary>
<param name="ArrayName">

Specifies the name of the array for <b>AERROR( )</b> to create.
</param>
<returns>
Numeric. <b>AERROR( )</b> returns the number of rows in the array.
</returns>
<remarks>

<b>AERROR( )</b> creates an array with seven columns containing information about the error. The type of error that occurred determines the number of rows in the array.
If no error occurred, <b>AERROR( )</b> does not create the array.
When a X# error occurs, the array contains one row. The following table describes the contents of each element. 
1
Numeric. The number of the error. Identical to the value returned by ERROR( ).
2
Character. The text of the error message. Identical to the value returned by MESSAGE( ).
3
The null value. However, if the error has an additional error parameter, contains the text of the error parameter. Almost identical to the value returned by SYS(2018), the difference being that AERROR( ) returns mixed case but SYS(2018) returns all uppercase.
4
The null value. However, as appropriate, contains the number of the work area in which the error occurred.
5
The null value. However, if a trigger failed (error 1539), contains one of the following numeric values:1 – Insert trigger failed.2 – Update trigger failed.3 – Delete trigger failed.
6
The null value.
7
The null value.
When OLE errors numbered 1427 or 1429 occur, the array contains one row. The following table describes the contents of each element. 
1
Numeric. Contains 1427 or 1429.
2
Character. The text of the X# error message.
3
Character. The text of the OLE error message.
4
Character. The application name (for example, Microsoft Excel).
5
The null value or Character. Contains the name of the application's Help file where more information about the error can be found if the information is available from the application; otherwise contains the null value.
6
The null value or Character. Contains the Help context ID for the appropriate Help topic if the information is available from the application; otherwise contains the null value.
7
Numeric. An OLE 2.0 exception number.
When an ODBC error numbered 1526 occurs, the array contains one or more rows, one row for each ODBC error. The following table describes the contents of each element. 
1
Numeric. Contains 1526.
2
Character. The text of the error message.
3
Character. The text of the ODBC error message.
4
Character. The current ODBC SQL state.
5
Numeric. The error number from the ODBC data source.
6
Numeric. The ODBC connection handle.
7
The null value.
</remarks>
<example>
 <code language="X#">ON ERROR DO errhand     &amp;&amp; errhand is the error handler procedure
BRWS  &amp;&amp; Causes a syntax error
ON ERROR  &amp;&amp; Restore system error handler
PROCEDURE errhand
= AERROR(aErrorArray)  &amp;&amp; Data from most recent error
CLEAR
? 'The error provided the following information'  &amp;&amp; Display message
FOR n = 1 TO 7  &amp;&amp; Display all elements of the array
? aErrorArray(n)
ENDFOR</code>
</example>
</aerror>
<aevents>
<summary>
You can use the <b>AEVENTS( )</b> function to retrieve the number of existing event bindings.
</summary>
<param name="ArrayName">

Specifies the name of the array that contains the results of <b>AEVENTS( )</b>. 
0 
Specifies that <b>AEVENTS( )</b> returns a three-element array containing an object reference to the current event source, the name of the triggered event, and how the event was triggered.
1
Event source
Object reference
2
String
3
Event type, or how event was raised.
0 - System
1 - RAISEEVENT( ) function
2 - Method call
The third array element indicates how an event was triggered. If the event is a property, this value can be 1 or 2. The value is 2 if the property is set or assigned. 
1
Specifies that <b>AEVENTS( )</b> returns a four-column array containing information about Windows Message (Win Msg) events.
The array contains one row for each binding. Bindings are created with the BINDEVENT( ) Function.
The following table describes the contents of each column in the array.
hWnd
Integer
Window Message
Reference of handler
Handler delegate

</param>
<param name="oEventObject">

Specifies an object reference. If you specify an object reference, <b>AEVENTS( )</b> returns a five-column array that contains the events raised and the delegate methods for oEventObject. Each row in ArrayName represents a binding. The following table describes the information in each of the five columns.
1
.T. if second element is the event source
.F. if second element is the event handler
Logical
2
Event source if you pass the event handler to oEventObject; otherwise, event handler if you pass the event source to oEventObject.
Object reference
3
String
4
Delegate method
5
<b>BINDEVENT( )</b> flags
Integer
When you pass oEventObject, the number of bindings returned by <b>AEVENTS( )</b> should equal the number of unbound events returned by the <b>UNBINDEVENTS( )</b> function when passing only the oEventObject parameter.
</param>
<returns>
Numeric. <b>AEVENTS( )</b> returns the number of rows in the specified array. Typically, the number represents the number of event bindings. However, if you pass zero (0), then <b>AEVENTS( )</b> returns 3.
</returns>
<remarks>
If <b>AEVENTS( )</b> returns 0, and the array does not exist, X# does not create the array. X# changes or alters an existing array only if valid results are returned. The array remains unchanged under the following conditions:
No events exist. 
You specify a value of 0 as the second parameter, and<b> AEVENTS( )</b> does not appear within an event or oEventObject has no bindings.
</remarks>
<example>
 <code language="X#">PUBLIC oHandler
oHandler=NEWOBJECT("myhandler")
DO (_browser)
BINDEVENT(_SCREEN,"Resize",oHandler,"myresize")
AEVENTS(myArray,oHandler)
numRows=ALEN(myArray,1)
numCols=ALEN(myArray,2)
WAIT "Rows in array after binding: " + TRANSFORM(numRows) WINDOW AT 20,20
WAIT "Cols in array after binding: " + TRANSFORM(numCols) WINDOW AT 20,20
FOR count1 = 1 TO numRows
FOR count2 = 1 TO numCols
WAIT myArray[count1,count2] WINDOW AT 20,20
ENDFOR
ENDFOR
* Comment the following line to see event binding persist.
UNBINDEVENTS(_SCREEN,"Resize",oHandler,"myresize")
AEVENTS(myArray,oHandler)
* Check if AEVENTS( ) created and populated new array.
IF VARTYPE(myArray) &lt;&gt; U
* The following code does not execute if event is unbound because
* AEVENT( ) does not create a new array if it returns 0. To execute
* the following code and see the contents of the new array, uncomment
* the UNBINDEVENTS( ) statement.
numRows=ALEN(myArray,1)
numCols=ALEN(myArray,2)
WAIT "Rows in array after unbinding: " + TRANSFORM(numRows) ;
WINDOW AT 20,20
WAIT "Cols in array after unbinding: " + TRANSFORM(numCols) ;
WINDOW AT 20,20
FOR count1 = 1 TO numRows
FOR count2 = 1 TO numCols
WAIT myArray[count1,count2] WINDOW AT 20,20
ENDFOR
ENDFOR
ENDIF
DEFINE CLASS myhandler AS Session
PROCEDURE myresize
_obrowser.left = _SCREEN.Width - _obrowser.width
RETURN
ENDDEFINE</code>
</example>
</aevents>
<afields>
<summary>
Retrieves and stores information about the structure of the table in a specified work area, specified by a table alias, or in the currently selected work area in an array and returns the number of fields in the table.
</summary>
<param name="ArrayName">

Specifies an array to store information about the table structure. 
If the array you specify does not exist, X# automatically creates it. If the array exists and is not large enough to contain all the information returned by <b>AFIELDS( )</b>, the size of the array is automatically increased to accommodate the information. 

</param>
<param name="nWorkArea">

Specifies the work area of the table.

</param>
<param name="cTableAlias">

Specifies a table alias. 
If you omit nWorkArea and cTableAlias, <b>AFIELDS( )</b> retrieves information for the table in the currently selected work area.
</param>
<returns>
Numeric data type. <b>AFIELDS( )</b> returns the number of fields in the table. The array contains 18 columns and has the same number of rows as fields in the table.
The following table describes the content of each column in the first row of the array and the data type of the information stored in each column. Values for table-specific properties in columns 10 through 16 only appear in the first row of the array. One row is created for each field in the table.
1
Field name
Character
2
Field type: 
C = Character
Y = Currency
D = Date
T = DateTime
B = Double
F = Float
G = General
I = Integer
L = Logical
M = Memo
N = Numeric
Q = Varbinary
V = Varchar and Varchar (Binary)
W = Blob
Character
3
Field width
Numeric
4
Decimal places
Numeric
5
Null values allowed
Logical
6
Code page translation not allowed
Logical
7
Field validation expression
Character
8
Field validation text
Character
9
Field default value
Character
10
Table validation expression
Character
11
Table validation text
Character
12
Long table name
Character
13
Insert trigger expression
Character
14
Update trigger expression
Character
15
Delete trigger expression
Character
16
Table comment
Character
17
NextValue for autoincrementing
Numeric
18
Step for autoincrementing
Numeric
</returns>
<remarks>
If the fields in the table use autoincrementing, the Step value is greater than 0.
You can use COPY STRUCTURE EXTENDED to place similar information into a table instead of an array.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer     &amp;&amp; Open Customer table.
gnFieldcount = AFIELDS(gaMyArray)  &amp;&amp; Create array.
CLEAR
FOR nCount = 1 TO gnFieldcount
? gaMyArray(nCount,1)  &amp;&amp; Display field names.
ENDFOR</code>
</example>
</afields>
<afont>
<summary>
Places information about available fonts, such as their names, into an array.
You can also use <b>AFONT( )</b> to determine available font sizes or if a font is scalable. To display a dialog box containing available fonts, font sizes, and styles, use the <b>GETFONT( )</b> function. For more information, see GETFONT( ) Function.
</summary>
<param name="ArrayName">

Specifies the variable array into which the names of available fonts are placed. If the array is not large enough to contain all the fonts, X# automatically increases the size of the array. If you specify an existing two-dimensional array, X# changes the array to a one-dimensional array.

</param>
<param name="cFontName">

Specifies a font for which information is placed into the array.
If the font you specify supports only discrete font sizes (8-point, 10-point, ...), the font sizes are stored to the array, and <b>AFONT( )</b> returns True (.T.). If the font you specify in cFontName is scalable (supports fractional font size values), the array has a single element containing –1, and <b>AFONT( )</b> returns True (.T.).   
If the font you specify is not available, the array is not created, and <b>AFONT( )</b> returns False (.F.). 

</param>
<param name="nFontSize">

Specifies a size for the font specified in cFontName.
If the font size nFontSize is available for the font specified in cFontName, the array has a single element containing a True (.T.) value, and <b>AFONT( )</b> returns True (.T.). If the font size is not available for the specified font, the array is not created, and <b>AFONT( )</b> returns False (.F.). 

</param>
<param name="nFontCharSet">

Specifies a character set for the font specified in cFontName. If the font character set specified is available for the font specified in cFontName, the array has a single element containing a True (.T.) value, and <b>AFONT( )</b> returns True (.T.). If the font character set is not available for the specified font, the array is not created, and <b>AFONT( )</b> returns False (.F.).

</param>
<param name="nFlags">

Controls whether the third parameter passed is treated as the font size or font character set. 
The following table describes behavior for various nFlags values specified.   
Omitted or 0 for the first bit
Third parameter is treated as a font size value.
If third parameter is -1, array is updated with all available font sizes for the font specified in cFontName for nonproportional fonts, such as MS Sans Serif, and <b>AFONT( )</b> returns True (.T.). This behavior in X# 8.0 and later is equivalent to passing only the first two parameters.
In versions prior to X# 8.0, if you specified any negative or positive font size for a non-proportional font, <b>AFONT( )</b> returned False (.F.). 
If the third parameter passed is 0, for nonproportional fonts, <b>AFONT( )</b> returns False (.F.) for X# 8.0 and later. However, the behavior for proportional fonts such as TrueType or OpenType (Arial) has not changed.
Third parameter is treated as a font character set. Array is populated with character sets available for the specified font.
If the third parameter passed is -1, array is updated with all available font character sets for the font specified in cFontName.
</param>
<returns>
Logical data type. <b>AFONT( )</b> returns True (.T.) if array is successfully created. Otherwise, <b>AFONT( )</b> returns False (.F.).
</returns>
<remarks>
If only ArrayName was passed in versions earlier than X# 8.0, the array populated in <b>AFONT( )</b> included extra fonts that were really part of a single font family. For example, the array might have included the following Arial fonts under X# 7.0:
Arial
Arial Baltic
Arial Black
Arial CE
Arial CYR
Arial Greek
Arial Narrow
Arial Tur
Many of these fonts are not included in a standard Font Picker dialog box such as the <b>GETFONT( )</b> function. In this version of X#, the array in <b>AFONT( )</b> excludes these extra fonts. For example, the array only includes the following fonts:
Arial
Arial Baltic
Arial Black
</remarks>
<example>
 <code language="X#">CLEAR
=AFONT(gaFontArray)  &amp;&amp; Array containS font names.
gnNumFonts = ALEN(gaFontArray)  &amp;&amp; Number of fonts
IF gnNumFonts &gt; 10
gnNumFonts = 10  &amp;&amp; Display first 10 fonts.
ENDIF
FOR nCount = 1 TO gnNumFonts
? ALLTRIM(gaFontArray(nCount))  &amp;&amp; Display font name.
?? '  This is an example of ' ;
+ ALLTRIM(gaFontArray(nCount)) FONT gaFontArray(nCount), 8
ENDFOR</code>
</example>
</afont>
<agetclass>
<summary>
Displays class libraries in the <b>Open</b> dialog box and creates an array containing the name of the class library and class chosen.
</summary>
<param name="ArrayName">

Specifies the name of the array in which the names of the class library and class are placed. The following table lists the contents of each element of the array created when you chose a class.
1
File name of the class library chosen.
2
Name of the class chosen.

</param>
<param name="cLibraryName">

Specifies the name of the class library initially selected when the Open dialog is displayed. cLibraryName can be a visual (.vcx) or program (.prg) -based class library.
The class library name you specify is displayed in the File name text box. An error is generated if the class library you specify doesn't exist or cLibraryName is the empty string or the null value. 

</param>
<param name="cClassName">

Specifies the name of the class initially selected in the Class name list when the Open dialog is displayed. If the class you specify doesn't exist, the first class in the Class name list is selected. An error is generated if you omit cLibraryName or cClassName is the null value.

</param>
<param name="cTitleText">

Specifies the text displayed in the title bar of the Open dialog. By default, "Open" is the text displayed.

</param>
<param name="cFileNameCaption">

Specifies the text displayed next to the File name text box. By default, "File name:" is the text displayed.

</param>
<param name="cButtonCaption">

Specifies the caption for the OK button.
</param>
<returns>
Logical data type. AGETCLASS( ) returns True (.T.), if you chose a class, and creates a one-dimensional array containing two elements. The first element contains the file name of the class library chosen; the second element contains the name of the class chosen. AGETCLASS returns False (.F.) if you exit the Class Library dialog box by pressing ESC, choosing Cancel, or clicking the Close button.
</returns>
<remarks>
If the array you specify does not exist, X# automatically creates the array. 
If the array exists and is not large enough to contain the names of the class library and class, X# automatically increases the size of the array. 
If the array is larger than necessary, X# truncates the array. If the array exists, and AGETCLASS( ) returns False (.F.) because the Class Library dialog box was closed by pressing ESC, choosing Cancel, or clicking the Close button, the array remains unchanged. 
If the array does not exist, and AGETCLASS( ) returns false (.F.), the array is not created.
X# 8.0 does not support AGETCLASS( ) in its run-time libraries. AGETCLASS( ) is supported in X# 9.0 run-time libraries, but the Program (*.prg) option is not available in the <b>Files of type</b> drop-down list box.
</remarks>
<example>
 <code language="X#">LOCAL aClassLib(2)  &amp;&amp; Create an array, initialized to .F.
cCurrentDir = CURDIR( )  &amp;&amp; Save the current directory.
CD HOME(2) + 'CLASSES'  &amp;&amp; Switch directories.
AGETCLASS(aClassLib, 'BUTTONS.VCX', 'VCR', 'Modify Class', ;
'Class File:', 'Modify')  &amp;&amp; Display the dialog.
CD (cCurrentDir)  &amp;&amp; Switch to the previous directory.
IF TYPE('aClassLib(2)') = 'C'  &amp;&amp; Class chosen?
MODIFY CLASS (aClassLib(2)) OF (aClassLib(1))  &amp;&amp; Open to modify.
ENDIF</code>
</example>
</agetclass>
<agetfileversion>
<summary>
Creates an array containing information about files with Windows version resources such as .exe, .dll, and .fll files, or automation servers created in X#.
For a X# automation server to have Windows version resources, you must specify a value for at least one item in the EXE Version dialog box. For more information, see EXE Version Dialog Box.
</summary>
<param name="ArrayName">

Specifies the name of the array in which the file information is placed. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain the file information, X# automatically increases the size of the array. If the array is larger than necessary, X# truncates the array.
The following table lists the contents of each element of the array.   
1
Comments
2
Company Name
3
File Description
4
File Version
5
Internal Name
6
Legal Copyright
7
Legal Trademarks
8
Original File Name
9
Private Build
10
Product Name
11
Product Version 
The format of this value is dependent on the version of X#. For details, see VERSION( ) Function.
12
Special Build
13
OLE Self Registration (contains "OLESelfRegister" if the file supports self-registration; otherwise contains the empty string)
14
Language (derived from the Translation Code)
For example, you can use the following code to determine the Locale ID for the X# executable file:
 <code language="X#">DIMENSION aFiles[1]
AGETFILEVERSION(aFiles,"VFP9.EXE")
? EVAL("0x"+LEFT(aFiles[15],4))
** Returns 1033 for US version</code>

</param>
<param name="cFileName">

Specifies the name, and optionally the path, of the target file.
</param>
<returns>
Numeric. <b>AGETFILEVERSION( )</b> returns the number of elements in the array. If the file you specify does not exist or does not contain Windows version resources, <b>AGETFILEVERSION( )</b> returns zero, and the array, if already created, remains unchanged.
</returns>
<remarks>

<b>AGETFILEVERSION( )</b> can be abbreviated to a minimum number of 5 characters.
</remarks>
</agetfileversion>
<ains>
<summary>
Inserts an element into a one-dimensional array, or a row or column into a two-dimensional array.
</summary>
<param name="ArrayName">

Specifies the name of the array into which the element is inserted.

</param>
<param name="nElementNumber">

Specifies where the new element, row, or column is inserted into the array.
To insert an element into a one-dimensional array, include ArrayName and the element nElementNumber where the insertion occurs. The new element is inserted just before element nElementNumber. To insert a row into a two-dimensional array, include ArrayName and the number of the row nElementNumber where the insertion occurs. The new row is inserted just before row nElementNumber.   
For more information on referencing an array element by its subscripts, see DIMENSION Command. 
2 
Inserts a column into a two-dimensional array. The new column is inserted just before the column specified with nElementNumber.
</param>
<returns>
Numeric
</returns>
<remarks>
Inserting an element, row, or column into an array does not change the size of the array. The trailing elements, rows, or columns are shifted toward the end of the array and the last element, row, or column in the array is dropped from it. The newly inserted element, row, or column is initialized to false (.F.).
AINS( ) returns 1 if the element, row, or column is successfully inserted.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer     &amp;&amp; Open customer table
SELECT company FROM customer ;
WHERE country = 'Germany' ;
INTO ARRAY gaCompanies
gnCount = _TALLY
gcName = 'Seven Seas Imports'
CLEAR
DISPLAY MEMORY LIKE gaCompanies
IF ASCAN(gaCompanies, gcName) = 0  &amp;&amp; Search for company
*** Company not found-add it ***
DIMENSION gaCompanies[gnCount+1,1]
= AINS(gaCompanies, gnCount-1)
gaCompanies[gnCount-1] = gcName
ENDIF
DISPLAY MEMORY LIKE gaCompanies</code>
</example>
</ains>
<ainstance>
<summary>
Places instances of a class into a variable array and returns the number of instances placed in the array.
</summary>
<param name="ArrayName">

Specifies the name of the array into which the instances are placed. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the instances, X# automatically increases the size of the array to accommodate the instances. If the array is larger than necessary, X# truncates the array. If the array exists and AINSTANCE( ) returns 0 because no instances are found, the array remains unchanged. If the array doesn't exist and AINSTANCE( ) returns 0, the array is not created.
Only class instances assigned to variables and array elements with CREATEOBJECT( ) or NEWOBJECT( ) are placed into the array. 

</param>
<param name="cClassName">

Specifies a X# base class name or a user-defined class name. For a complete list of the X# base classes, see Base Classes in X#.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">CLEAR ALL
goINSTANCE1 = CREATEOBJECT('Form')
goINSTANCE2 = CREATEOBJECT('Form')
CLEAR
? AINSTANCE(gaMyArray, 'Form')  &amp;&amp; Returns 2, two form instances
DISPLAY MEMORY LIKE gaMyArray  &amp;&amp; Displays the references</code>
</example>
</ainstance>
<alanguage>
<summary>
Returns an array containing the names of all valid X# commands, functions, or base classes.
</summary>
<param name="ArrayName">

Specifies the name of the array to contain the language items. If the array doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the data, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.

</param>
<param name="nType">

Specifies the type of language item returned, according to the following list:
1
Commands
One-dimensional:    Command name
2
Functions
Two-dimensional: 
Function name   [M] nParamR [- nParamT]
The matchFlag, M, specifies that you must use the full    function name in code.nParamR specifies the number of required parameters. nParamT specifies total number of possible parameters. 
3
Base classes
One-dimensional: 
Base Class name
4
DBC Events
DBC event name (The displayed name omits the "DBC_" prefix of the event name.)
</param>
<remarks>
The ALANGUAGE( ) function returns an array of all valid X# commands and functions. To return object information, use the AMEMBERS( ) function. 
Use the ALANGUAGE( ) function to access X# functions as in the following code:
 <code language="X#">   ALANGUAGE(FuncArr,2)</code>
The resulting array, FuncArr, will contain the following values:
 <code language="X#">   JUSTSTEM, M1</code>
JUSTSTEM( ) cannot be abbreviated and it requires one parameter.
 <code language="X#">   KEYMATCH, 1-4</code>
KEYMATCH( ) can be abbreviated to four characters, and has one required, and three optional parameters (total = 4).
 <code language="X#">   LASTKEY, 0</code>
LASTKEY( ) can be abbreviated and requires no parameters.
</remarks>
</alanguage>
<alen>
<summary>
Returns the number of elements, rows, or columns in an array.
</summary>
<param name="ArrayName">

Specifies the name of the array. If you include only the array name, ALEN( ) returns the number of elements in the array.

</param>
<param name="nArrayAttribute">

Determines whether ALEN( ) returns the number of elements, rows or columns in the array according to the following values for nArrayAttribute:
0
Returns the number of elements in the array. Omitting nArrayAttribute is identical to specifying 0.
1
Returns the number of rows in the array.
2
Returns the number of columns in the array. If the array is a one-dimensional array, ALEN( ) returns 0 (no columns).
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">CLEAR
=AFONT(gaFontArray)  &amp;&amp; Array containing font names
gnNumFonts= ALEN(gaFontArray)  &amp;&amp; Number of fonts
IF gnNumFonts &gt; 10
gnNumFonts = 10  &amp;&amp; Display first 10 fonts
ENDIF
FOR nCount = 1 TO gnNumFonts
? ALLTRIM(gaFontArray(nCount))  &amp;&amp; Display font name
?? '  This is an example of ' ;
+ ALLTRIM(gaFontArray(nCount)) FONT gaFontArray(nCount), 8
ENDFOR</code>
</example>
</alen>
<alias>
<summary>
Returns the table alias of the current or specified work area.
</summary>
<param name="nWorkArea">

Specifies the work area number for which ALIAS( ) returns the table alias.

</param>
<param name="cTableAlias">

Specifies the table alias for which ALIAS( ) returns the table alias.
If you omit nWorkArea or cTableAlias, ALIAS( ) returns the alias of the table open in the current work area. An empty string is returned if a table isn't open in the current or specified work area.
</param>
<returns>
Character
</returns>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer     &amp;&amp; Open customer table
CLEAR
? ALIAS( )  &amp;&amp; Display the alias
SELECT 0
USE customer AGAIN ALIAS MyCustomer  &amp;&amp; Different alias
? ALIAS( )  &amp;&amp; Display the alias</code>
</example>
</alias>
<alines>
<summary>
Copies each line in a character expression or memo field to a corresponding row in an array.
</summary>
<param name="ArrayName">

Specifies the name of the array to store the copied lines in the character expression or memo field. 
If the array you specify does not exist, X# automatically creates the array. If the array exists but is not large enough to contain all the lines in the memo field, X# automatically increases the size of the array. If the array is larger than necessary, X# truncates the array.
When used with binary values, such as <b>Varbinary</b> and <b>Blob</b>, <b>ALINES( )</b> creates an array with elements that have <b>Varbinary</b> type.

</param>
<param name="cExpression">

Specifies the character expression or memo field containing the lines to copy to the array. All character expressions are case-sensitive.
If cExpression is the empty string or the null value, an array with a single row is created and the row contains the empty string. You can use double-byte expressions.
[, nFlags] 
In previous versions of X#, nFlags was the lTrim option. The lTrim option corresponds to a value of 1 for nFlag. Previous code will run identically in X# 9.0.
The following table describes the values for nFlags.
(Default) Removes leading and trailing spaces from lines, or for Varbinary and Blob values, removes trailing zeroes (0) instead of spaces.
2
Include the last element in the array even if the element is empty.
4
Do not include empty elements in the array.
3
8
Specifies case-insensitive parsing.
16
Include the parsing characters in the array.
[, cParseChar[, c ParseChar2[, ...]]] 
Specifies one or more character strings that terminate the elements in cExpression. When cParseChar is specified, the line breaks when cParseChar is found, and the next line continues with the character following cParseChar.
The maximum number of strings permitted in cParseChar is 23. 
You can use a line feed (CHR(10)) or carriage return (CHR(13)) character to denote the end of a line. You can also denote the end of the line with either combination of these two characters, for example, (CHR(10) + CHR(13) or CHR(13) + CHR(10)). The default behavior for <b>ALINES( )</b> is to ignore CHR(13) and CHR(10) when you specify one or more values for cParseChar, unless you also specify the end of line characters.   
When cParseChar is omitted for <b>Varbinary</b> or <b>Blob</b> input, <b>ALINES( )</b> treats the hexadecimal value 0hA (10) as a carriage return and discontinues the line at that location. The value, 0hA, is not saved in the resulting array element and might result in an incorrect binary value. For example, given the binary value, 0hFE0AF2, <b>ALINES( )</b> creates a two-element array with the values, 0hFE and 0hF2.
</param>
<returns>
Numeric. <b>ALINES( )</b> returns the number of rows in the array, or, identically, the number of lines in the character expression or memo field.
</returns>
<remarks>

<b>ALINES( )</b> provides an easy way to parse lines in a character expression or memo field. While you can also use <b>MLINES( )</b> to parse a character expression or memo field, <b>ALINES( )</b> is faster and requires less programming. Also, <b>ALINES( )</b> is not affected by the value of <b>SET MEMOWIDTH</b>.
The first line of the character expression or memo field is copied to the first row of the array, the second line of the character expression or memo field is copied to the second row of the array, and so on.
You must have sufficient memory to copy the lines in a large memo field to an array. X# generates an error message if you lack sufficient memory.
If you want to perform a case-insensitive parse, you can follow one of the following examples:
 <code language="X#">? ALINES(aMyArray, UPPER(employee.notes), "R.") </code>
- OR -
 <code language="X#">? ALINES(aMyArray, employee.notes, "R.", "r.")</code>
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
SET TALK OFF
OPEN DATABASE (HOME(2) + "data\testdata")
USE employee  &amp;&amp; Open Employee table
? ALINES(aMyArray, employee.notes)            &amp;&amp; Displays 1
? ALINES(aMyArray, employee.notes, CHR(13))   &amp;&amp; Displays 1
? ALINES(aMyArray, employee.notes, " ")       &amp;&amp; Displays 75
? ALINES(aMyArray, employee.notes, ".")       &amp;&amp; Displays 7
? ALINES(aMyArray, employee.notes, ",")       &amp;&amp; Displays 4
? ALINES(aMyArray, employee.notes, ".", ",")  &amp;&amp; Displays 10
? ALINES(aMyArray, employee.notes, 8, "m")    &amp;&amp; Displays 14
? ALINES(aMyArray, employee.notes, "m")       &amp;&amp; Displays 11
? ALINES(aMyArray, employee.notes, "M")       &amp;&amp; Displays 4</code>
</example>
</alines>
<alltrim>
<summary>
Removes all leading and trailing spaces or parsing characters from the specified character expression, or all leading and trailing zero (0) bytes from the specified binary expression.
</summary>
<param name="Expression">

Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove leading and trailing spaces or 0 bytes from, respectively. 

</param>
<param name="nFlags">

Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

cParseChar [, cParseChar2 [, ...]]
Specifies one or more character strings that are trimmed from the beginning and end of cExpression. If cParseChar is not included, then leading and trailing spaces or 0 bytes are removed from Expression.
<b>Note</b>   The maximum number of strings permitted in cParseChar is 23. 
</param>
<returns>
Character or Varbinary. <b>ALLTRIM( )</b> returns the specified expression without leading or trailing spaces, parsing characters, or 0 bytes respectively.
</returns>
<remarks>
You can use <b>ALLTRIM( )</b> to ensure that spaces or 0 bytes are removed from data entered by a user.
</remarks>
<example>
 <code language="X#">CLEAR
=AFONT(gaFontArray)  &amp;&amp; Array containing font names
gnNumFonts= ALEN(gaFontArray)  &amp;&amp; Number of fonts
IF gnNumFonts &gt; 10
gnNumFonts = 10  &amp;&amp; Display first 10 fonts
ENDIF
FOR nCount = 1 TO gnNumFonts
? ALLTRIM(gaFontArray(nCount))  &amp;&amp; Display font name
?? '  This is an example of ' ;
+ ALLTRIM(gaFontArray(nCount)) FONT gaFontArray(nCount), 8
ENDFOR</code>
</example>
</alltrim>
<amembers>
<summary>
Places the names of properties, procedures, and member objects for an object into a variable array.
</summary>
<param name="ArrayName">
Specifies the array into which the names of the member properties for oObjectName are placed. If you specify the name of an array that doesn't exist, the array is automatically created. If the array isn't large enough to contain all the names, X# automatically increases the size of the array.
</param>
<param name="oObjectName">

Specifies the object whose member properties are placed in the variable array specified with ArrayName. oObjectName can be any expression that evaluates to an object, such as an object reference, an object variable, or an object array element.

</param>
<param name="cClassName">

Specifies the X# class whose member properties are placed in the variable array specified with ArrayName.

nArrayContentsID, 0 | 1 | 2 | 3 
Specifies that the array contains a single column of property names. Omitting the nArrayContentsID parameter is the same as passing a 0.
Specifies that the array contains the names of the properties of the object or class, as well as the methods and member objects. The resulting array is two-dimensional with the second column specifying what type of member is listed in the first column. The possible values for the second column are Property, Event, Method, or Object.   
Specifies that the array contains the names of objects that are members of a native X# object specified with oObjectName. The resulting array is one-dimensional.
This option provides a method to determine the names of child objects in a container such as all Form objects in a form set or controls in a form.
Specifies that the array contains information about one or more objects. You can pass an object reference to either a native X# object or to a COM object.
A value of 3 for this parameter is not supported in .app or .exe applications.
The array returned when you specify this parameter consists of four columns as described in the following table:   
Name of the event or method
Property type (for example, PROPERTYPUT, PROPERTYGET, PROPERTYPUTREF, METHOD)
Function signature (parameters and their types, and the function return type). This information is similar to the Quick Info text provided in IntelliSense expansion of a method. 
4
Help string
If you omit nArrayContentsID, AMEMBERS( ) returns a one column array of properties.
</param>
<param name="cFlags">

Specify the filtering applied to the array returned by the AMEMBERS( ) function. cFlags will not function when AMEMBERS( ) is passed a COM object (the value of ArrayContentsID is 3). Some flags are mutually exclusive so that if you use more than one cFlag, use them in the following groupings:  
code[P | H | G] [N | U] [C] [I | B] [R]/code

The following tables describe the valid values for cFlags.    
Protected properties, methods, or events
Hidden properties, methods, or events
Public properties, methods, or events
Native (Intrinsic) properties, methods, or events
User-Defined (Extrinsic) properties, methods, or events
Changed properties (but not changed array properties)
Inherited properties, methods, or events
Base properties, methods, or events (using the AddProperty method)
Read-Only Properties
The default configuration for the filtering specified by cFlags is logical OR between flags. You can change this by using the special "+" cFlags.
#
Adds a new column to the output array with the corresponding cFlags value.
Performs logical AND between filter flags.
</param>
<returns>
Numeric
</returns>
<remarks>
AMEMBERS( ) returns the number of objects, properties, and procedures for the object, or 0 if the array cannot be created. If you omit the optional 1, 2, or 3 flag parameters, a one-dimensional array is created containing the properties of oObjectName.
You can pass COM object references to the AMEMBERS( ) function, but when you do so, you must also pass a value of 3 in the third (flag) parameter, as in the following example.
 <code language="X#">oExcel = CREATEOBJECT("excel.application")
= AMEMBERS(gaPropArray, oExcel, 3)</code>
</remarks>
<example>
 <code language="X#">CLEAR
goForm1 = CREATEOBJECT("Form")  &amp;&amp; Creates a Form
= AMEMBERS(gaPropArray, goForm1, 1)  &amp;&amp; Array containing Form properties
DISPLAY MEMORY LIKE gaPropArray  &amp;&amp; Display the Form properties</code>
</example>
</amembers>
<amouseobj>
<summary>
Creates an array containing information about the mouse pointer position and the object over which the mouse pointer is positioned.
</summary>
<param name="ArrayName">

Specifies the name of the array containing the mouse pointer information. If the array you specify doesn't exist, X# automatically creates a four-row array. If the array exists, X# dimensions it to four rows.
The following table describes the contents of each row in the array:   
1
Contains an object reference to the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
2
Contains an object reference to the container of the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
3
Contains the horizontal (X) coordinate in pixels of the mouse pointer, relative to the container of the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
4
Contains the vertical (Y) coordinate in pixels of the mouse pointer, relative to the container of the object over which the mouse pointer is positioned when AMOUSEOBJ( ) is executed.
The first and second rows in the array can contain the same values if the mouse is positioned over a generic container such as a pageframe.
[, 1] 
This optional parameter specifies that the mouse pointer information contained in the array is relative to the current form (THISFORM). If you include this option, the second array row always contains an object reference to the current form, and the third and fourth rows contain the mouse pointer coordinates relative to the current form.
</param>
<returns>
Numeric
</returns>
<remarks>
You can also use AMOUSEOBJ( ) to determine where to position the mouse pointer during design time. The following table lists the design time element and the values contained in each row of the array:
Form and Class Designers
Row 1 – Object reference to the control.Row 2 – Object reference to the form.Row 3 – Mouse pointer horizontal (X) coordinate relative to the form.Row 4 – Mouse pointer vertical (Y) coordinate relative to the form.
Project Manager
Row 1 – Object reference to the project.Row 2 – Object reference to the project.Row 3 – Zero.Row 4 – Zero.
X# Desktop
Row 1 – Object reference to the desktop.Row 2 – Object reference to the desktop.Row 3 – Mouse pointer horizontal (X) coordinate relative to the desktop.Row 4 – Mouse pointer vertical (Y) coordinate relative to the desktop.
AMOUSEOBJ( ) returns 4 (the number of rows in the array) if you position the mouse pointer over an area listed above. If you position the mouse pointer over an area other than those listed above, AMOUSEOBJ( ) returns zero. If the array you specify already exists, it remains unchanged. If the array you specify does not exist, the system does not create it.
</remarks>
</amouseobj>
<anetresources>
<summary>
Places the names of network shares or printers into an array and then returns the number of resources.
</summary>
<param name="ArrayName">

Specifies the name of the array containing the network share or printer information. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain all the information, X# automatically increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array.
If the array exists and ANETRESOURCES( ) returns 0 because no network shares or printers are found, the array remains unchanged. If the array doesn't exist and ANETRESOURCES( ) returns 0, the array isn't created. 

</param>
<param name="cNetworkName">

Specifies the name of the network or domain for which share or printer information is returned. The network name should be in the format "\\NetworkName." You do not have to be connected to the network you specify, and specifying a network doesn't connect you to the network. If you specify a domain name, ANETRESOURCES( ) returns an array of members or resources from that domain.

</param>
<param name="nResourceType">

Specifies the type of network resource for which information is returned. The names of shares on the network are returned if nResourceType evaluates to 1. The names of printers on the network are returned if nResourceType evaluates to 2. A value of 0 returns the name of any resource.
</param>
<returns>
Numeric
</returns>
<remarks>
ANETRESOURCES( ) returns the number of network shares or printers found (identical to the number of rows in the array). ANETRESOURCES( ) returns zero if there are no shares or printers for the network of the type you specify, or the network you specify doesn't exist.
Before Windows 2000, share names were limited to twelve characters in length. If you run ANETRESOURCES() on a computer that uses an operating system earlier than Windows 2000, ANETRESOURCES() will not return any shares that are on computers running Windows 2000 or later that have share names longer than twelve characters.
Refer to the WNetOpenEnum and WNetEnumResource Win32 API functions for more details.
</remarks>
</anetresources>
<ansitooem>
<summary>
Included for backward compatibility. Use CPCONVERT( ) Function instead.
Converts each character of a character expression to the corresponding character in the MS-DOS (OEM) character set.
</summary>
<returns>
Return value - Character
</returns>
<remarks>
<br />
ANSITOOEM() is supported in FoxPro for Windows and FoxPro for Macintosh.<br />
<br />
Use ANSITOOEM() to move data from FoxPro for Windows and FoxPro for Macintosh to FoxPro for MS-DOS. ANSITOOEM() converts each character in expC to the corresponding character in the MS-DOS (OEM) character set. The character expression expC should contain characters from the ANSI character set.<br />
<br />
If a character in expC doesn't have an MS-DOS equivalent, the character is converted to a similar MS-DOS character.<br />
<br />

</remarks>
</ansitooem>
<aprinters>
<summary>
Stores information about currently-available printers into an array.
The behavior of this function is OS (operating system) - specific.  X# may or may not check to see if the printers are actually connected to your computer when it prepares this list, and the list may include all printers installed as printer setups, or only those available on the current network.
</summary>
<param name="ArrayName">

Specifies the name of the array containing information about printers. 
If the array you include does not exist, X# automatically creates the array. If the array exists but is not large enough to contain all the information, X# increases the size of the array to accommodate the information. If the array is larger than necessary, X# truncates the array. If the array exists but <b>APRINTERS( )</b> returns 0 because no printers are available, the array remains unchanged. If the array does not exist, and <b>APRINTERS( )</b> returns 0, the array is not created.
[, nValue] 
Specifies a value that creates a two-column array or five-column array. Each row in the array contains information about a printer.
The following table describes the possible values of nValue.
</param>
<param name="nValue">
0 or omitted
Return a two-column array containing the following items beginning with the first column:
Printer name.
Name of the port to which the printer is connected.
1
Return a five-column array containing the following items beginning with the first column:
Name of the printer driver.
Printer comment.
Printer location.
</param>
<returns>
Numeric. <b>APRINTERS( )</b> returns the number of rows in the array or 0 when no printers are available.
</returns>
<example>
 <code language="X#">IF APRINTERS(gaPrinters) &gt; 0
CLEAR  &amp;&amp; clear the current output window
DISPLAY MEMORY LIKE gaPrinters &amp;&amp; show the contents of the array
ELSE
WAIT WINDOW 'No printers found.'
ENDIF</code>
</example>
</aprinters>
<aprocinfo>
<summary>
Creates an array containing X# language elements contained in a program file.
</summary>
<param name="ArrayName">

Specifies the name of the array to be created.

</param>
<param name="cFileName">

Specifies the filename of the program that this function traverses.

</param>
<param name="nType">

Specifies the type of information returned in cArrayName. The following table specifies valid nType values and describes the information returned by each nType value.
0 (default
Populates the array with all document information.
Column1 – Doc View content
Column2 – line
Column3 – type
Column4 – indentation
 Indentation is used with preprocessor directives to show nested levels of #IF type statements.
Populates the array with only the class definitions in the document.
Column1 – class name
Column3 – parentclass
Column4 - is OLEpublic
Populates the array with only class procedure information (class definition excluded)
Populates the array with #define and other preprocessor directives in the document.
The following table describes the "type" values returned in Column3 for nType values of 0 and 3.    
Define
#DEFINE preprocessor directive
Directive
Other preprocessor directives, such as #IF
Class
Class definition line
Procedure
Procedure, Method or Event
</param>
<returns>
Numeric. APROCINFO( ) returns the number of rows added to the array.
</returns>
<remarks>
X# automatically creates the array you specify if it doesn't already exist. X# automatically increases or truncates the size of the array to accommodate the returned information. This function supports program (PRG) files only.
</remarks>
</aprocinfo>
<asc>
<summary>
Returns the ANSI value for the leftmost character in a character expression.
</summary>
<param name="cExpression">

Specifies the character expression containing the character whose ANSI value ASC( ) returns. Any characters after the first character in cExpression are ignored by ASC( ).
</param>
<returns>
Numeric
</returns>
<remarks>
ASC( ) returns the position of the character in the character table of the current code page. Every character has a unique ANSI value in the range from 0 to 255.
</remarks>
<example>
 <code language="X#">STORE 'ABCDEFGHIJ' TO gcANSI  &amp;&amp; 10 characters
CLEAR
FOR nCOUNT = 1 TO 10
? SUBSTR(gcANSI, nCount,1)  &amp;&amp; Display a character
?? ASC(SUBSTR(gcANSI, nCount)) &amp;&amp; Display ANSI value
ENDFOR</code>
</example>
</asc>
<ascan>
<summary>
Searches an array for an element containing the same data and data type as an expression.
</summary>
<param name="ArrayName">

Specifies the name of the array to search.

</param>
<param name="eExpression">

Specifies the general expression to search for.

</param>
<param name="nStartElement">

Specifies the element number at which the search begins. The element number you specify is included in the search. If you omit nStartElement or if you pass negative value on its place, the entire array is searched by default. 

</param>
<param name="nElementsSearched">

Specifies the number of elements that are searched. If you omit nStartElement and nElementsSearched or if you pass negative value on its place, the search begins with the first array element and continues to the last array element if you do not specify nSearchColumn. 
You can refer to an element in a two-dimensional variable array in one of two ways. The first method uses two subscripts to specify the row and column position of the element in the array; the other method uses an element number. This function and others that manipulate two-dimensional arrays require element numbers (nStartElement and nElementsSearched). Use AELEMENT( ) to return the element number from row and column subscripts in a two-dimensional array.

</param>
<param name="nSearchColumn">

Specifies the array column to search. This is often useful in arrays created by functions such as AFIELDS( ).
You can use 0 or a negative number for nSearchColumn to impose a search of the entire array. If you use a value greater than 0 for nSearchColumn, ASCAN( ) treats the specified column as a one-dimensional array, using each data row as an element in the search. For instance, the following example searches only the third and fourth elements of column 2 instead of the entire array.   
 <code language="X#">? ASCAN(abc,"M",3,2,2)</code>
X# generates an error if nSearchColumn is a number larger than the number of available columns. 
<code language="X#">? ASCAN(abc,"HELLO",-1,-1,2,15) &amp;&amp; Search the whole column 2 of two-dimensional array</code>
nFlags

Specifies additional search criteria to apply to the scan function. Default scans are case-sensitive.
The number you specify in nFlags provides a bit-value that determines the case sensitivity or exactness setting of a scan according to the following table:   
NFlag
0000
Behavior existing in X# 6 or earlier
0001
Case Insensitive
0010
Current behavior existing in the previous version of X#
0011
4
0100
Exact OFF
0101
Case Insensitive; Exact OFF
0110
Exact ON
7
0111
Case Insensitive; Exact ON
8
1000
Return row number
9
1001
Case Insensitive; return row number
1010
1011
12
1100
Return row number; Exact OFF
13
1101
Case Insensitive; Return row number; Exact OFF
14
1110
Return row number; Exact ON
1111
Case Insensitive; Return row number; Exact ON
The bit values are as follows:
Case Insensitive bit 
Exactness ON bit (Only effective if bit 2 is set)
Override system Exact setting bit
Return row number if 2D array
nFlags applies only to the ASCAN( ) function and does not affect settings for SET EXACT.
</param>
<returns>
Numeric
</returns>
<remarks>
If a match is found, ASCAN( ) returns the number of the element containing the expression. If a match cannot be found, ASCAN( ) returns 0.
The criteria for a successful match of character data are determined by the setting of the system SET EXACT if nFlag with bit 2 is not set. If SET EXACT is ON, an element must match the search expression character for character and have the same length. If SET EXACT is OFF, and an element and search expression match until the end of the expression is reached, the match is successful. For more information on match criteria for character strings, see the string comparison table in the SET EXACT Command topic.
In X# 6.0, the nStartElement and nElementsSearched parameters are optional. The nStartElement must be &gt; 0 while nElementsSearched can be any value. In order to accommodate the nSearchColumn parameter, you will need to bypass these parameters by passing a value of -1.
The nStartElement and nElementsSearched parameters take on special meaning if the value of nSearchColumn is greater than 0. In X# 6.0, they are always referenced to the entire array. Beginning with X# 7.0, if a positive nSearchColumn is passed, the values of nStartElement and nElementsSearched are referenced to the single one-dimensional array represented by the nSearchColumn. For example, the following would only search the third and fourth elements of column 2, and not the entire array:
 <code language="X#">? ASCAN(abc,"M",3,2,2)</code>
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer     &amp;&amp; Open customer table
SELECT company FROM customer ;
WHERE country = 'UK' ;
INTO ARRAY gaCompanies
gnCount = _TALLY
gcName = 'Seven Seas Imports'
CLEAR
DISPLAY MEMORY LIKE gaCompanies*
gnPos = ASCAN(gaCompanies, gcName) &amp;&amp; Search for company
IF gnPos != 0
*** Company found, remove it from the array ***
= ADEL(gaCompanies, gnPos)
gnCount = gnCount - 1
ENDIF
DISPLAY MEMORY LIKE gaCompanies</code>
</example>
</ascan>
<aselobj>
<summary>
Places an object reference for the currently selected control or container that exists in the Form Designer, Class Designer, or code editing window into a specified variable array. When calling ASELOBJ( ) in a code editing window, the array also includes elements for forms (.scx), visual class libraries (.vcx), and #INCLUDE file names. You can also use ASELOBJ( ) to create control builders.
</summary>
<param name="ArrayName">

Specifies the name of the array you want to use. 
1 
Creates a one-element array containing an object reference to the container for the currently active and selected control. 
For example, if the currently active and selected control is a spinner on a form, the array contains an element with the value "FORM." When calling ASELOBJ( ) in the Command window, include this argument.    
When a page frame is selected, ASELOBJ() returns the name of the current page.
2 
Creates a one-element array containing an object reference to the DataEnvironment object for the form. The DataEnvironment object makes it possible for you to determine the data environment properties of the form.
3 
Creates three-element array containing information in context with the currently active code editing window: object reference to a container object, the full path and name of the .scx or .vcx file, and the full path and name of the #INCLUDE file, if available. 
The following table shows the order in which these elements appear.   
Object reference to container object
Full path and name of .scx or .vcx file
Full path and name of #INCLUDE file, if available
If no #INCLUDE file is available, the third element contains an empty string.
</param>
<returns>
Numeric data type. ASELOBJ( ) returns the number of objects selected. The array contains three columns and a row for each selected object. .
</returns>
<remarks>
If no controls are selected, and the argument, 1, is omitted, ASELOBJ( ) returns 0 and does not create the array. If no controls exist on the form, ASELOBJ( ) does not recognize the form as the selected control. If no controls are currently selected and the argument, 1, is included, ASELOBJ( ) returns 1.
If the array does not exist, X# automatically creates the array. 
If the array exists but is too small to contain all the information, X# automatically increases the size of the array to accommodate the information. If the array is larger than needed, X# truncates the array. 
If the array exists, and ASELOBJ( ) returns 0 because no controls are selected, the array remains unchanged. If the array does not exist, and ASELOBJ( ) returns 0, the array is not created.
</remarks>
<example>
 <code language="X#">gnobjects = ASELOBJ(gaSelected)     &amp;&amp; Create array of control names
IF gnobjects &gt; 0  &amp;&amp; 0 indicates no controls selected
CLEAR
DISPLAY MEMORY LIKE gaSelected     &amp;&amp; Displays selected controls
FOR nCnt = 1 TO gnobjects
? gaSelected(nCnt).Caption + ' =&gt; New Caption ' ;
+ LTRIM(STR(nCnt))  &amp;&amp; Display old and new caption
gaSelected(nCnt).Caption = 'New Caption ' ;
+ ALLTRIM(STR(nCnt))  &amp;&amp; Assign new caption
NEXT
ENDIF</code>
</example>
</aselobj>
<asessions>
<summary>
Creates an array of existing data session IDs.
</summary>
<param name="ArrayName">

Specifies the array that contains the data session IDs.
</param>
<returns>
Numeric. Returns the number of data sessions.
</returns>
<remarks>
If the array does not exist, X# automatically creates and populates it. X# automatically resizes the array to accommodate current data sessions.
</remarks>
</asessions>
<asin>
<summary>
Returns in radians the arc sine of a numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression whose arc sine ASIN( ) returns. The value of nExpression can range from +1 through –1, and the value ASIN( ) returns can range from –pi/2 through +pi/2 ( –1.57079 to 1.57079). The number of decimal places in the display of the result can be specified with SET DECIMALS.
</param>
<returns>
Numeric
</returns>
<remarks>
Use RTOD( ) to convert radians to degrees.
</remarks>
<example>
 <code language="X#">CLEAR
? RTOD(ASIN(0))  &amp;&amp; Returns 0.00
STORE 1 to gnArcAngle
? RTOD(ASIN(gnArcAngle))  &amp;&amp; Returns 90.00
? RTOD(ASIN(SQRT(2)/2))  &amp;&amp; Returns 45.00</code>
</example>
</asin>
<asort>
<summary>
Sorts elements in an array in ascending or descending order.
</summary>
<param name="ArrayName">

Specifies the name of the array to sort.

</param>
<param name="nStartElement">

Specifies the starting element of the sort. If you omit nStartElement, the array is sorted starting with the first array element by default. If the array is one-dimensional, the sort includes nStartElement. If the array is two-dimensional, the starting element nStartElement determines both the row where the sort begins and the column that determines the sort order of the rows.
You can refer to an element in a two-dimensional array in one of two ways. The first method uses two subscripts to specify the row and column position of the element in the array; the other method uses an element number. This function and others that manipulate two-dimensional arrays require element numbers (in ASORT() the numeric expressions nStartElement and nNumberSorted). You can use AELEMENT( ) to return the element number from row and column subscripts in a two-dimensional array.
The following example illustrates that the starting element nStartElement determines how the rows in a two-dimensional array are sorted. A small array named codegaArray/code is created and sorted twice. The first sort begins with the first element of codegaArray/code; the rows are sorted based on the values contained in the first column of the array. The second sort begins with the fourth element of codegaArray/code; the rows are sorted based on the values contained in the second column.   
The first sort begins with the first row. The second sort begins with the second row. You can use DISPLAY MEMORY to display the contents of the array; in these examples tables are used to graphically display the results of the sorts.   
These commands create the array named codegaArray/code:   
 <code language="X#">DIMENSION gaArray(3,2)
gaArray(1) = 'G'
gaArray(2) = 'A'
gaArray(3) = 'C'
gaArray(4) = 'Z'
gaArray(5) = 'B'
gaArray(6) = 'N'</code>
codegaArray/code looks like this:   
Row 1
Row 2
Row 3
The array is then sorted by ASORT( ) starting with the first element (1,1) in the array. The elements in the first column are placed in ascending order by rearranging the rows of the array.   
 <code language="X#">=ASORT(gaArray,1)</code>
Note the new order of the rows:   
The array is then sorted starting with the fourth element (2,2) in the array. The elements in the second column are placed in order by rearranging the array rows.   
 <code language="X#">=ASORT(gaArray,4)</code>
Note the difference in the order of the rows:   

</param>
<param name="nNumberSorted">

Specifies the number of elements that are sorted in a one-dimensional array, or the number of rows that are sorted in a two-dimensional array. For example, if the array is one-dimensional and nStartElement is 2, indicating that the sort starts with the second array element, and nNumberSorted is 3, indicating that the sort should include three elements, the second, third and fourth array elements are sorted. If nNumberSorted is –1 or is omitted, all array elements from the starting element nStartElement through the last element in the array are sorted.
If the array is two-dimensional, nNumberSorted designates the number of rows to sort, beginning with the row containing the starting element nStartElement. For example, if nStartElement is 2 and nNumberSorted is 3, the row containing the second array element and the following two rows are sorted. If nNumberSorted is –1 or is omitted, all array rows beginning with the row containing the starting element nStartElement through the last array row are sorted. 

</param>
<param name="nSort">

Specifies the sort order (ascending or descending) for the elements in the array. By default, array elements are sorted in ascending order. If nSortOrder is 0 or is omitted, the array elements are sorted in ascending order. If nSortOrder is any positive value, the array elements are sorted in descending order.

</param>
<param name="nFlags">

Specifies case-sensitive search criteria to apply to the sort function. Valid values are 0 (the default) and 1. ASORT( ) uses the current collate sequence (see SET COLLATE Command) to determine the sort order. Certain collate sequences (such as "GENERAL") are not case-sensitive, and specifying nFlags = 0 will not cause a case-sensitive sorting. 
The nFlags parameter is only useful when the current collate sequence is case-sensitive (such as "MACHINE"), and you wish to do a non-case-sensitive sort.   
The number you specify in nFlags provides a bit-value that determines the case sensitivity of a sort according to the following table:   
nFlag
000
Case-sensitive sort
001
Case insensitive sort
If you specify nFlags, you can omit the other parameters by passing them in as -1.
</param>
<returns>
Numeric
</returns>
<remarks>
All elements included in the sort must be of the same data type. One-dimensional arrays are sorted by their elements; two-dimensional arrays are sorted by their rows. When a two-dimensional array is sorted, the order of the rows in the array is changed so that the elements in a column of the array are in ascending or descending order.
If the sort is successful, 1 is returned; otherwise –1 is returned.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer  &amp;&amp; Open customer table
COUNT TO gnCount  &amp;&amp; Number of contacts
DIMENSION gaContact(gnCount,1)  &amp;&amp; Create a contact array
COPY TO ARRAY gaContact FIELD contact     &amp;&amp; Fill the array
CLEAR
? 'Contact names:'
?
FOR nCount = 1 TO 20
? gaContact(nCount)  &amp;&amp; Display first 20 contacts
ENDFOR
= ASORT(gaContact)     &amp;&amp; Sort the array
?
? 'Sorted Contact names:'
?
FOR nCount = 1 TO 20
? gaContact(nCount)  &amp;&amp; Display first 20 contacts, sorted
ENDFOR</code>
</example>
</asort>
<asqlhandles>
<summary>
Stores numeric references to all active SQL connection statement handles in an array.
</summary>
<param name="ArrayName">

Specifies the name of an array to store statement handle information. 
If the array you specify does not exist, X# creates the array automatically. If the array exists and is not large enough to store the information, X# increases the array size automatically. If the array is larger than necessary, X# truncates the array. 

</param>
<param name="nStatementHandle">

Populates the array with statement handles that use the same shared connection, including nStatementHandle.
</param>
<returns>
Numeric. <b>ASQLHANDLES( )</b> returns the number of statement handles in use. If no statement handles are available, <b>ASQLHANDLES( )</b> returns 0 and does not modify the array.
</returns>
<remarks>
You can use references to statement handles in other X# SQL functions, such as <b>SQLEXEC( )</b> and <b>SQLDISCONNECT( )</b>. For more information, see SQLEXEC( ) Function and SQLDISCONNECT( ) Function.
You can create and return new statement handles using the <b>SQLCONNECT( )</b> and <b>SQLSTRINGCONNECT( )</b> functions. For more information, see SQLCONNECT( ) Function and SQLSTRINGCONNECT( ) Function.
</remarks>
</asqlhandles>
<astackinfo>
<summary>
Creates an array and populates it with information about the current state of the call stack.
</summary>
<param name="ArrayName">

Specifies the name of the array to store information about the call stack. 
The following table describes the information returned by the ASTACKINFO( ) function:   
1
Call Stack Level 
2
Current program filename 
3
Module or Object name 
4
Module or Object Source filename 
5
Line number in the object source file
6
Source line contents
</param>
<returns>
Numeric
</returns>
<remarks>
ASTACKINFO( ) populates an array with information about the entire calling stack. It combines functionality of SYS(16) and PROGRAM( ) functions while adding new support for line numbers at each call stack level. The value returned is the number of program levels or rows of the returned array.
ASTACKINFO( ) only populates the 6th array element if source line contents are available, otherwise it will be left empty.
ASTACKINFO( ) provides, in the 2nd and 4th elements respectively, the name of the current file and, if the file is bound in an APP or other separate file, a full path name to the binding program. 
The 4th element contains the original source file information. For objects, this is same information returned by SYS(16), even when bound inside of applications. 
ASTACKINFO() might not be able to retrieve information about program (.prg) files. In this case, X# displays the 2nd element similar to the SYS(16) function. For more information, see SYS(16) - Executing Program File Name.
</remarks>
<example>
 <code language="X#">ASTACKINFO(myarray)
DISPLAY MEMO LIKE myarray
myArray
(1,1)   1                                    &amp;&amp; Stack level = 1
(1,2)   c:\vfp\myAppl.app                        &amp;&amp; Current program
(1,3) frmRerport.PrintReport.Click         &amp;&amp; Object
(1,4) c:\vfp\myclasses\buttons.vct         &amp;&amp; Object source file name
(1,5) 42                              &amp;&amp; Line number in the source
(1,6) THISFORM.DoReport()                  &amp;&amp; in the source
(2,1)   2                                    &amp;&amp; Stack level = 2
(2,2) c:\vfp\myAppl.app
(2,3) frmRerport.DoReport
(2,4) c:\vfp\forms\frmRerport.sct         &amp;&amp; Module source file name
(2,5) 31
(2,6) DO RunListReport                     &amp;&amp; in the source
(3,1)   3                                    &amp;&amp; Stack level = 3
(3,2) c:\vfp\myAppl.app
(3,3)
(3,4) c:\vfp\programs\runlisterport.prg   &amp;&amp; Module source file name
(3,5) 12
(3,6) REPORT FORM myreport1.frx            &amp;&amp; in the source
(4,1)   4                                    &amp;&amp; Stack level = 4
(4,2) c:\vfp\reports\myreport1.frt
(4,3) myreport1.DataEnvironment.BeforeOpenTables
(4,4) c:\vfp\reports\myreport1.frt          &amp;&amp; Module source file name
(4,5) 31
(4,6) DO FORM getcusts                     &amp;&amp; in the source
(5,1)   5                                    &amp;&amp; Stack level = 5
(5,2) c:\vfp\myAppl.app
(5,3) getcusts.init
(5,4) c:\vfp\forms\getcusts.sct            &amp;&amp; Module source file name
(5,5) 2
(5,6) ASTACKINFO(myarray)                  &amp;&amp; in the source </code>
</example>
</astackinfo>
<asubscript>
<summary>
Returns the row or column subscript of an element from the element's number.
</summary>
<param name="ArrayName">

Specifies the name of the array.

</param>
<param name="nElementNumber">

Specifies the element number.

</param>
<param name="nSubscript">

Determines if the row or column subscript is returned.
If the array is one-dimensional, include the element number in nElementNumber and 1 in nSubscript. ASUBSCRIPT( ) identically returns nElementNumber.   
If the array is two-dimensional, include both the element number nElementNumber and a value of 1 or 2 in nSubscript. Specifying 1 in nSubscript returns the row subscript of the element, and specifying 2 returns the column subscript.   
For more information on how to reference elements in an array, see DIMENSION.
</param>
<returns>
Numeric
</returns>
<remarks>
You can refer to elements in two-dimensional variable arrays in one of two ways. The first method uses two subscripts to specify the row and column position of the element in the array. The second method uses an element number. Use ASUBSCRIPT( ) to obtain an element's row or column subscript from the element's number.
In the following example, an array with two rows and three columns is created. DISPLAY MEMORY shows the contents of the elements of the array listed in element number order.
 <code language="X#">DIMENSION gaMyArray(2,3)
DISPLAY MEMORY LIKE gaMyArray
GAMYARRAY  Pub  A
( 1, 1)   L  .F. (element number 1)
( 1, 2)   L  .F. (element number 2)
( 1, 3)   L  .F. (element number 3)
( 2, 1)   L  .F. (element number 4)
( 2, 2)   L  .F. (element number 5)
( 2, 3)   L  .F. (element number 6)</code>
Each of these commands stores the character string INVOICE to the same array element:
 <code language="X#">STORE 'INVOICE' TO gaMyArray(2, 1)
STORE 'INVOICE' TO gaMyArray(4)</code>
In one-dimensional arrays, an element's number is identical to its single row subscript. It isn't necessary to use ASUBSCRIPT( ) with one-dimensional arrays.
</remarks>
</asubscript>
<at>
<summary>
Searches a character expression for the occurrence of another character expression. 
The search performed by <b>AT( )</b> is case-sensitive. To perform a search that is not case-sensitive, use <b>ATC( )</b>. For more information, see ATC( ) Function.
</summary>
<param name="cSearchExpression">

Specifies the character expression to search for in cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression to search for cSearchExpression. 
Both cSearchExpression and cExpressionSearched can be memo fields of any size. 

</param>
<param name="nOccurrence">

Specifies which occurrence, first, second, third, and so on, of cSearchExpression to search for in cExpressionSearched. By default, <b>AT( )</b> searches for the first occurrence of cSearchExpression (nOccurrence = 1).
</param>
<returns>
Numeric. <b>AT( )</b> returns an integer indicating the position of the first character for a character expression or memo field within another character expression or memo field, beginning from the leftmost character. If the expression or field is not found, or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched, <b>AT( )</b> returns 0.
</returns>
<example>
 <code language="X#">STORE 'Now is the time for all good men' TO gcString
STORE 'is the' TO gcFindString
CLEAR
? AT(gcFindString,gcString)  &amp;&amp; Displays 5
STORE 'IS' TO gcFindString
? AT(gcFindString,gcString)  &amp;&amp; Displays 0, case-sensitive</code>
</example>
</at>

<ataginfo>
<summary>
Creates an array that contains information about index files for the selected table.
</summary>
<param name="ArrayName">

Specifies the name of the array to create. X# creates the array if it does not already exist.

</param>
<param name="cCDXName">

Specifies the name of the compound index (.cdx) file to return information for. 
Specifying an empty string ("") returns the number of tags in all open .cdx files and all open standalone index (.idx) files for the selected table.

</param>
<param name="uArea">
  Specifies the work area number or workarea alias that contains the table to returns information for. <br/>
  Omitting this uses the table in the current work area.

</param>
<returns>
Numeric. <b>ATAGINFO( )</b> returns the number of index tags in compound index (.cdx) files or open single-key standalone index (.idx) files for the current table.
</returns>
<remarks>
The following table describes the information stored in the array that <b>ATAGINFO( )</b> creates.
1
Index tag name in a .cdx file or index file name for .idx files
Character
2
Index tag type 
Character
3
Index key expression
Character
4
Filter expression
Character
5
Index order as created (Ascending or Descending)
Character
6
Collate sequence
Character
</remarks>
</ataginfo>
<atan>
<summary>
Returns in radians the arc tangent of a numeric expression.
</summary>
<param name="nExpression">

Specifies a numeric expression whose arc tangent ATAN( ) returns. nExpression can be any value. The value returned by ATAN( ) can range from –pi/2 through +pi/2 (–1.57079 to 1.57079). The number of decimal places displayed in the value returned by ATAN( ) is determined by SET DECIMALS.
</param>
<returns>
Numeric
</returns>
<remarks>
Use RTOD( ) to convert radians to degrees.
</remarks>
<example>
 <code language="X#">CLEAR
? ATAN(0)  &amp;&amp; Displays 0.00
STORE PI( )/2 to gnAngle
? ATAN(gnAngle)  &amp;&amp; Displays 1.00
? ATAN(PI( )/2)  &amp;&amp; Displays 1.00
? ATAN(DTOR(90))  &amp;&amp; Displays 1.00</code>
</example>
</atan>
<atc>
<summary>
Returns the beginning numeric position of the first occurrence of a character expression or memo field within another character expression or memo field, without regard for the case of these two expressions.
</summary>
<param name="cSearchExpression">

Specifies the character expression that ATC( ) searches for in cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression cSearchExpression searches for.
Both cSearchExpression and cExpressionSearched can be memo fields of any size. 

</param>
<param name="nOccurrence">

Specifies which occurrence (first, second, third, and so on) of cSearchExpression is searched for in cExpressionSearched. By default, ATC( ) searches for the first occurrence of cSearchExpression (nOccurrence = 1). Including nOccurrence lets you search for additional occurrences of cSearchExpression in cExpressionSearched.
</param>
<returns>
Numeric
</returns>
<remarks>
ATC( ) searches the second character expression for the occurrence of the first character expression, without concern for the case (upper or lower) of the characters in either expression. Use AT( ) to perform a case-sensitive search.
ATC( ) returns an integer corresponding to the position where the first character of the character expression is found. If the character expression isn't found, ATC( ) returns 0.
</remarks>
<example>
 <code language="X#">STORE 'Now is the time for all good men ... ' TO gcString
STORE 'IS THE' TO gcFindString
CLEAR
? ATC(gcFindString, gcString)  &amp;&amp; Displays 5
STORE 'is' TO gcFindString
? ATC(gcFindString, gcString)  &amp;&amp; Displays 5
? ATC('now',gcString)  &amp;&amp; Displays 1</code>
</example>
</atc>
<atcline>
<summary>
Returns the line number of the first occurrence of a character expression or memo field within another character expression or memo field, without regard for the case (upper or lower) of the characters in either expression.
</summary>
<param name="cSearchExpression">

Specifies the character expression that ATCLINE( ) searches for in cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression cSearchExpression searches for.
Both cSearchExpression and cExpressionSearched can be memo fields of any size. Use MLINE( ) to return the line containing the matching character expression.   
ATCLINE() offers a convenient way to search memo fields.
</param>
<returns>
Numeric
</returns>
<remarks>
If the search is successful, ATCLINE( ) returns the number of the line containing the first character expression. If the search is unsuccessful, ATCLINE( ) returns 0.
The line number that ATCLINE( ) returns is determined by the value of SET MEMOWIDTH, even if cExpressionSearched isn't a memo field. For more information, see SET MEMOWIDTH.
Use ATLINE( ) to perform a case-sensitive search.
</remarks>
<example>
 <code language="X#">* Example 1
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE employee  &amp;&amp; Open employee table
CLEAR
STORE 'JAPANESE' TO gcFindString  &amp;&amp; Case insensitive
LOCATE FOR ATCLINE(gcFindString, notes) != 0
? First_Name
?? Last_Name
? MLINE(notes, ATCLINE(gcFindString, notes))
* Example 2
STORE '1234567890ABCDEFGHIJ' TO gcString
SET MEMOWIDTH TO 20
? ATCLINE('AB', gcString)  &amp;&amp; Displays 1
SET MEMOWIDTH TO 10
? ATCLINE('AB', gcString)  &amp;&amp; Displays 2</code>
</example>
</atcline>
<atline>
<summary>
Returns the line number of the first occurrence of a character expression or memo field within another character expression or memo field, counting from the first line.
</summary>
<param name="cSearchExpression">

Specifies the character expression that X# looks for in cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression that cSearchExpression searches for.
Both cSearchExpression and cExpressionSearched can be memo fields of any size.   
Use MLINE( ) to return the line containing the matching character expression as a character string.   
ATLINE() offers a convenient way to search memo fields.
</param>
<returns>
Numeric
</returns>
<remarks>
ATLINE( ) searches the second character expression for the occurrence of the first character expression. ATLINE( ) performs a case-sensitive search. Use ATCLINE( ) to perform a search that isn't case-sensitive.
If the search is successful, ATLINE( ) returns the number of the line where the match occurs. If the search is unsuccessful, ATLINE( ) returns 0.
The line number that ATLINE( ) returns is determined by the value of SET MEMOWIDTH, even if cExpressionSearched isn't a memo field. For more information, see SET MEMOWIDTH Command.
</remarks>
<example>
 <code language="X#">* Example 1
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE employee  &amp;&amp; Open employee table
CLEAR
STORE 'Japanese' TO gcFindString  &amp;&amp; Case sensitive
LOCATE FOR ATLINE(gcFindString, notes) != 0
? First_Name
?? Last_Name
? MLINE(notes, ATLINE(gcFindString, notes))
* Example 2
STORE '1234567890ABCDEFGHIJ' TO gcString
SET MEMOWIDTH TO 20
? ATLINE('AB', gcString)  &amp;&amp; Displays 1
SET MEMOWIDTH TO 10
? ATLINE('AB', gcString)  &amp;&amp; Displays 2</code>
</example>
</atline>
<atn2>
<summary>
Returns the arc tangent in all four quadrants from specified values.
</summary>
<param name="nYCoordinate">

Specifies the y coordinate.

</param>
<param name="nXCoordinate">

Specifies the x coordinate.
</param>
<returns>
Numeric
</returns>
<remarks>
ATN2( ) returns the angle (in radians) between the line y = 0 and the line connecting the specified coordinates and the origin (0, 0) of the coordinate system.
ATN2( ) returns a value between – pi/2 and +pi/2.
You can convert the value returned by ATN2( ) to degrees with RTOD( ). You can specify the number of decimal places that are displayed in the result with SET DECIMALS.
</remarks>
<example>
 <code language="X#">CLEAR
? PI( )  &amp;&amp; Displays 3.14
? ATN2(0,-1)  &amp;&amp; Displays 3.14
STORE COS(PI( )) TO gnXCoord
STORE SIN(PI( )) TO gnYCoord
? ATN2(gnYCoord,gnXCoord)  &amp;&amp; Displays 3.14
? ATN2(gnYCoord,gnXCoord)/PI( )  &amp;&amp; Displays 1.00</code>
</example>
</atn2>
<aused>
<summary>
Places table aliases and work areas for a data session into a variable array.
</summary>
<param name="ArrayName">

Specifies the name of the array containing the table aliases and work areas for a data session. If the array you specify does not exist, X# automatically creates the array. If the array exists and is not large enough to contain all the table aliases and work areas, X# automatically increases the size of the array. If the array is larger than necessary, X# truncates the array. If the array exists, and <b>AUSED( )</b> returns 0 because no tables are open in the data session, the array remains unchanged. If the array does not exist, and <b>AUSED( )</b> returns 0, the array is not created.

</param>
<param name="nDataSessionNumber">

Specifies the data session number for which <b>AUSED( )</b> returns the table aliases and work areas. If you omit nDataSessionNumber, <b>AUSED( )</b> returns information about the current data session. Use <b>SET DATASESSION</b> to specify the current data session.

</param>
<param name="cTableName">

The array will only contain aliases of the table specified with cTableName.
The current data session is used if you set nDataSessionNumber to the null value (.NULL.).
cTableName can be in the following formats, listed in the order in which X# searches for tables.
DatabaseName!TableName or DatabaseName!ViewName.
Path\DatabaseName!TableName or Path\DatabaseName!ViewName.
Database container (DBC) defined table name or view in the current DBC in the data session.
Simple or full table name.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>AUSED( )</b> returns the number of rows in the array, which is identical to the number of tables open in the data session.

<b>AUSED( )</b> creates a two-dimensional array and places the aliases of tables open for the data session in the first column of the array. The second column of the array contains the tables' corresponding work area numbers.
The table aliases are placed into the array in reverse order that they were opened in. For example, the first array element contains the alias of the last table opened, and the last array element contains the alias of the first table opened. This ordering is useful when using <b>TABLEUPDATE( )</b> on views that contain views. For example:
 <code language="X#">FOR x = 1 TO AUSED(aTableAliases,1)
IF CURSORGETPROP( "Buffering", aTableAliases(x) ) &gt; 1 &amp;&amp; Buffered
? TABLEUPDATE( 0, .T., aTableAliases(x) )
ENDIF
NEXT</code>
</remarks>
<example>
 <code language="X#">OPEN DATABASE (HOME(2) + 'Data\testdata') EXCLUSIVE
USE Customer IN 0
CLEAR
? AUSED(gaInuse)
DISPLAY MEMORY LIKE gaInuse
CLOSE DATABASES</code>
</example>
</aused>
<avcxclasses>
<summary>
Places the information about classes in a class library into an array.
</summary>
<param name="ArrayName">

Specifies the name of the array in which the class information is placed. If the array you specify doesn't exist, X# automatically creates the array. If the array exists and isn't large enough to contain the class names and base classes, X# automatically increases the size of the array. If the array is larger than necessary, X# truncates the array.
The array contains a row for each class in the class library, and each row contains 11 columns containing information about the class. The following table lists the class information in each column.   
Class name.
OBJNAME
2
Base class of the class.
BASECLASS
3
Parent class name of the class.
4
Relative path and file name of the parent class library.
CLASSLOC
5
Relative path and file name of the bitmap for a custom class icon.
RESERVED4
6
Relative path and file name for a custom Project Manager or Class Browser class icon.
RESERVED5
7
ScaleMode of the class, Pixels or Foxels.
RESERVED6
8
Description of the class.
RESERVED7
9
Relative path and file name for the #INCLUDE file for the class.
RESERVED8
10
User-defined information for the class.
USER
Logical true (.T.) if the class is OLEPUBLIC, otherwise logical false (.F.).
RESERVED2

</param>
<param name="cLibraryName">

Specifies the name of the class library for which AVCXCLASSES( ) places class information into the array specified with ArrayName. cLibraryName can contain a path to the class library. An error is generated if the class library you specify doesn't exist.
</param>
<returns>
Numeric
</returns>
<remarks>
AVCXCLASSES( ) returns the number of rows in the array (the number of classes in the class library).
</remarks>
<example>
 <code language="X#">ACTIVATE SCREEN
CLEAR
? AVCXCLASSES(aClasses, '\VFP\SAMPLES\CLASSES\BUTTONS.VCX')
*** Displays 5
FOR nColCount = 1 TO ALEN(aClasses,2) &amp;&amp; Loop through columns
? aClasses(1, nColCount) &amp;&amp; Each column of the 1st class
NEXT
*** Displays the following:
*
* cmdCancel
* commandbutton
* cmdok
* buttons.vcx
* cancel.bmp
* cancel.bmp
* Pixels
* Release Form or Form Set
*
*
* .F.</code>
</example>
</avcxclasses>
<bar>
<summary>
Returns the number of the most recently chosen item from a menu defined with DEFINE POPUP or a menu item chosen from a X# menu.
</summary>
<returns>
BAR( )Return Value
Numeric
</returns>
<remarks>
Each item on a menu is assigned a number with DEFINE BAR. When a menu item is chosen from the menu, BAR( ) returns the number assigned to that item. A program can branch to other routines based on the value that BAR( ) returns.
BAR( ) returns 0 if there is no active menu or if the user presses ESC to exit the menu.
</remarks>
<example>
 <code language="X#">*** Name this program BAR_EXAM.PRG ***
CLEAR
SET SYSMENU SAVE
SET SYSMENU TO
DEFINE PAD padConv OF _MSYSMENU ;
PROMPT '\&lt;Conversions' COLOR SCHEME 3 ;
KEY ALT+C, ''
DEFINE PAD padCard OF _MSYSMENU ;
PROMPT 'Card \&lt;Info' COLOR SCHEME 3 ;
KEY ALT+I, ''
ON PAD padConv OF _MSYSMENU ACTIVATE POPUP popConv
ON PAD padCard OF _MSYSMENU ACTIVATE POPUP popCard
DEFINE POPUP popConv MARGIN RELATIVE COLOR SCHEME 4
DEFINE BAR 1 OF popConv PROMPT 'Ar\&lt;ea' KEY CTRL+E, '^E'
DEFINE BAR 2 OF popConv PROMPT '\&lt;Length' ;
KEY CTRL+L, '^L'
DEFINE BAR 3 OF popConv PROMPT 'Ma\&lt;ss' ;
KEY CTRL+S, '^S'
DEFINE BAR 4 OF popConv PROMPT 'Spee\&lt;d' ;
KEY CTRL+D, '^D'
DEFINE BAR 5 OF popConv PROMPT '\&lt;Temperature' ;
KEY CTRL+T, '^T'
DEFINE BAR 6 OF popConv PROMPT 'T\&lt;ime' ;
KEY CTRL+I, '^I'
DEFINE BAR 7 OF popConv PROMPT 'Volu\&lt;me' ;
KEY CTRL+M, '^M'
*** Here is where the POPCONV menu uses the BAR( ) function
*** to pass a bar number to the procedure called choice below.
ON SELECTION POPUP popConv;
DO choice IN bar_exam WITH BAR( ), POPUP( )
DEFINE POPUP popCard MARGIN RELATIVE COLOR SCHEME 4
DEFINE BAR 1 OF popCard PROMPT '\&lt;View Charges' ;
KEY ALT+V, ''
DEFINE BAR 2 OF popCard PROMPT 'View \&lt;Payments' ;
KEY ALT+P, ''
DEFINE BAR 3 OF popCard PROMPT 'Vie\&lt;w Users' ;
KEY ALT+W, ''
DEFINE BAR 4 OF popCard PROMPT '\-'
DEFINE BAR 5 OF popCard PROMPT '\&lt;Charges ';
KEY ALT+C
DEFINE BAR 6 OF popCard PROMPT '\-'
DEFINE BAR 7 OF popCard PROMPT 'E\&lt;xit ';
KEY ALT+X
*** Here is where the POPCARD menu uses the BAR( ) function
*** to pass a bar number to the procedure called choice below.
ON SELECTION POPUP popCard;
DO choice IN bar_exam WITH BAR( ), POPUP( )
*** The procedure choice uses the gnBar parameter
*** to contain the value passed by the BAR( ) function.
PROCEDURE choice
PARAMETERS gnBar, gcPopup
WAIT WINDOW 'You chose bar #' + LTRIM(STR(gnBar)) + ;
' from popup ' + gcPopup NOWAIT
SET SYSMENU TO DEFAULT</code>
</example>
</bar>
<barcount>
<summary>
Included for compatibility with dBASE.
 
</summary>
</barcount>
<barprompt>
<summary>
Included for compatibility with dBASE. 
 
</summary>
</barprompt>
<between>
<summary>
Determines whether the value of an expression is inclusively between the values of two expressions of the same type.
</summary>
<param name="eTestValue">

Specifies an expression to evaluate. 

</param>
<param name="eLowValue">

Specifies the lower value in the range.

</param>
<param name="eHighValue">

Specifies the upper value in the range.
</param>
<returns>
Logical or null. <b>BETWEEN( )</b> returns True (.T.) if the value of the specified expression is equal to one of the values or greater than the lower value and less than the higher value of the two expressions. Otherwise, <b>BETWEEN( )</b> returns False (.F.). <b>BETWEEN( )</b> returns a null value if eLowValue or eHighValue is a null value.
</returns>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE orders  &amp;&amp; Open order table
CLEAR
SCAN FOR BETWEEN(order_amt,950,1000)
? cust_id, order_amt
ENDSCAN</code>
</example>
</between>
<bindevent>
<summary>
Provides ability to execute user code (an object method) when an event occurs.
With the first form of the syntax below, you can use <b>BINDEVENT( )</b> to bind events, properties, or methods from native X# objects to other X# objects.
With the second syntax variation below, you can bind to Windows Message (Win Msg) events.
If you want to bind to events from Component Object Model (COM) objects, use the <b>EVENTHANDLER( )</b> function.
</summary>
<param name="oEventSource">

Specifies the event source, which must be a valid X# object.

</param>
<param name="hWnd">

Specifies the integer handle of the window that receives Windows Messages.
If a value of 0 is passed, the specified event (nMessage) is trapped for all windows.
You can use the hWnd Property (X#) to bind Windows Messages (events) received by _VFP, _SCREEN and instantiated form. ActiveX controls also have an hWnd property

</param>
<param name="cEvent">

Specifies the name of the event, method, or property you want to bind.

</param>
<param name="nMessage">

Specifies a valid Windows message that is trapped. See MSDN (the Microsoft Developer Network) for information about Windows messages.

</param>
<param name="oEventHandler">

Specifies the object, which must be a valid X# object, handling the event. 

</param>
<param name="cDelegate">

Specifies the method, or "delegate", that handles the event for oEventHandler.
The delegate method must have the same parameters as the event specified in cEvent. You can call the <b>AEVENTS( ) </b>function to retrieve an object reference to the event source. If the delegate method does not have enough parameters to handle those passed by the event, X# generates an error.
When trapping for Windows Message (Win Msg) events, the cDelegate method must include a PARAMETERS statement to accept four parameters that get passed to the method. The format of the parameters is identical to the format of the Windows WindowProc function. See MSDN (the Microsoft Developer Network) for information about the Windows WindowProc function. The method must return an integer value.

</param>
<param name="nFlags">

Specifies an additive bit flag you can set for the event binding operation.
The nFlags parameter is ignored when a Windows message event binding is created.
0
000
FoxPro object
Call delegate code before event code. (Default)
1
001
Call event code before delegate code. 
2
010
Do not trigger event (call delegate code) by simple method call.
3
011
Call event code before delegate code. Do not trigger event (call delegate code) when simple method calls occur.
4
100
Windows Message
Prevents recursion of similar events while user event code is executing. 
The following table shows whether an event is raised when Bit 1 is off or on.   
Interactive
YES
Programmatic
NO
<b>RAISEEVENT( )</b>

</param>
<returns>
Numeric data type. <b>BINDEVENT( )</b> returns the number of bindings for the object's event.
BINDEVENT( ) always returns 1 when a Windows message event binding is created. No error detection is performed, so if invalid hWnd and nMessage values are specified, 1 is still returned and the binding remains in effect until it is released.
</returns>
<remarks>
You can bind to any valid X# object event, property, or method, including the <b>Access</b> and <b>Assign</b> methods. However, the event and delegate methods must be public, not protected or hidden, members of the class.
You cannot bind to an event with parameters that are passed by reference. Though calling <b>BINDEVENT( )</b> succeeds, raising the event, for example, using <b>RAISEEVENT( )</b>, fails.
When you bind to a property, you should bind to it directly and not to the <b>Assign</b> method. If you bind directly to the <b>Assign</b> method, be aware that <b>Access</b> and <b>Assign</b> methods are marked as <b>Protected</b> and are not visible except within the class.
If you bind to a property that has an <b>Assign</b> method, the delegate method might trigger twice. The first time is when the property assignment call is made. The second time is when the property is actually set, within the <b>Assign</b> method, to the parameter that is passed. The delegate method should be aware of this possibility.
Normal rules of inheritance apply. If the delegate method does not contain any code, X# traverses up the parent hierarchy.
An event handler is called when an event occurs or if it is called as a method. Calling the event as a method triggers the event unless you specify an nFlags value of 2 or 3.
By default, X# calls the delegate method before the event. However, you can change the default behavior by using an nFlags setting.
If you specify a property as the event you want to bind, X# binds that property to an implicit <b>Assign</b> method. When the value of that property changes, X# triggers an event.
If an invalid parameter is passed, X# generates the error, "Function argument value, type, or count is invalid." However, if a problem occurs during the binding operation, X# does not generate an error. You can retrieve the return value of <b>BINDEVENT( )</b> to check the number of bindings.
Certain control events such as <b>GotFocus</b>, <b>LostFocus</b>, <b>InteractiveChange</b>, and <b>ProgrammaticChange</b> do not work if the second bit of the nFlags parameter is set, for example, nFlags set to 2. These events are treated as method calls internally by X#, even though they are considered events. The same behavior applies to the <b>Refresh</b> method of an object on a form that is called when the form's <b>Refresh</b> method is called. Certain events such as <b>When</b> and <b>Valid</b> require code in the event for it to occur.

<b>BINDEVENT( )</b> does not directly support the <b>Value</b> property because it is handled by X# in a special way. You should use the <b>InteractiveChange </b><b>ProgrammaticChange</b> events instead. Additionally, the <b>ActivePage</b> property is not supported.
If the original event contains a <b>NODEFAULT</b> command, X# still processes the event because it is possible that the delegate method is called before the event. <b>NODEFAULT</b> applies only to native X# events.
If you make an exact duplicate <b>BINDEVENT( )</b> call, X# disregards the call but still returns the number of bindings for the object's event. If you change the nFlags setting, you can call <b>BINDEVENT( )</b> to rebind the event.
When binding to Windows message (Win Msg) events, only one hWnd to Windows message pairing can exist. You can pass an hWnd value of 0 if you want to bind all windows to the same Windows message event. A Windows message event binding can be released with the UNBINDEVENTS( ) Function and the CLEAR Commands. Also, if the event handler object specified with the oEventHandler parameter no longer exists, the binding is released when its Windows message occurs.
With a Windows message event binding, your user code will execute whenever an event occurs including scenarios in which a modal dialog is displayed. This is because the Window Procedure must always process the message and return. Since it is possible for recursion to occur with an event while your user code is executing, you may want to specify an nFlags value of 4 to prevent this from happening.
A Windows message event binding should be used with care since your user code is bound to events being triggered by the Windows operating system and these events can occur at times when you do not expect them to.
</remarks>
<example>
 <code language="X#">PUBLIC oHandler
oHandler=NEWOBJECT("myhandler")
DO (_browser)
BINDEVENT(_SCREEN,"Resize",oHandler,"myresize")
DEFINE CLASS myhandler AS Session
PROCEDURE myresize
IF ISNULL(_obrowser) THEN
UNBINDEVENTS(THIS)
ELSE
_obrowser.left = _SCREEN.Width - _obrowser.width
ENDIF
RETURN
ENDDEFINE</code>
</example>
</bindevent>
<bintoc>
<summary>
Converts a numeric value to a binary character representation.
</summary>
<param name="nExpression">

Specifies the value to convert. For eFlags settings 1, 2 or 4, this value is an integer. Otherwise, the expression data type is based on the eFlags setting.

</param>
<param name="eFlags">

Specifies the length in characters of the returned character string. 
eFlags determines the value you can specify for nExpression. eFlags can either be numeric or character. The following table lists the permissible values for eFlags and the corresponding range of values for nExpression:
nExpression Range
1
–128 to 127
–32,768 to 32,767
4
–2,147,483,648 to 2,147,483,647
This is default setting.
The range of nExpression depends on its type. Only numeric, float, double, and currency data types are supported with this option. See X# Data and Field Types for the ranges of the numeric, float, double, and currency data types. 
BINTOC( ) returns 8 bytes for this setting.
nExpression is interpreted as a Float Field Type and BINTOC( ) returns 4 bytes.
nExpression is interpreted as a Double Field Type and BINTOC( ) returns 8 bytes.
Reverses the resulting binary expression.
Prevents the sign bit of number from being toggled (BITXOR).
If this parameter is omitted, BINTOC( ) returns a character string composed of four characters.
</param>
<returns>
Character. BINTOC( ) returns a binary character expression.
</returns>
<remarks>
The eFlags parameter can either be numeric or character. The 'R' and 'S' settings are additive while the others are mutually exclusive. Character settings can be passed in either upper or lower case (e.g., 'R' or 'r'). The following examples show various uses of the eFlags parameter.
 <code language="X#">? BINTOC(1,1)
? BINTOC(1000,"2")&amp;&amp; same as BINTOC(1000,2)
? BINTOC($12.34,8)
? BINTOC(1, "4RS")&amp;&amp; same as BINTOC(1,"RS")
? BINTOC(-100, "Fr")</code>
You can use BINTOC( ) to reduce the size of indexes for numeric fields containing integer data by passing a numeric eFlags parameter. For example, a numeric field named codenPartCode/code might contain an integer value from 1 to 32,767, which corresponds to a parts classification code. BINTOC( ) lets you convert the value in the numeric field to a smaller character representation. For example, the following command creates an index with a two-character index key:
 <code language="X#">INDEX ON BINTOC(nPartCode,2) TAG PartCode</code>
When using BINTOC( ) for an 8 byte index creation, you should use 8 and not "B". For 4 byte results, you should use 4 if nExpression is an integer type. Otherwise, you should use 'F' for floating point type.
BINTOC( ) can also be used when working with Win32 API routines where you might need to convert to or from a Win32 struct member. When used for indexing, BINTOC( ) needs to properly handle negative numbers for the resulting binary expression. This is done by using a BITXOR operation on the high bit. This also means that the most significant byte is first. For Win32 API routines on an Intel platform, the architecture follows the little-endian rule where the least significant byte is stored first (memory location with lowest address). The 'R' and 'S' settings allow you to use BINTOC( ) to work more efficiently with routines that use structs.
</remarks>
</bintoc>
<bitand>
<summary>
Performs a bitwise AND operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result. There is a numeric and a binary version of the syntax.
</summary>
<returns>

<b>Numeric</b> or <b>Varbinary</b>. <b>BITAND( )</b> returns the result of the bitwise AND operation performed on the specified expressions.
For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value up to the length of the longest value. The appropriate operation is then performed between those values.
</returns>
<remarks>

<b>BITAND( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If the bits in eExpressionN and eExpressionN+1 are both 1, the corresponding result bit is set to 1; otherwise, the corresponding result bit is set to 0.
The following table shows the result of a bitwise AND operation on corresponding eExpressionN and eExpressionN+1 bits:
0
0
0
0
1
0
1
1
1
1
0
0
</remarks>
<example>
 <code language="X#">x = 3  &amp;&amp; 0011 binary
y = 6  &amp;&amp; 0110 binary
? BITAND(x,y) &amp;&amp; Returns 2, 0010 binary</code>
</example>
</bitand>
<bitclear>
<summary>
Clears the specified bit in a <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> value by setting it to 0 and returns the resulting value. There is a numeric and a binary version of the syntax.
If the specified expression is not an integer, it is converted to an integer before performing the operation. 
</summary>
<param name="nNumericExpression1">

Specifies the <b>Numeric</b> value to clear the bit in. If the expression is not an integer, it is converted to an integer before setting the bit.

</param>
<param name="nNumericExpression2">

Specifies the bit position in nExpression1 to clear. nExpression2 can range from 0 to 31 with 0 located as the bit to the farthest right.

</param>
<param name="BinaryExpression">

Specifies a <b>Varbinary</b> or <b>Blob</b> expression.
[ nStartBit[, nBitCount]] 
Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.
If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. If you specify nStartBit only, the operation applies to nStartBit only.
</param>
<returns>

<b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BITCLEAR( )</b> returns the specified expression without specified bit.
</returns>
<example>
 <code language="X#">x = 7  &amp;&amp; 0111 binary
y = 1  &amp;&amp; 2nd bit position (0 = 1st bit position)
? BITCLEAR(x,y) &amp;&amp; Returns 5, 0101 binary</code>
</example>
</bitclear>
<bitlshift>
<summary>
Moves bits in a numeric value to the left by the specified number of positions and returns the resulting value.
If the specified expressions are not integers, they are converted to integers before performing the operation. 
</summary>
<param name="nExpression1">

Specifies the numeric value in which to move bits to the left. 

</param>
<param name="nExpression2">

Specifies the number of bit positions to move to the left.
</param>
<returns>
Numeric. <b>BITLSHIFT( )</b> returns the specified expression with bits moved by the specified number of positions.
</returns>
<remarks>

<b>BITLSHIFT( )</b>
<b> </b>does not support <b>Varbinary</b> values.
</remarks>
<example>
 <code language="X#">x = 5  &amp;&amp; 0101 binary
y = 1  &amp;&amp; Shift bits 1 position left
? BITLSHIFT(x,y) &amp;&amp; Returns 10, 1010 binary</code>
</example>
</bitlshift>
<bitnot>
<summary>
Performs a bitwise NOT operation on a value of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the bitwise complement on the specified value. There is a numeric and a binary version of the syntax.
If the specified expression is not an integer, it is converted to an integer before performing the operation.
</summary>
<param name="nNumericExpression">

Specifies a <b>Numeric</b> value to perform the bitwise NOT operation. 

</param>
<param name="BinaryExpression">

Specifies a <b>Varbinary</b> or <b>Blob</b> value to perform the bitwise NOT operation.
[ nStartBit[, nBitCount]] 
Specifies nStartBit as the starting zero-based number of the first bit to perform the operation and nBitCount as the number of bits to perform the operation.
If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. If you specify nStartBit only, the operation applies to nStartBit only.
</param>
<returns>

<b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BITNOT( )</b> returns the bitwise complement of the specified expression. In other words, the return value represents the specified expression with each 0 bit changed to 1 and each 1 bit changed to 0.
</returns>
<example>
 <code language="X#">x = 5  &amp;&amp; 0101 binary
? BITNOT(x) &amp;&amp; Returns -6</code>
</example>
</bitnot>
<bitor>
<summary>
Perform a bitwise inclusive OR operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result. There is a numeric and a binary version of the syntax.
</summary>
<returns>

<b>Numeric</b> or <b>Varbinary</b>. <b>BITOR( )</b> returns the result of a bitwise inclusive OR operation on the specified expressions.
For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value up to the length of the longest value. The appropriate operation is then performed between those values.
</returns>
<remarks>

<b>BITOR( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If either of the bits in eExpressionN and eExpressionN+1 is 1, the corresponding result bit is set to 1; otherwise, the corresponding result bit is set to 0.
The following table shows the result of an inclusive OR operation on corresponding eExpressionN and nExpressionN+1 bits:
0
0
0
0
1
1
1
0
1
1
1
1
</remarks>
<example>
 <code language="X#">x = 5  &amp;&amp; 0101 binary
y = 6  &amp;&amp; 0110 binary
? BITOR(x,y) &amp;&amp; Returns 7, 0111 binary</code>
</example>
</bitor>
<bitrshift>
<summary>
Moves bits in a numeric value to the right by the specified number of positions and returns the resulting value.
If the specified expressions are not integers, they are converted to integers before performing the operation. 
</summary>
<param name="nExpression1">

Specifies the numeric value in which to move bits to the right. 

</param>
<param name="nExpression2">

Specifies the number of bit positions to move to the right.
</param>
<returns>
Numeric. <b>BITRSHIFT( )</b> returns the specified expression with bits moved by the specified number of positions.
</returns>
<remarks>

<b>BITRSHIFT( ) </b>does not support <b>Varbinary</b> values.
</remarks>
<example>
 <code language="X#">x = 5  &amp;&amp; 0101 binary
y = 1  &amp;&amp; Shift bits 1 position right
? BITRSHIFT(x,y) &amp;&amp; Returns 2, 0010 binary</code>
</example>
</bitrshift>
<bitset>
<summary>
Sets a bit to 1 in a value of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the resulting value. There is a numeric and a binary version of the syntax.
If the specified expression is not an integer, it is converted to an integer before setting the bit.
</summary>
<param name="nNumericExpression1">

Specifies a <b>Numeric</b> value to set the bit. 

</param>
<param name="nNumericExpression2">

Specifies the position of the bit in nExpression1 to set to 1. nExpression2 can range from 0 to 31 with 0 as the bit farthest to the right. 

</param>
<param name="BinaryExpression">

Specifies a <b>Varbinary</b> or <b>Blob</b> expression.
[ nStartBit[, nBitCount]] 
Specifies a starting zero-based number of the first bit to perform the operation as nStartBit and the number of bits to perform the operation as nBitCount.
If you do not specify nStartBit and nBitCount, the operation applies to all bits in the expression. If you specify nStartBit only, the operation applies to nStartBit only.
</param>
<returns>

<b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b>. <b>BITSET( )</b> returns the specified expression with the specified bit set to 1.
</returns>
<example>
 <code language="X#">x = 5  &amp;&amp; 0101 binary
y = 1  &amp;&amp; 2nd bit position (0 = 1st bit position)
? BITSET(x,y) &amp;&amp; Returns 7, 0111 binary</code>
</example>
</bitset>
<bittest>
<summary>
Determines whether a specific bit in a <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> value is set to 1. There is a numeric and a binary version of the syntax.
If the specified expression is not an integer, it is converted to an integer before performing the operation. 
</summary>
<param name="nNumericExpression1">

Specifies the <b>Numeric</b> value to check for the specified bit. 

</param>
<param name="nNumericExpression2">

Specifies the bit position in nExpression1 to check. nExpression2 can range from 0 to 31 with 0 as the bit farthest to the right.

</param>
<param name="BinaryExpression">

Specifies a <b>Varbinary</b> or <b>Blob</b> expression to check for the specified bit.

</param>
<param name="nBitNumber">

Specifies a zero-based bit in qExpression.
If nBitNumber is out of range of qExpression, X# generates an error.
</param>
<returns>
Logical. <b>BITTEST( ) </b>returns True (.T.) if the specified bit is set to 1; otherwise, it returns False (.F.).
</returns>
<example>
 <code language="X#">CLEAR
? '2 even? '
?? IsEven(2)  &amp;&amp; Even, .T. returned
? '3 even? '
?? IsEven(3)  &amp;&amp; Not even, .F. returned
? '0 even? '
?? IsEven(0)  &amp;&amp; Even, .T. returned
? '-13 even? '
?? IsEven(-13)  &amp;&amp; Not even, .F. returned
Function IsEven
PARAMETER nInteger
RETURN NOT BITTEST(nInteger, 0)</code>
</example>
</bittest>
<bitxor>
<summary>
Perform a bitwise exclusive OR operation on two or more values of <b>Numeric</b>, <b>Varbinary</b>, or <b>Blob</b> type and returns the result. There is a numeric and a binary version of the syntax.
</summary>
<returns>

<b>Numeric</b> or <b>Varbinary</b>. <b>BITXOR( )</b> returns the result of the bitwise exclusive OR operation performed on the specified expressions. 
For <b>Varbinary</b> or <b>Blob</b> values, the return value is calculated as if all values are padded with 0h00 on the right of the value up to the length of the longest value. The appropriate operation is then performed between those values.
</returns>
<remarks>

<b>BITXOR( )</b> compares each bit in eExpressionN to the corresponding bit in eExpressionN+1. If the bits in eExpressionN and eExpressionN+1 are the same, the corresponding result bit is set to 0; otherwise, the corresponding result bit is set to 1.
The following table shows the result of an exclusive OR operation on corresponding eExpressionN and eExpressionN+1 bits:
0
0
0
0
1
1
1
0
1
1
1
0
</remarks>
<example>
 <code language="X#">Var1 = 5  &amp;&amp; 0101 binary value
Var2 = 6  &amp;&amp; 0110 binary value
? BITXOR(Var1,Var2) &amp;&amp; returns 3 (0011 binary value)</code>
</example>
</bitxor>
<bof>
<summary>
Determines whether the record pointer is positioned at the beginning of a table.
</summary>
<param name="nWorkArea">

Specifies the work area number for a table open in another work area.

</param>
<param name="cTableAlias">

Specifies the table alias for a table open in another work area.
If the table you want to test for a beginning-of-file condition is open in a work area other than the currently selected work area, use these optional arguments to specify the work area number or table alias for the table. If a table isn't open in the work area you specify, <b>BOF( )</b> returns false (.F.).
</param>
<returns>
Logical
</returns>
<remarks>
Use <b>BOF( )</b> to test for a beginning-of-file condition for a table. <b>BOF( )</b> returns true (.T.) if you have tried to move the record pointer to a position before the first record in the table.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
OPEN DATABASE (HOME() + "samples\data\testdata")
USE customer
GO BOTTOM
local recCtr, btnValue
recCtr = 0
btnValue = 1
DO WHILE btnValue = 1 AND NOT BOF()
? "Company : " + company
recCtr = recCtr + 1
if (recCtr % 20) = 0 then
btnValue =MESSAGEBOX ("Click OK to continue, Cancel to quit.",33)
clear
endif
Skip -1    &amp;&amp; Move up one record
ENDDO
=MESSAGEBOX("Listing complete.",48)</code>
</example>
</bof>
<candidate>
<summary>
Returns true (.T.) if an index tag is a candidate index tag; otherwise, returns false (.F.).
</summary>
<param name="nIndexNumber">
Specifies the number of the index tag for which CANDIDATE( ) returns the candidate status. CANDIDATE( ) returns the candidate status in the following order as nIndexNumber increases from 1 to the total number of structural compound and independent compound index tags:
Candidate status for each tag in the structural compound index (if one is present) is returned first. The candidate status is returned for the tags in the order in which the tags are created in the structural index.
Candidate status for each tag in any open independent compound indexes is returned last. The candidate status is returned for the tags in the order in which the tags are created in the independent compound indexes.
If you omit nIndexNumber, CANDIDATE( ) checks the master controlling index tag to see if it is a candidate index tag. If there is no master controlling index tag, CANDIDATE( ) returns false (.F.). 
</param>
<param name="uArea">
Specifies the work area number or workarea alias of the index tag specified with nIndexNumber. <br/>
If you omit this, CANDIDATE( ) checks the index tag in the currently selected work area to see if it is a candidate index tag.
</param>
<returns>
Logical
</returns>
<remarks>
A candidate index tag is an index tag that can become the primary index tag because it does not contain null or duplicate values.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer     &amp;&amp; Open customer table
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
? TAG(nCount)  &amp;&amp; Display tag name
? CANDIDATE(nCount)  &amp;&amp; Display candidate status
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found
ENDIF
ENDFOR</code>
</example>
</candidate>
<capslock>
<summary>
Returns the current mode of the CAPS LOCK key or sets the CAPS LOCK key mode on or off.
</summary>
<param name="lExpression">

Include to turn the CAPS LOCK key on or off. CAPSLOCK(.T.) turns CAPS LOCK on and CAPSLOCK(.F.) turns CAPS LOCK off. A logical value is returned corresponding to the CAPS LOCK setting before CAPSLOCK(.T.) or CAPSLOCK(.F.) is issued.
</param>
<returns>
Logical
</returns>
<remarks>
Issuing CAPSLOCK( ) with no argument returns true (.T.) if CAPS LOCK is on, or false (.F.) if CAPS LOCK is off.
</remarks>
<example>
 <code language="X#">glOldLock = CAPSLOCK( )     &amp;&amp; Save original setting
CAPSLOCK(.T.)     &amp;&amp; Turn CAPS LOCK on
*** Perform any number of statements ***
CAPSLOCK(glOldLock)  &amp;&amp; Return to original setting
*** or, toggle CapsLock to the opposite value and back ***
CAPSLOCK(!CAPSLOCK( ))
WAIT WINDOW
CAPSLOCK(!CAPSLOCK( ))
WAIT WINDOW
CAPSLOCK(glOldLock)  &amp;&amp; Return to original setting</code>
</example>
</capslock>
<cast>
<summary>
Converts an expression from one data type to another.
</summary>
<param name="eExpression">

Specifies a data expression, usually in a SQL statement, that you want to convert to another data type. eExpression can be a field, calculated field, or other type of expression.

</param>
<param name="cDataType">

Specifies the valid name of or letter representing the target data type name. cDataType can also be an expression that evaluates to a valid data type name or letter representing a valid data type. 
If you specify an expression for cDataType, you must enclose the expression you specify for cDataType with parentheses.
Some field data types require that you specify a value for nFieldWidth, nPrecision, or both. The following table lists values for cDataType and whether nFieldWidth and nPrecision apply.
W, Blob
No
C, Char, Character
Yes
Y, Currency
D, Date
T, DateTime
B, Double
F, Float
Floating
G, General
I, Int, Integer
L, Logical
M, Memo
N, Num, Numeric
Q, Varbinary
V, Varchar

</param>
<param name="nFieldWidth">

Specifies the field width for certain data types. X# disregards nFieldWidth for the following data types: D, T, I, Y, L, M, G, and W. If nFieldWidth is not specified, default values are used, for example, as defined by the <b>CREATE TABLE</b> command. 

</param>
<param name="nPrecision">

Specifies the number of decimal place precision for certain data types. X# disregards nPrecision for the following data types: C, D, T, I, Y, L, M, G, V, Q, and W. 
If nPrecision is not included for the <b>Numeric</b> or <b>Float</b> data type, the default is zero (0), which is no decimal places. If nPrecision is not included for the Double data type, nPrecision defaults to the number of decimal place precision set by the <b>SET DECIMALS</b> command. If nPrecision is not specified for any other data type, default values are used, for example, as defined by the <b>CREATE TABLE</b> command.  
NULL | NOT NULL 
Specifies whether to permit null values in the field. 
If one or more fields can contain null values, the maximum number of fields the table can contain is reduced from 255 to 254.
If <b>NULL</b> or <b>NOT NULL</b> is not specified, it is inherited from the expression.
</param>
<remarks>
The following table shows conversions supported by the <b>CAST( )</b> function. The vertical axis lists the source data type, and the horizontal axis lists the target data type. The following letters describe the level of conversion supported:
F - Full conversion without loss of data
P - Partial conversion with possible loss of data
N - Not supported

<b>C</b>

F
P
P
P
P
P
P
P
P
F
N
F
F
F

<b>D</b>

F
F
F
N
N
N
N
N
N
F
N
F
N
N

<b>T</b>

F
P
F
N
N
N
N
N
N
F
N
F
N
N

<b>N</b>

F
N
N
F
F
P
F
P
P
F
N
F
N
N

<b>F</b>

F
N
N
F
F
P
F
P
P
F
N
F
N
N

<b>I</b>

F
N
N
F
F
F
F
F
P
F
N
F
N
N

<b>B</b>

P
N
N
P
P
P
F
P
P
F
N
P
N
N

<b>Y</b>

F
N
N
P
P
P
F
F
P
F
N
F
N
N

<b>L</b>

F
N
N
F
F
F
F
F
F
F
N
F
N
N

<b>M</b>

P
P
P
P
P
P
P
P
P
F
N
P
P
F

<b>G</b>

N
N
N
N
N
N
N
N
N
N
F
N
N
F

<b>V</b>

P
P
P
P
P
P
P
P
P
F
N
F
P
P

<b>Q</b>

P
N
N
N
N
N
N
N
N
F
N
P
F
F

<b>W</b>

P
N
N
N
N
N
N
N
N
F
F
P
P
F
If you specify decimal precision, conversions between numeric data types, for example, <b>Numeric</b>, <b>Float</b>, <b>Currency</b>, and <b>Double</b>, to <b>Integer</b> data type might result in loss of precision.
For conversions to <b>Character</b>, <b>Varchar</b>, and <b>Varbinary</b> data types, if the specified field width is less than that of the original data, X# truncates values to fit the field width. For conversions to <b>Character</b> data type, if the specified width is greater than that of the original data, X# pads the field with spaces to the right of the value.
</remarks>
<example>
 <code language="X#">CLEAR ALL
OPEN DATABASE HOME(2) + 'Data\Testdata.dbc'
SELECT Product_ID, CAST(unit_Cost * in_Stock AS Numeric(8,2)) FROM Products</code>
</example>
</cast>
<cdow>
<summary>
Returns the day of the week from a given Date or DateTime expression.
</summary>
<param name="dExpression">

Specifies the date from which CDOW( ) returns the day.

</param>
<param name="tExpression">

Specifies the datetime from which CDOW( ) returns the day.
</param>
<returns>
Character
</returns>
<remarks>
CDOW( ) returns the name of the day of the week as a string in proper noun format.
</remarks>
<example>
 <code language="X#">STORE {^1998-02-16} TO gdDate
CLEAR
? CDOW(gdDate)  &amp;&amp; Displays Monday</code>
</example>
</cdow>
<cdx>
<summary>
Returns the names of the open compound index (.cdx) file that has the specified index position number.
</summary>
<param name="nIndexNumber">

The following apply to a table with a structural compound index and one or more compound indexes:
nIndexNumber 
1
Returns the name of the structural index file (which is always the same as the name of the table).
2
Returns the first compound index file name specified in the INDEX clause of USE or in SET INDEX.
3
Returns the second compound index file name, if any, and so on.
Greater than the number of open .cdx files
Returns the empty string.
The following apply to a table with no structural compound index and one or more compound indexes:   

</param>
<param name="uArea">
  Specifies the work area number or alias of a table whose open compound index file names you want CDX( ) to return.<br/>
  If you omit this, names of compound index files are returned for the table in the currently selected work area.
</param>
<returns>
Character
</returns>
<remarks>
The CDX( ) function is identical to the MDX( ) function.
A .cdx (compound) index consists of one physical file containing many index tags. Each index tag is an index order reference for the associated table.
There are two types of .cdx files: standard compound index (.cdx) and structural .cdx. A standard compound index (.cdx) may have a different name from its associated table and can reside in a different directory from its associated table. A table can have multiple compound index files. You open a compound index with the INDEX clause of USE or with SET INDEX.
A structural .cdx must have the same name as its associated table and reside in the same directory. A table can have only one structural index file. Structural .cdx files are automatically opened and updated when the associated table is opened with USE.
CDX( ) ignores any .idx (Microsoft FoxBASE+ and FoxPro 1.0 compatible index) files specified in USE or SET INDEX.
Use TAG( ) to return individual tag names contained in a .cdx, and NDX( ) to return the name of open .idx files.
When SET FULLPATH is ON, CDX( ) returns the path and name of the .cdx. When SET FULLPATH is OFF, CDX( ) returns the drive and name of the .cdx.
</remarks>
<example>

<code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer     &amp;&amp; Open customer table
CLEAR
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
? CDX(nCount)     &amp;&amp; Display structural index names
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found
ENDIF
ENDFOR</code>
</example>
</cdx>
<ceiling>
<summary>
Returns the next highest integer that is greater than or equal to the specified numeric expression.
</summary>
<param name="nExpression">

Specifies the number whose next highest integer <b>CEILING( )</b> returns.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>CEILING</b> rounds a number with a fractional portion to the next highest integer.
</remarks>
<example>
 <code language="X#">STORE 10.1 TO num1
STORE -10.9 TO num2
? CEILING(num1)  &amp;&amp; Displays 11
? CEILING(num2)  &amp;&amp; Displays -10
? CEILING(10.0)  &amp;&amp; Displays 10
? CEILING(-10.0) &amp;&amp; Displays -10</code>
</example>
</ceiling>
<chr>
<summary>
Returns the character associated with the specified numeric ANSI code.
</summary>
<param name="nANSICode">

Specifies a number between 0 and 255 whose equivalent ANSI character <b>CHR( )</b> returns.
Use <b>ASC( )</b> to return the ANSI value for a specified character.
</param>
<returns>
Character
</returns>
<remarks>

<b>CHR( )</b> returns a single character corresponding to the numeric position of the character in the character table of the current code page. <b>CHR( )</b> can be used to send printer control codes to a printer.
</remarks>
<example>
 <code language="X#">CLEAR
FOR nCOUNT = 65 TO 75
? nCount &amp;&amp; Display numeric value
?? ' ' + CHR(nCount) &amp;&amp; Display character
ENDFOR</code>
</example>
</chr>
<chrsaw>
<summary>
Determines whether or not a character is present in the keyboard buffer.
</summary>
<param name="nSeconds">

Specifies the time in seconds that <b>CHRSAW( )</b> waits before checking the keyboard buffer. The keyboard buffer is checked immediately if you omit nSeconds.
Including nSeconds lets you use <b>CHRSAW( )</b> for a variety of timed activities. For example, your program can close an application if a key hasn't been pressed for a specific number of seconds.
</param>
<returns>
Logical
</returns>
<remarks>

<b>CHRSAW( )</b> returns True (.T.) if a character is present in the keyboard buffer, and False (.F.) if not. <b>CHRSAW( )</b> doesn't affect the keyboard buffer contents.
</remarks>
<example>
 <code language="X#">SET TALK OFF
DEFINE WINDOW wEnter FROM 7,10 to 13,70 PANEL
ACTIVATE WINDOW wEnter
@ 1,3 SAY 'Customer: '   GET gcCustomer  DEFAULT SPACE(40)
@ 3,3 SAY 'Address:  '   GET gcAddress  DEFAULT SPACE(40)
WAIT WINDOW 'Waiting for input' NOWAIT
IF NOT CHRSAW(5)
DEACTIVATE WINDOW wEnter
CLEAR GETS
ELSE
READ
DEACTIVATE WINDOW wEnter
ENDIF
RELEASE WINDOW wEnter
WAIT
CLEAR</code>
</example>
</chrsaw>
<chrtran>
<summary>
Replaces each character in a character expression that matches a character in a second character expression with the corresponding character in a third character expression.
</summary>
<param name="cSearchedExpression">

Specifies the expression in which <b>CHRTRAN( )</b> replaces characters.

</param>
<param name="cSearchExpression">

Specifies the expression containing the characters <b>CHRTRAN( )</b> looks for in cSearchedExpression.

</param>
<param name="cReplacementExpression">

Specifies the expression containing the replacement characters.
If a character in cSearchExpression is found in cSearchedExpression, the character in cSearchedExpression is replaced by a character from cReplacementExpression that's in the same position in cReplacementExpression as the respective character in cSearchExpression.   
If cReplacementExpression has fewer characters than cSearchExpression, the additional characters in cSearchExpression are deleted from cSearchedExpression. If cReplacementExpression has more characters than cSearchExpression, the additional characters in cReplacementExpression are ignored.
</param>
<returns>
Character
</returns>
<remarks>

<b>CHRTRAN( )</b> translates the character expression cSearchedExpression using the translation expressions cSearchExpression and cReplacementExpression and returns the resulting character string.
</remarks>
<example>
 <code language="X#">? CHRTRAN('ABCDEF', 'ACE', 'XYZ')  &amp;&amp; Displays XBYDZF
? CHRTRAN('ABCD', 'ABC', 'YZ')  &amp;&amp; Displays YZD
? CHRTRAN('ABCDEF', 'ACE', 'XYZQRST')  &amp;&amp; Displays XBYDZF</code>
</example>
</chrtran>
<chrtranc>
<summary>
Replaces each character in a character expression that matches a character in a second character expression with the corresponding character in a third character expression.
</summary>
<param name="cSearched">

Specifies the expression in which <b>CHRTRANC( )</b> replaces characters.

</param>
<param name="cSearchFor">

Specifies the expression containing the characters <b>CHRTRANC( )</b> looks for in cSearched.

</param>
<param name="cReplacement">

Specifies the expression containing the replacement characters.
If a character in cSearchFor is found in cSearched, the character in cSearched is replaced by a character from cReplacement that's in the same position in cReplacement as the respective character in cSearchFor.   
If cReplacement has fewer characters than cSearchFor, the additional characters in cSearchFor are deleted from cSearched. If cReplacement has more characters than cSearchFor, the additional characters in cReplacement 
</param>
<returns>
Character
</returns>
<remarks>

<b>CHRTRANC( )</b> is designed to facilitate working with expressions that contain double-byte characters. Use <b>CHRTRANC( )</b> to replace single-byte characters with double-byte characters or double-byte characters with single-byte characters. If the expressions contains only single-byte characters, <b>CHRTRANC( )</b> is equivalent to <b>CHRTRAN( )</b> .
This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
</remarks>
</chrtranc>
<clearresultset>
<summary>
Clears the marker from a cursor marked by <b>SETRESULTSET( )</b> in the current data session.
</summary>
<returns>
CLEARRESULTSET( )Return Value
Numeric. <b>CLEARRESULTSET( ) </b>returns the number of the work area for the previously marked cursor or zero (0) if no cursor is marked in the current data session.
</returns>
<remarks>

<b>CLEARRESULTSET( ) </b>is supported in X# and the X# OLE DB Provider. You can use <b>GETRESULTSET( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider. 
</remarks>
</clearresultset>
<cmonth>
<summary>
Returns the name of the month from a given date or DateTime expression.
</summary>
<param name="dExpression">

Specifies the date expression from which <b>CMONTH( )</b> returns the name of the month.

</param>
<param name="tExpression">

Specifies the DateTime expression from which <b>CMONTH( )</b> returns the name of the month.
</param>
<returns>
Character
</returns>
<remarks>

<b>CMONTH( )</b> returns the name of the month as a string in proper noun format based on the current resource file you are using and not on the Windows locale. For more information, see Managing Files in an International Application.
</remarks>
<example>
 <code language="X#">? <b>CMONTH(</b>DATE( )<b>)</b>
STORE {^1998-02-16} TO gdDueDate
? 'Your payment was due in ', <b>CMONTH(</b>gdDueDate<b>)</b>
STORE gdDueDate+60 TO gdFinalDate
? 'You must pay by ', <b>CMONTH(</b>gdFinalDate<b>)</b></code>
</example>
</cmonth>
<cntbar>
<summary>
Returns the number of menu items on a user-defined menu or the X# system menu.
</summary>
<param name="cMenuName">

Specifies the name of the menu for which <b>CNTBAR( )</b> returns the number of menu items. For a list of the X# system menu names, see the System Menu Names topic.
</param>
<returns>
Numeric
</returns>
<remarks>
If a user-defined menu is created with the PROMPT option in <b>DEFINE POPUP</b>, X# evaluates the number of menu items when you issue <b>ACTIVATE POPUP</b>. For such a menu, <b>CNTBAR( )</b> returns a meaningful value only after you activate the menu. However, if the menu items in the menu are created with <b>DEFINE BAR</b>, <b>CNTBAR( )</b> can determine the number of menu items before you issue <b>ACTIVATE POPUP</b>.
</remarks>
<example>
 <code language="X#">*** You must name this program CNTBAR.PRG ***
CLEAR
SET TALK OFF
DEFINE PAD padEnv OF _MSYSMENU PROMPT 'E\&lt;nvironment';
KEY ALT+R, 'ALT+R'
ON PAD padEnv OF _MSYSMENU ACTIVATE POPUP popEnv
DEFINE POPUP popEnv MARGIN RELATIVE COLOR SCHEME 4
DEFINE BAR 1 OF popEnv PROMPT '\&lt;Status Bar'
DEFINE BAR 2 OF popEnv PROMPT '\&lt;Clock'
DEFINE BAR 3 OF popEnv PROMPT '\&lt;Extended Video'
DEFINE BAR 4 OF popEnv PROMPT 'St\&lt;icky'
ON SELECTION POPUP popEnv DO enviropop IN cntbar.prg
FOR i = 1 TO CNTBAR('popEnv')
DO CASE
CASE PRMBAR('popEnv', i) = 'Status Bar'
IF _WINDOWS or _MAC
SET MARK OF BAR i OF popEnv TO SET('STATUS BAR') = 'ON'
ELSE
SET MARK OF BAR i OF popEnv TO SET('STATUS') = 'ON'
ENDIF
CASE PRMBAR('popEnv', i) = 'Clock'
SET MARK OF BAR i OF popEnv TO  SET('CLOCK') = 'ON'
CASE PRMBAR('popEnv', i) = 'Extended Video'
SET MARK OF BAR i OF popEnv TO  SROW( ) &gt; 25
CASE PRMBAR('popEnv', i) = 'Sticky'
SET MARK OF BAR i OF popEnv TO  SET('STICKY') = 'ON'
ENDCASE
ENDFOR
PROCEDURE enviropop
DO CASE
CASE PROMPT() = 'Status'
IF mrkbar('popEnv', BAR( ))
DO CASE
CASE _WINDOWS OR _MAC
SET STATUS BAR OFF
CASE _DOS
SET STATUS OFF
OTHERWISE
ENDCASE
SET MARK OF BAR BAR( ) OF popEnv TO .F.
ELSE
DO CASE
CASE _WINDOWS OR _MAC
SET STATUS BAR ON
CASE _DOS
SET STATUS ON
OTHERWISE
ENDCASE
SET MARK OF BAR BAR( ) OF popEnv TO .T.
ENDIF
CASE PROMPT( ) = 'Clock'
IF mrkbar('popEnv', BAR( ))
SET CLOCK OFF
SET MARK OF BAR BAR( ) OF popEnv TO .F.
ELSE
DO CASE
CASE _WINDOWS OR _MAC
SET STATUS BAR ON
SET CLOCK STATUS
CASE _DOS
SET CLOCK ON
OTHERWISE
ENDCASE
SET MARK OF BAR BAR( ) OF popEnv TO .T.
ENDIF
CASE PROMPT( ) = 'Extended Video'
IF MRKBAR('popEnv', BAR( ))
SET DISPLAY TO VGA25
SET MARK OF BAR BAR( ) OF popEnv TO .F.
ELSE
SET DISPLAY TO VGA50
SET MARK OF BAR BAR( ) OF popEnv TO .T.
ENDIF
CASE PROMPT( ) = 'Sticky'
IF MRKBAR('popEnv', BAR( ))
DO CASE
CASE _WINDOWS OR _MAC
WAIT WINDOW 'STICKY is always on in this X# version'
CASE _DOS
SET STICKY OFF
OTHERWISE
ENDCASE
SET MARK OF BAR BAR( ) OF popEnv TO .F.
ELSE
DO CASE
CASE _WINDOWS OR _MAC
WAIT WINDOW 'STICKY is always ON in X#'
CASE _DOS
SET STICKY ON
OTHERWISE
ENDCASE
SET MARK OF BAR BAR( ) OF popEnv TO .T.
ENDIF
ENDCASE</code>
</example>
</cntbar>
<cntpad>
<summary>
Returns the number of menu titles on a user-defined menu bar or the X# system menu bar.
</summary>
<param name="cMenuBarName">

Specifies the name of the menu bar for which <b>CNTPAD( )</b> returns the number of menu titles.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">? CNTPAD('_MSYSMENU')</code>
</example>
</cntpad>
<col>
<summary>
Included for backward compatibility. Use the CurrentX, CurrentY Properties.
 
Returns the current column position of the cursor.
</summary>
<returns>
Return value - Numeric
</returns>
<remarks>
<br />
COL() is especially useful for directing screen output to a column position relative to the current column position of the cursor.<br />
<br />
The special operator $ can be used in place of COL().<br />
<br />

</remarks>
<example>




 






<code language="X#">@ 5,5 SAY ''
@ ROW(), COL()+12 SAY 'Contact person'
@ ROW(), $+12 SAY 'Contact person'
</code>					




</example>
</col>
<comarray>
<summary>
Specifies how to pass arrays to COM objects.
</summary>
<param name="oObject">

Specifies an object reference to a COM object.

</param>
<param name="nNewValue">

Specifies how to pass an array to a COM object specified with oObject. 
The following table lists the settings for nNewValue and how the to pass the array to the COM object.   
0
The array is a zero-based array and is passed by value.
1 
The array is a one-based array and is passed by value. Compatible with earlier versions of X#. (Default)
10
The array is a zero-based array and is passed by reference.
11
The array is a one-based array and is passed by reference.
100
The array is a fixed size array and cannot be redimensioned.
1000
Byte arrays are not converted to strings.
To return the current setting, call <b>COMARRAY( )</b> without an argument for the nNewValue parameter.
</param>
<returns>
Numeric. <b>COMARRAY( )</b> returns the current setting.
</returns>
<remarks>
Use <b>COMARRAY( )</b> only when you pass arrays to COM objects using the following syntax:

codeoComObject.Method(@MyArray)/code

If you omit the at sign (@), only the first element of the array passes to the COM object, and <b>COMARRAY( )</b> has no effect. This behavior is the same as that in earlier versions of X#.
When you use a byte array (VT_UI1) to communicate with a COM server, X# converts the byte array into a string. The additive nValue of 1000 retains the original proper type of the array and does not convert the result to a string.
If a client passes a byte array by reference to a X# COM Server, the X# COM Server must also set the nValue additive to 1000. You can do this by putting the following call in the Init event of the X# COM Server:
 <code language="X#">COMARRAY(THIS,1000)</code>
The additive nValue of 100 makes it possible for you to prevent redimensioning of an array. You should check for possible errors after calling the server in case the server attempts to redimension the array. The following example shows how to prevent redimensioning of the array. To run this example, first build the class definition into a DLL named "t1.dll".
 <code language="X#">LOCAL loSvr, laTest
loSvr = NEWOBJECT("t1.arrayhandler")
DIMENSION laTest[10]
laTest=3
? COMARRAY(loSvr,11 + 100)
* The COM server will return an error on the next line of code
* because arrays passed to loSvr will not allow re-dimensioning.
loSvr.RedimensionArray(@laTest,4)
? ALEN(laTest)
DEFINE CLASS ARRAYHANDLER AS CUSTOM OLEPUBLIC
PROCEDURE RedimensionArray(aArray, nRows)
DIME aArray[nRows]
ENDPROC
ENDDEFINE</code>
</remarks>
</comarray>
<comclassinfo>
<summary>
Returns registry information about a COM object such as a X# automation server.
</summary>
<param name="oObject">

An object reference to a COM or OLE object.

</param>
<param name="nInfoType">

Specifies the type of information to return. The following table lists the values for nInfoType and the information returned.
1 (Default)
The object's programmatic identifier (ProgID).A ProgID is a registry entry that can be associated with a CLSID.
2
The object's VersionIndependentProgID.The VersionIndependentProgID associates a ProgID with a CLSID. It is used to determine the latest version of an object application, refers to the application's class, and does not change from version to version.
3
The object's friendly name.
4
The object's class identifier (CLSID). A CLSID is a globally unique identifier that identifies a COM class object.
5
Type of object passed:    <b>Return value      Description</b>          1               X# object          2               ActiveX Control          3               COM Component          4               OLEBound object (General field)
</param>
<returns>
Character
</returns>
<remarks>
COMCLASSINFO( ) returns the empty string if registry information isn't available for the object you specify. X# automation servers are COM objects, both .exe executable files and .dll dynamic link libraries you can create in the Project Manager.
If you create an instance of an ActiveX control by using CREATEOBJECT( ) as in the following code, nInfoType returns 3 (COM Component) rather than 2.
 <code language="X#">X=CREATEOBJECT("MSComctlLib.treectrl.2")</code>
To return 2 (ActiveX control) you must use the object as such, as in the following code:
 <code language="X#">ox.addobject("oc","olecontrol","MSComctlLib.treectrl.2")</code>
</remarks>
</comclassinfo>
<compobj>
<summary>
Compares the properties of two objects and returns True (.T.) if their properties and property values are identical.
</summary>
<returns>
Logical
</returns>
<remarks>
COMPOBJ( ) returns False (.F.) if an object has a property that the other object doesn't have, or if the objects have identical properties but the values of one or more properties differ.
</remarks>
<example>
 <code language="X#">lstMyList1 = CREATEOBJ('ListBox')  &amp;&amp; Creates a ListBox
lstMyList2 = CREATEOBJ('ListBox')  &amp;&amp; Creates a second ListBox
cmbMyCombo = CREATEOBJ('ComboBox')  &amp;&amp; Creates a ComboBox
lstMyList1.Name = 'list1'
lstMyList2.Name = 'list2'
CLEAR
? lstMyList1.Name  &amp;&amp; Displays List1 Name property
? lstMyList2.Name  &amp;&amp; Displays List2 Name property
? COMPOBJ(lstMyList1, cmbMyCombo)     &amp;&amp; Displays .F.
? COMPOBJ(lstMyList1, lstMyList2)     &amp;&amp; Displays .F., different Names
lstMyList2.Name = lstMyList1.Name
? COMPOBJ(lstMyList1, lstMyList2)     &amp;&amp; Displays .T., same properties</code>
</example>
</compobj>
<comprop>
<summary>
Sets or returns the behavior setting of a COM object property.
</summary>
<param name="oComObject">

Specifies a reference to a COM object. cProperty is not case sensitive.
You must use the complete name of the COM object. If you do not provide eValue, COMPROP( ) returns the value of cProperty. 

</param>
<param name="cProperty">

Specifies the name of the COM property to set. The following table lists possible values of cProperty.
UTF8
Determines whether UNICODE strings returned from a COM object are converted to ANSI. Conversion is performed by default.
PUTREF
Determines if initial object assignment is PROPERTY_PUT (default) or PUTREF.

</param>
<param name="eValue">

Specifies a value representing behavior to apply to the cProperty. The following table lists values for eValue.
0
Apply default behavior.
1
Apply nondefault behavior as described in the table for cProperty. 
For example, setting an eValue of 1 for UTF8 prevents the display of multi-byte characters as question marks. Setting an eValue of 1 for PUTREF causes X# to attempt object assignment as a PUTREF first and, only if that fails, attempt assignment as a PROPERTY_PUT. Object assignments to properties of some ActiveX controls or COM objects requires PUTREF, and X# defaults to PROPERTY_PUT.
</param>
<returns>
COMPROP( ) returns the value of cProperty.
The following example returns data from methods of an ADO recordset as UNICODE instead of allowing conversion to ANSI:
 <code language="X#">LOCAL oConn AS adodb.Connection, oRS AS adodb.Recordset
LOCAL lcStr AS STRING
oConn=CREATEOBJECT("ADODB.Connection")
oConn.Open("DSN=Nwind;")  &amp;&amp; DSN to SQL Server
oRS=oConn.Execute("select * from customers")
COMPROP(oRS,'UTF8',1)
DO WHILE NOT oRS.Eof
lcStr = oRS.Fields(4).Value
oRS.MoveNext
ENDDO
oRS.Close()
oRS.ActiveConnection=NULL
oRS=NULL
oConn.Close()
oConn=NULL</code>
In the following example, an ActiveX control is made to use PUTREF rather than PROPERTY_PUT:
 <code language="X#">=COMPROP(oForm.OLECONTROL1, 'PUTREF',1)</code>
</returns>
</comprop>
<comreturnerror>
<summary>
Populates the COM exception structure with information that Automation clients can use to determine the source of Automation errors.
</summary>
<param name="cExceptionSource">

Specifies the text for the source of the exception.

</param>
<param name="cExceptionText">

Specifies the text for the description of the exception.
</param>
<remarks>
COMRETURNERROR( ) allows X# Automation servers to populate the COM exception structure so that Automation clients can determine the cause of an error on the Automation server.
Executing COMRETURNERROR( ) places the specified text in the COM exception structure, aborts executing the current method, and returns control to the client. The Automation server remains in memory and the client can call more Automation server methods.
X# clients can use AERROR( ) to view the text placed on the COM exception structure.
(For advanced users) COMReturnErrorInfo fills in a COM exception information structure. This is used only for IDispatch (late binding calls). If you call the server via early binding and the client passes a COM exception structure to the server, there is no error mechanism to return the error info unless the client does a QueryInterface on the ISupportsErrorInfo interface.
</remarks>
</comreturnerror>
<cos>
<summary>
Returns the cosine of a numeric expression.
</summary>
<param name="nExpression">

Specifies a numeric expression whose cosine COS( ) returns. nExpression can be any value.
</param>
<returns>
Numeric
</returns>
<remarks>
COS( ) returns the cosine of nExpression in radians. Use DTOR( ) to convert an angle from degrees to radians. The number of decimal places that COS( ) returns can be specified with SET DECIMALS. The value COS( ) returns ranges between –1 and 1.
</remarks>
<example>
 <code language="X#">CLEAR
? COS(0)  &amp;&amp; Displays 1.00
? COS(PI( ))  &amp;&amp; Displays -1.00
? COS(DTOR(180))  &amp;&amp; Displays -1.00
STORE PI( ) * 3 TO gnAngle
? COS(gnAngle)  &amp;&amp; Displays -1.00</code>
</example>
</cos>
<cpconvert>
<summary>
Converts character or memo fields or character expressions to another code page.
</summary>
<param name="nCurrentCodePage">

Specifies the code page that cExpression is being converted from.

</param>
<param name="nNewCodePage">

Specifies the code page to which cExpression is converted.

</param>
<param name="cExpression">

Specifies the character expression that's converted.
</param>
<remarks>
Note that CPCONVERT( ) isn't required for normal cross-platform functioning of the product. It is used strictly to access the underlying translation facilities of X#.
For example, if the variable codegcCharExpr/code contains a character that looks like  on the Macintosh (in code page 10000) then CPCONVERT( ) will return a character that looks like  in Microsoft Windows (code page 1252):
 <code language="X#">CPCONVERT(10000, 1252, gcCharExpr)</code>
For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
</remarks>
</cpconvert>
<cpcurrent>
<summary>
Returns the code page setting (if any) in your X# configuration file, or returns the current operating system code page.
</summary>
<remarks>
CPCURRENT([1 | 2])Remarks
CPCURRENT( ) returns one of the following:

In X#, the current operating system code page if the CODEPAGE configuration item isn't included in your configuration file. In previous versions of FoxPro, 0 is returned if the CODEPAGE configuration item isn't included in your configuration file.
The code page number specified in the CODEPAGE configuration item. For example, CPCURRENT( ) returns 852 if the following line is included in your configuration file:

 <code language="X#">CODEPAGE = 852</code>
The current operating system code page if you have included the following line in your configuration file:

 <code language="X#">CODEPAGE = AUTO</code>
In X#, CPCURRENT(1) returns the current operating system code page, regardless of your configuration CODEPAGE setting.
CPCURRENT(2) always returns the underlying operating system code page, regardless of your configuration CODEPAGE setting. For example, if you're running Windows, CPCURRENT(2) returns the MS-DOS code page.
For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
</remarks>
</cpcurrent>
<cpdbf>
<summary>
Returns the code page with which an open table has been marked.
</summary>
<param name="uArea">Specifies the work area number or alias .
Include this to specify a table open in a work area other than the current work area. CPDBF( ) returns 0 if a table isn't open in the work area you specify. If a table doesn't have the alias you specify with cTableAlias, X# generates an error message.
</param>
<remarks>
DISPLAY STRUCTURE also displays the code page with which an open table has been marked.
For additional information on code pages and X#'s international support, see Code Pages Supported by X# and Developing International Applications.
</remarks>
</cpdbf>
<createbinary>
<summary>
Converts character type data created in X# to a binary type character string you can pass to an ActiveX control or automation object.
</summary>
<param name="cExpression">

Specifies the character expression for which a binary type character string is returned.
</param>
<returns>
Character
</returns>
<remarks>
X# character strings can contain binary data. However, an ActiveX control or automation object character string (OLE VT_BSTR type data) cannot contain binary data. An ActiveX control or automation object passes binary data to applications such as X# as an array of VT_UI1 type data.
X# automatically converts binary data passed from an ActiveX control or automation object as an array of VT_UI1 type data to a X# character string. X# internally marks this character string as binary data passed from an ActiveX control or automation object. When the character string is passed back to an ActiveX control or automation object, X# automatically converts the character string to an array of VT_UI1 type data the ActiveX control or automation object expects.
Use CREATEBINARY( ) to convert character type data created in X# to a binary type character string you can pass to an ActiveX control or automation object. The minimum number of characters to which CREATEBINARY( ) can be abbreviated is 7.
For more information about ActiveX controls and automation objects, see Sharing Information and Adding OLE.
</remarks>
</createbinary>
<createobject>
<summary>
Creates an object from a class definition or an Automation-enabled application.
</summary>
<param name="ClassName">

Specifies the class or OLE object from which the new object is created. X# searches for the class or OLE object in the following order:
X# base classes
Classes in the current program
Classes in .vcx class libraries opened with SET CLASSLIB
Classes in procedure files opened with SET PROCEDURE
Classes in the X# program execution chain
The OLE registry if SET OLEOBJECT is ON
OLE objects are created using the following syntax for ClassName:   
 <code language="X#">ApplicationName.Class</code>
For example, to create a Microsoft Excel worksheet (which supports Automation), you can use the following syntax:   
 <code language="X#">x = CREATEOBJECT('Excel.Sheet')</code>
When this code is run, Microsoft Excel is started (if not already running), and a new worksheet is created.   
A class library can have an alias. To specify an object in a class library with an alias, include the class library alias followed by a period and the object name.   
Note that ClassName cannot be the X# OLE Container control base class. 

eParameter1, eParameter2, ...
These optional parameters are used to pass values to the Init event procedure for the class. The Init event is executed when you issue CREATEOBJECT( ) and allows you to initialize the object.
</param>
<returns>
Object
</returns>
<remarks>
Use CREATEOBJECT( ) to create an object from a class definition or an application that supports Automation, and assign a reference to the object to a system variable or array element.
Before you can create an object from a user-defined class, the user-defined class must first be created with DEFINE CLASS, or it must be available in a .vcx visual class library opened with SET CLASSLIB.
Use = or STORE to assign a reference to the object to a system variable or array element. If an object assigned to a system variable or array element is released, the system variable or array element contains the null value. Use RELEASE to remove the system variable or array element from memory.
</remarks>
<example>
 <code language="X#">CLEAR
* Verify current class library setting
cCurClassLib=SET("CLASSLIB")
IF LEN(ALLTRIM(cCurClassLib))=0
cCurClassLib="None"
ENDIF
WAIT WINDOW "Current class library is: " + cCurClassLib + CHR(13);
+ "Press any key to continue..."
frmMyForm = CREATEOBJECT("FormGrandChild")
* Create an array
FOR nCount = 1 TO ACLASS(gaNewarray, frmMyForm)
? gaNewarray(nCount)  &amp;&amp; Display the names of the classes
ENDFOR
RELEASE frmMyForm
* Create FormChild from FORM baseclass
DEFINE CLASS FormChild AS FORM
ENDDEFINE
* Create FormGrandChild from user-defined FormChild class
DEFINE CLASS FormGrandChild AS FormChild
ENDDEFINE</code>
</example>
</createobject>
<createobjectex>
<summary>
Creates an instance of a registered COM object (such as a X# Automation server) on a remote computer.
</summary>
<param name="cComputerName">

Specifies the remote computer on which the COM object is instantiated.
If cComputerName is the empty string, the COM object is instantiated on the local computer or a redirected machine as specified in the registry.    
cComputerName supports Universal Naming Convention (UNC) names such as "\\myserver" and "myserver," and Domain System Names (DNS) names. 

</param>
<param name="cIID">

Specifies the Interface ID GUID of cCLSID | cPROGID when you create an early bound instance of the class. If you pass an empty string as cIID X# attempts to access the default interface (IID) of cCLSID | cPROGID.
</param>
<returns>
Object
</returns>
<remarks>
CREATEOBJECTEX( ) returns an object reference to the COM object if it is successfully instantiated. CREATEOBJECTEX( ) cannot be used to instantiate X# classes such as forms – use CREATEOBJECT( ) to instantiate X# classes. Note that you can only abbreviate CREATEOBJECTEX( ) to a minimum of 13 characters, distinguishing it from the CREATEOBJECT( ) function.
When you call certain COM classes with CREATEOBJECT( ) they return "No such interface supported" because they do not support an IDispatch interface. Using the cIID parameter you can now access these classes in your applications.
If you pass an empty string ("") as cIID X# attempts to to get the default interface (IID) of the specified CLSID or PROGID.
Because it supports early binding through cIID, CREATEOBJECTEX( ) can help improve performance by avoiding much of the overhead of IDispatch calls.
CREATEOBJECTEX( ) supports creation of new early-bound objects. However, it is also possible that your X# component is passed an object that you want to call via early-binding. You can use the GETINTERFACE( ) support on existing COM objects.
For additional information about using X# to create Automation servers, see Sharing Information and Adding OLE.
</remarks>
<example>
 <code language="X#">      x = CREATEOBJECTEX("excel.application","",;
"{000208D5-0000-0000-C000-000000000046}")</code>
The following is a valid function call for an excel application object. It will return the excel.application default interface.
 <code language="X#">      x = CREATEOBJECTEX("excel.application","","")</code>
</example>
</createobjectex>
<createoffline>
<summary>
Takes an existing view offline.
</summary>
<param name="ViewName">

Specifies the name of the existing view to take offline. The database containing the existing view must be open before you can take the existing view offline.

</param>
<param name="cPath">

Specifies the directory in which the offline view is placed and the name of the offline view.
</param>
<returns>
Logical
</returns>
<remarks>
CREATEOFFLINE( ) returns a logical true (.T.) if the existing view is successfully taken offline; otherwise false (.F.) is returned.
An offline view is opened with USE. When an offline view is open, you can append records or make changes to records in the offline view. However, you cannot use the CREATE TRIGGER, INSERT, PACK or ZAP commands in an offline view. After making changes to the offline view, you can update the data on the server with your changes by opening the offline view with USE and including the ONLINE clause.
You cannot refresh the contents of an offline view with data from the server until the offline view has been opened with USE and the ONLINE clause.
Use DROPOFFLINE( ) to take the offline view back online.
</remarks>
</createoffline>
<ctobin>
<summary>
Converts a binary character representation to a numeric value.
</summary>
<param name="cExpression">

Specifies the binary character representation to convert.

</param>
<param name="cFlags">

If the binary character representation specified with cExpression was generated using an 8 byte data type (currency or double, for example), include cFlags to control the type of value returned by CTOBIN( ).
1
cExpression is an expression that is 1 byte long.
2
cExpression is an expression that is 2 bytes long.
4
cExpression is an expression that is 4 bytes long.
cExpression is an expression that is 8 bytes long.
cExpression is a double data type, and must be 8 bytes long.
CTOBIN( ) returns a double data type value. This is the default for an expression that is 8 bytes long.
cExpression is a numeric data type, and must be 4 or 8 bytes long.
CTOBIN( ) returns a numeric type value.
Y
cExpression is a currency data type, and must be 8 bytes long.
CTOBIN( ) returns a currency type value.
R
Reverses the binary expression.
S
Prevents the sign bit of number from being toggled (BITXOR).
</param>
<returns>
Numeric. <b>CTOBIN( )</b> returns a numeric value from a binary character expression.
</returns>
<remarks>
The cFlags parameter is a character expression. The 'R' and 'S' settings are additive while the others are mutually exclusive. Character settings can be passed in either upper or lower case (e.g., 'R' or 'r'). Specifying a value of '1', '2' or '4' is not required, but is available as a convenience to provide feedback for the length of cExpression.
The following examples show various uses of the cFlags parameter.
 <code language="X#">? CTOBIN("A")&amp;&amp; same as CTOBIN("A","1")
? CTOBIN(BINTOC($12.34,"8"),"Y")
? CTOBIN(BINTOC(12.34,"8"),"B")
? CTOBIN(BINTOC(PI(),"BR"),"NRS")</code>
You can use CTOBIN( ) to convert a binary character representation created with BINTOC( ) to its integer value. CTOBIN( ) can also be used when working with Win32 API routines where you might need to convert to or from a Win32 struct member. The 'R' and 'S' settings allow you to use CTOBIN ( ) to work more efficiently with these scenarios. 
</remarks>
</ctobin>
<ctod>
<summary>
Converts a character expression to a date expression.
</summary>
<param name="cExpression">

Specifies a character expression.
</param>
<returns>
Date data type. CTOD( ) returns a Date value.
</returns>
<remarks>
CTOD() can create ambiguous Date values and generates a compilation error when SET STRICTDATE is set to 2. To create unambiguous Date values, use the DATE( ) function.
</remarks>
<example>
 <code language="X#">SET CENTURY ON               &amp;&amp; Shows the century value.
cDate="01/01/2003"
?CTOD(cDate)               &amp;&amp; Returns 01/01/2003 as Date.
?GOMONTH(CTOD(cDate),12)   &amp;&amp; Returns 01/01/2004.
?CTOD(cDate)+100            &amp;&amp; Returns 04/11/2003.</code>
</example>
</ctod>
<ctot>
<summary>
Returns a DateTime value from a character expression.
</summary>
<param name="cCharacterExpression">

Specifies the character expression from which a DateTime value is returned.
</param>
<returns>
DateTime data type. CTOT( ) returns a DateTime value from a character expression.
</returns>
<remarks>
CTOT() can create ambiguous DateTime values and generates a compilation error when SET STRICTDATE is set to 2. To create nonambiguous Date values, use the DATETIME( ) function instead.
X# supports the native SQL Datatypes Datetime and Smalldatetime, which are returned in 24 hour format in SQL XML. 
The CTOT() function does not address the 19 different ways that T-SQL Convert() function returns datetime and smalldatetime values. 
To convert date formats from Access, SQL Server, Visual Studio, and XML, you must call the appropriate SET DATE setting to interpret DateTime strings properly. However, if an uppercase T is in the XML date string, X# overrides the current date setting by internally calling SET DATE YMD and restores the current date setting when exiting CTOT( ). 
CTOT( ) resolves these dates to the limits of precision of the X# DateTime data type. Therefore, precision can be lost when using CTOT( ) with certain formats. The X# DateTime data type does not support milliseconds or time zones.
CTOT( ) respects the setting of the SET CENTURY command. For more information, see SET CENTURY Command.
The following examples show how CTOT( ) handles DateTime values from different sources. In all examples, CTOT( ) converts the DateTime values correctly without needing to call SET DATE YMD.  
Access 2000 XML date format 
 <code language="X#">* 2000-10-24T13:30:00 (24-hour format is exported from Access,
* whether original was in 12- or 24-hour format)
? CTOT("2000-10-24T13:30:00")</code>
SQL Server 2000 XML date format 
 <code language="X#">? CTOT("2000-10-24T20:47:58.170")   &amp;&amp; datetime (24-hour format)
? CTOT("2000-10-24T21:11:00")         &amp;&amp; Small DT (24-hour format)
? CTOT("2000-10-03T02:02:02")</code>
Visual Studio XML 
 <code language="X#">? CTOT("2002-10-05T04:04:04.0000000-07:00")</code>
Simple Object Access Protocol (SOAP) 
 <code language="X#">? CTOT("2001-09-14T07:00:00Z")</code>
</remarks>
</ctot>
<curdir>
<summary>
Returns the current directory.
</summary>
<param name="cExpression">

Specifies the drive or volume for which CURDIR( ) returns the current directory or folder. If you omit cExpression, the current default drive or volume is assumed. The empty string is returned if the drive or volume you specify in cExpression doesn't exist. Note that this argument is only included for earlier versions of X# and FoxPro running under Window 3.1 or MS-DOS.
</param>
<returns>
Character
</returns>
<remarks>
CURDIR( ) returns, as a character string, the current MS-DOS directory on a specified drive.
</remarks>
<example>
 <code language="X#">CLEAR
? 'Current directory: ', CURDIR( )
gcOldDir = SET('DEFAULT') + SYS(2003)
SET DEFAULT TO (HOME( ))
? 'X# directory: ', CURDIR( )
SET DEFAULT TO (gcOldDir)
? 'Current directory: ', CURDIR( )</code>
</example>
</curdir>
<cursorgetprop>
<summary>
Retrieves the current property settings for a X# table or a cursor. 
To set a specific property for a X# table or a cursor, use <b>CURSORSETPROP( )</b>. For additional information about each of the properties and their settings, see CURSORSETPROP( ) Function.
</summary>
<param name="cProperty">

Specifies the property setting to retrieve.
The following table includes a list of properties whose settings can be returned, the data type of the return value, and a description of the return value.   
cProperty
ADOBookmark
Variant
Contains a value that corresponds to an ADO Bookmark for the current record in an ADO-based cursor.
ADOCodePage
N
Returns the code page bound to an ADO-based cursor as specified by the ADOCodePage Property. Read-only.
ADORecordset
Contains an object reference to the ActiveX Data Object (ADO) Recordset associated with the cursor. Not valid for cursors that are not based on ADO Recordsets. Read-only. 
AllowSimultaneousFetch
L
Applies when using remote views, a shared connection, and to cursors created using ODBC. 
AllowSimultaneousFetch contains True (.T.) when similarly configured cursors sharing the connection are permitted to fetch rows simultaneously. 
Otherwise, AllowSimultaneousFetch contains False (.F.) when fetching rows simultaneously is not permitted.
AutoIncError
Contains True (.T.) when attempts to insert or update a value in a field that uses automatically incrementing field values generate an error message. 
Contains False (.F.) when attempts to insert or update a value in a field that uses automatically incrementing field values does not generate an error message and the specified value to be inserted or updated is disregarded.
Applies to cursors and sessions.
Read/write.
BatchUpdateCount*
Contains the number of update statements sent to the remote data source for buffered tables. The default value is 1. Adjusting this value can greatly increase update performance.
Buffering
1 – Row and table buffering is off. (Default)
2 – Pessimistic row buffering is on.
3 – Optimistic row buffering is on.
4 – Pessimistic table buffering is on.
5 – Optimistic table buffering is on.
CompareMemo
Contains True (.T.) if WHERE clause for updates includes memo fields of type Memo, General, or Picture. (Default). 
Otherwise, contains False (.F.).
For views only.
ConnectHandle
The connection handle. This property is valid only when the data source contains a remote table. The connection handle obtained for a view might close when the view closes.
ConnectName
The connection name used when the cursor is created. This property is valid only when the data source contains a remote table.
Database
The name of the database that contains the table or view. If a table is a free table, Database contains an empty string.
FetchAsNeeded
If True (.T.), data is fetched only when needed, such as when record pointer moves to a row that has not been fetched.
If False (.F.), additional data is fetched during idle time. (Default)
FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).
FetchIsComplete
If True (.T.), the fetch process is complete for an ODBC or ADO-based cursor.
If False (.F.), the fetch process has not been completed.
This option is not supported for tables and local views or on the environment level (work area 0).
FetchMemo*
Contains True (.T.) if memo fields are fetched with the view results. Otherwise, contains False (.F.). (Default).
Use the ISMEMOFETCHED( ) Function to determine if the memo field has been fetched.
FetchSize*
Contains the number of rows fetched at a time from the remote tables. The default is 100 rows. Setting FetchSize to –1 retrieves the complete result set, limited by the MaxRecords setting.
Progressive fetching holds the connection until all rows are retrieved. Use caution coding with FetchSize if ShareConnection is True (.T.).
KeyFieldList
A comma delimited list of primary fields for the cursor.
MapBinary
Contains True (.T.) if <b>Varbinary</b> mapping is turned on. Otherwise, contains (.F.).
Read/write for nWorkArea set to 0 only. Read-only for SQL Pass-Through cursors. Invalid for table cursors (nWorkArea equal to or greater than 1).
MapVarchar
Contains True (.T.) if <b>Varchar</b> mapping is turned on. Otherwise, contains False (.F.).
MaxRecords*
The maximum number of rows fetched when result sets are returned. The default value is – 1 (all rows are returned). A value of 0 specifies that the view is executed but no results are fetched.
ParameterList
A semi-colon delimited list of view parameters and parameter types. For views only.
Prepared
Contains True (.T.) if SQL statements are prepared for subsequent REQUERY( ) function calls. Otherwise, contains False (.F.). (Default). 
REQUERY( ) is used to retrieve data again for a SQL view. See SQLPREPARE( ) for additional information about preparing SQL statements. For views only.
RecordsFetched
Contains a numeric value that indicates the number of records fetched from the data source for an ODBC or ADO-based cursor.
This numeric value may not reflect the current record count for the cursor if records were locally deleted or appended.
Any filter conditions are ignored in the record count.
Refresh
Contains a numeric value that indicates the refresh setting for an individual cursor in the current data session or an initial refresh value for newly opened cursors in the current data session.
SendUpdates
Contains True (.T.) if a SQL update query is sent to update tables when an update is made using the view; otherwise, contains false (.F.) (default).
SourceName
Contains the long name for a SQL view or a table in a database, or the file path and table name for a free table.
SourceType
1 – The data source is a local SQL view.
101 (1 + 100) - Cursor is created by the <b>CursorFill</b> method.
201 (1 + 200) - Cursor is attached to a <b>CursorAdapter</b> object using the <b>CursorAttach</b> method.
2 – The data source is a remote SQL view.
102 (2 + 100) - Cursor is created by <b>CursorFill</b>.
202 (2 + 200) - Cursor is attached to a <b>CursorAdapter</b> object using <b>CursorAttach</b>.
3 – The data source is a table.
103 (3 + 100) - Cursor is created by <b>CursorFill</b>.
203 (3 + 200) - Cursor is attached to a <b>CursorAdapter</b> object using <b>CursorAttach</b>.
4 - The cursor is based on ADO Recordset and attached to a <b>CursorAdapter</b> object.
104 (4 + 100) - Cursor is created by <b>CursorFill</b>.
204 (4 + 200) - Cursor is attached to a <b>CursorAdapter</b> object using <b>CursorAttach</b>.
The SQL statement executed when the cursor is created.
Tables
A comma delimited list of the names of tables.
UpdatableFieldList
A comma delimited list of fields in the view. This list can include fields from local and remote tables.
UpdateNameList
A comma delimited list of remote field names and the local field names assigned to the cursor. Use this option to specify valid X# names for fields in the cursor that have invalid X# field names.
UpdateType
1 – Specifies that old data is updated with the new data. (Default).
2 – Specifies that updates occur by deleting the old data and inserting the new data.
UseMemoSize*
The minimum size, in bytes, for result columns to return in memo fields. For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field. UseMemoSize may vary from 1 to 255; the default value is 255.
WhereType
The <b>WHERE</b> clause for updates to tables. WhereType can specify the following values:
1 or <b>DB_KEY</b> (from FOXPRO.H). The WHERE clause used to update tables consists of only the primary fields specified with the KeyFieldList property.
2 or <b>DB_KEYANDUPDATABLE</b> (from FOXPRO.H). The WHERE clause used to update tables consists of the primary fields specified with the KeyFieldList property and any updatable fields.
3 or <b>DB_KEYANDMODIFIED</b> (from FOXPRO.H) (default). The WHERE clause used to update tables consists of the primary fields specified with the KeyFieldList property and any other fields that are modified.
4 or <b>DB_KEYANDTIMESTAMP</b> (from FOXPRO.H). The WHERE clause used to update tables consists of the primary fields specified with the KeyFieldList property and a comparison of the time stamps.
* The value returned by this property is significant only for remote views; if you get this property for local views, the <b>CURSORGETPROP( )</b> function returns the default value.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor from which the property setting is returned. If you specify 0 for nWorkArea, <b>CURSORGETPROP( )</b> returns the environment setting.

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor from which the property setting is returned.
</param>
<returns>
Character, Numeric, or Logical data type
</returns>
<remarks>
The current property settings are returned for the table or cursor open in the currently selected work area if <b>CURSORGETPROP( )</b> is issued without the optional cTableAlias or nWorkArea arguments. If you use CURSORGETPROP( ) without a table selected, a cursor open, or an alias specified, you get Error 52 (No table is open in current work area.) unless a work area is specified as in this example, CURSORSETPROP("Refresh",-2,0).
</remarks>
<example>
When a cursor is opened, the default value for the AutoIncError property is read from the session default value, which is the current default data session setting. The following example shows how you can retrieve the default AutoIncError value for each session by specifying 0 (default session) as the last parameter:
 <code language="X#">CURSORGETPROP("AutoIncError", 0) </code>
The default session is used when opening a new private data session or cursor. The following example shows how you can retrieve the cursor or table AutoIncError setting for each table by using the nWorkArea or cTableAlias parameter as the last parameter:
 <code language="X#">CURSORGETPROP("AutoIncError", nWorkArea | cTableAlias)</code>
The following example opens a "Customer" table in the "Testdata" database and uses <b>CURSORGETPROP( )</b> to display the buffering mode for the table and the name of the database in which the table is contained:
 <code language="X#">CLOSE DATABASES
CLEAR
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer     &amp;&amp; Open customer table
? CURSORGETPROP("Buffering") &amp;&amp; Displays buffering mode
? CURSORGETPROP("Database")  &amp;&amp; Displays database name</code>
</example>
</cursorgetprop>
<cursorsetprop>
<summary>
Specifies property settings for a X# table or a cursor.
</summary>
<param name="cProperty">

Specifies the table or cursor property to set. Buffering is the only property you can specify for a X# table.

</param>
<param name="eExpression">

Specifies the value for the property you specify with cProperty. If you omit eExpression, the property is set to its default value.
The following table lists the properties you can specify for cProperty and a description of the values eExpression can assume.
eExpression values
AllowSimultaneousFetch
Applies when using remote views, a shared connection, and to cursors created using ODBC. 
.T. - Permit similarly configured cursors sharing the connection to fetch rows simultaneously. 
.F. - Do not permit similarly configured cursors sharing the connection to fetch rows simultaneously.
AutoIncError
.T. - Generate an error message when attempting to insert or update values in a field that uses automatically incrementing field values. 
.F. - Does not generate an error message but does not use the value specified when attempting to insert or update the value in a field that uses automatically incrementing field values, which uses the appropriate incremented value.
Applies to cursors and sessions.
BatchUpdateCount*
Specifies the number of update statements to send to the remote data source for buffered tables. The default value is 1. Adjusting this value can greatly increase update performance when using automatic updating.
Buffering
1 – Sets row and table buffering off. Record locking and data writing are identical to earlier FoxPro versions. (Default)
2 – Sets pessimistic row buffering on.
3 – Sets optimistic row buffering on.
4 – Sets pessimistic table buffering on.
5 – Sets optimistic table buffering on. <b>SET MULTILOCKS</b> must be <b>ON</b> for all Buffering modes except 1 (off).
CompareMemo
.T. - Include memo fields of type Memo, General, or Picture in the <b>WHERE</b> clause for updates. 
.F. – Do not include memo fields in the WHERE clause for updates.
Applies when automatic updating is used.
FetchAsNeeded
.T. – Fetch records only when needed, such as when record pointer moves to a row that has not been fetched.
.F. – Fetch additional data during idle time.
FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).
FetchMemo*
.T. – Fetch memo fields with the view results. 
.F. – Do not fetch memo fields with the view results.
FetchSize*
Specifies the number of rows progressively fetched from the remote table result set. The default value is 100 rows. Setting FetchSize to –1 retrieves the complete result set, limited by the MaxRecords setting.
Progressive fetching holds the connection until all rows are retrieved. Use caution coding with FetchSize if ShareConnection is True (.T.).
KeyFieldList
Specifies a comma-delimited list of primary fields for the cursor. No default. You must include a list of field names for updates to work when using automatic updating.
MapBinary
.T. - At the session level, SQL Pass-Through maps SQL_BINARY, SQL_VARBINARY, and SQL_LONGVARBINARY ODBC types to <b>Varbinary</b> or <b>Blob</b> data type.
For remote views, the <b>CREATE SQL VIEW</b> command maps the SQL_LONGVARBINARY ODBC data source type to <b>Blob</b> type, and it maps SQL_BINARY and SQL_VARBINARY ODBC data source types to <b>Varbinary</b> type when the precision of the corresponding column in the data source is less than or equal to 254 bytes. When precision is greater than 254 bytes, these types map to <b>Blob</b> type. 
.F. - SQL Pass-Through maps SQL_BINARY and SQL_VARBINARY ODBC types to <b>Character</b> type. (Default)
For remote views, the <b>CREATE SQL VIEW</b> command maps SQL_BINARY and SQL_VARBINARY ODBC data source types to <b>Memo</b> type.
<b>MapBinary</b> is read/write for nWorkArea set to 0, read-only for SQL Pass-Through cursors, and invalid for table cursors (nWorkArea equal to or greater than 1).
MapVarchar
.T. - At the session level, SQL Pass-Through maps SQL_WVARCHAR and SQL_VARCHAR ODBC types to <b>Varchar</b> type. 
For remote views, <b>CREATE SQL VIEW</b> command maps SQL_WVARCHAR and SQL_VARCHAR ODBC data source types to <b>Varchar</b> type.
.F. - SQL Pass-Through maps SQL_WVARCHAR and SQL_VARCHAR ODBC types to <b>Character</b> type. (Default)
For remote views, <b>CREATE SQL VIEW</b> command maps SQL_WVARCHAR and SQL_VARCHAR ODBC data source types to <b>Character</b> type.
<b>MapVarchar</b> is read/write for nWorkArea set to 0, read-only for SQL Pass-Through cursors, and invalid for table cursors (nWorkArea equal to or greater than 1).
MaxRecords*
Specifies the maximum number of rows fetched when returning result sets. The default value is – 1, and all rows are returned. A value of 0 specifies that the view is executed but no results are fetched.
ParameterList
Specifies a semi-colon delimited list of view parameters and parameter types. For views only.
Prepared
.T. - Prepare SQL statements for subsequent <b>REQUERY( )</b> function calls. 
.F. - Do not prepare SQL statements for subsequent <b>REQUERY( )</b> calls. (Default).
<b>REQUERY( )</b> is used to retrieve data again for a SQL view. For additional information about preparing SQL statements, see SQLPREPARE( ) Function.
Refresh
Specifies a numeric refresh value for an individual cursor in the current data session or an initial refresh value for newly opened cursors in the current data session.
Use the SET DATASESSION Command to select a specific data session, and use the cTableAlias or nWorkArea parameter to specify a specific cursor. Use nWorkArea = 0 to change the initial refresh value for all newly opened cursors. Any cursors that are already open will not be affected by the new refresh setting.
SET REFRESH Command allows you to specify a global refresh value. By default, the CURSORSETPROP( ) Refresh setting is -2, which indicates that the current global SET REFRESH value is used. The global SET REFRESH value is specified with its second parameter, nSeconds2.
You can set the CURSORSETPROP( ) Refresh setting to the same values as the nSeconds2 parameter in SET REFRESH.
<b>Note</b>   The  CURSORSETPROP( ) Refresh setting will be ignored if the nSeconds2 parameter is currently set to zero in the SET REFRESH command.
SendUpdates
.T. – Specifies that a SQL update query is sent to update tables when an update is made using the view.
.F. – Specifies that a SQL update query is not sent to update tables.
Tables
Specifies a comma-delimited list of the names of remote tables. No default. You must include a list of table names for updates to work when using automatic updating.
UpdatableFieldList
Specifies a comma-delimited list of fields in the view. This list can include fields from local and remote tables. You must include a list of fields for updates to work when using automatic updating.
UpdateNameList
Specifies a comma-delimited list of remote field names and the local field names assigned to the cursor. Use this option to specify valid X# names for fields in the cursor that have invalid X# field names.
UpdateType
1 – Update old data with new data. (Default)
2 – Update by deleting old data and inserting new data.
UseMemoSize*
Specifies the minimum size in bytes for result columns to return in memo fields. For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field. UseMemoSize can vary from 1 to 255 bytes. The default value is 255 bytes.
WhereType
The <b>WHERE</b> clause for updates to remote tables. WhereType can assume the following values:
1 or <b>DB_KEY</b> (from FOXPRO.H). The WHERE clause used to update remote tables consists of only the primary fields specified with the KeyFieldList property.
2 or <b>DB_KEYANDUPDATABLE</b> (from FOXPRO.H). The WHERE clause used to update remote tables consists of the primary fields specified with the KeyFieldList property and any updatable fields.
3 or <b>DB_KEYANDMODIFIED</b> (from FOXPRO.H). The WHERE clause used to update remote tables consists of the primary fields specified with the KeyFieldList property and any other fields that are modified. (Default)
4 or <b>DB_KEYANDTIMESTAMP</b> (from FOXPRO.H). The <b>WHERE</b> clause used to update remote tables consists of the primary fields specified with the KeyFieldList property and a comparison of the time stamps.
* This property is primarily used for remote views; setting it has no effect on local views. However, you can preset this property for local views that will be upsized.

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor for which the property is set.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor for which the property is set. If you specify 0 for nWorkArea, <b>CURSORSETPROP( )</b> sets the environment setting used for all subsequent tables or cursors.
Buffering is not applied to tables that are opened implicitly, for example, using SQL INSERT/UPDATE/DELETE commands.
</param>
<returns>
Logical data type. <b>CURSORSETPROP( )</b> returns True (.T.) if X# successfully sets the property you specify. X# generates an error if the property you specify cannot be set.
</returns>
<remarks>
The setting of the Buffering property for <b>CURSORSETPROP( )</b> determines how X# performs record locking and update buffering. For additional information about record locking and update buffering, see How to: Buffer Data.
The setting of the WhereType property for <b>CURSORSETPROP( )</b> determines how updates are performed on remote tables. For additional information about remote table updates, see Developing Databases.
You can use <b>CURSORSETPROP( )</b> to override the FetchSize property in the <b>SQLSETPROP( )</b> function for a cursor. This property is inherited from the cursor's connection handle by default.
Use <b>CURSORGETPROP( )</b> to return the current property settings for a X# table or a cursor created for a table.
If <b>CURSORSETPROP( )</b> is issued without the optional cTableAlias or nWorkArea arguments, the property setting is specified for the open table or cursor in the currently selected work area.
</remarks>
<example>
When a cursor is opened, the default value for the AutoIncError property is read from the session default value, which is the current default data session setting. The following example shows how you can set the default AutoIncError value for each session by specifying 0 (default session) as the last parameter:
 <code language="X#">CURSORSETPROP("AutoIncError", .T., 0) </code>
The default session is used when opening a new private data session or cursor. The following example shows how you can set the cursor or table AutoIncError setting for each table by using the cTableAlias or nWorkArea parameter as the last parameter:
 <code language="X#">CURSORSETPROP("AutoIncError", .F. , cTableAlias | nWorkArea )</code>
The following example demonstrates how you can enable optimistic table buffering with <b>CURSORSETPROP( )</b>. <b>MULTILOCKS</b> is set to <b>ON</b>, a requirement for table buffering. The "Customer" table in the "testdata" database is opened, and <b>CURSORSETPROP( )</b> is used to set the buffering mode to optimistic table buffering (5). A message box is displayed showing the result of the operation.
 <code language="X#">CLOSE DATABASES
CLEAR
SET MULTILOCKS ON
OPEN DATABASE (HOME(2) + 'data\testdata')
USE Customer     &amp;&amp; Open Customer table.
* Set buffering mode and store logical result
lSuccess=CURSORSETPROP("Buffering", 5, "Customer")
IF lSuccess = .T.
=MESSAGEBOX("Operation successful!",0,"Operation Status")
ELSE
=MESSAGEBOX("Operation NOT successful!",0,"Operation Status")
ENDIF</code>
</example>
</cursorsetprop>
<cursortoxml>
<summary>
Converts a X# cursor to XML.
</summary>
<param name="uArea">

Specifies the work area number or alias of the table from which to create the XML string. 
If you specify 0 or no value, X# uses the current work area. 

</param>
<param name="cOutput">

Specifies the path and file name or memory variable name to which results are sent. 
If nFlags is set to 0 (default) for memory variable output, XML is returned to the memory variable. If the memory variable does not exist, it is created.
If nFlags is set to 512 for file output, and the file does not exist, it is created. If the file already exists, it is overwritten. The setting for <b>SET SAFETY</b> is observed. 

</param>
<param name="nOutputFormat">

Specifies the output format of the XML string. The following table lists the values for nOutputFormat.
nOuputFormat
1 – ELEMENTS
(Default) Element-centric XML 
2 – ATTRIBUTES
Attribute-centric XML
3 – RAW
Generic, attribute-centric XML

</param>
<param name="nFlags">

Specifies the formatting of the XML that is produced and its destination. The following table lists the values for nFlags.
0
0000
(Default) Produce XML in UTF-8 format. 
This setting creates a memory variable if one does not exist when specified by cOutput and returns XML to the memory variable.
The XML declaration does not contain an Encoding= attribute; that is, no encoding attribute is set to UTF-8.
1
0001
Produce unformatted XML as a continuous string.
2
0010
Enclose empty elements with open and closing elements, for example, &lt;cc04&gt;&lt;cc04/&gt;.
0100
Preserve white space in fields.
1000
Wrap Memo fields in CDATA sections.
16
10000
Output encoding. Output is set to the cursor code page. 
To ensure accurate character translation, the X# default code page must match the code page of the cursor. You can accomplish this by setting character and memo fields in the cursor to <b>NOCPTRAN</b> (character binary/memo binary).
When setting this value with tables using any of the code pages, the encoding attribute in the XML is set to an empty string (""). To change to the correct encoding attribute, use the STRTRAN( ) function. 
For example, for code page 936, provide the following to the resulting XML string:
 <code language="X#">strxml=STRTRAN(strxml, 'encoding=""', 'encoding="gb2312"'</code>
32
100000
512
1000000000
Output to the file specified by cOutput.
If a file does not exist, it is created. If the file already exists, it is overwritten. The setting for <b>SET SAFETY</b> is observed.
4096
1000000000000
Disables base64 encoding. 
<b>CURSORTOXML( )</b> exports Memo (Binary) fields as xsd:base64binary unless you use nFlags set to 4096. In X#, base64 encoding is meant for encoding only binary data.
32768
none
Indicates that a code page should be used.
The following table describes how the encoding attribute is written when output encoding defaults to the cursor or table code page.   
Encoding flags are set by combining bits 4 and 5 (0010000).
+0
(Default) Windows-1252. 
+16
Set output encoding attribute to the cursor code page.
+32
Set output encoding attribute to UTF-8 with no character translation.
+48
11
Set output encoding attribute to UTF-8 and translate character data to UTF-8.
The following table lists common Windows-compatible code pages.   
437
MS-DOS, US
ibm437
850
MS-DOS, International
ibm850
865
MS-DOS, Nordic
Empty string ("")
866
MS-DOS, Russian
cp866
932
Windows, Japanese
shift-jis
Simplified Chinese
949
Windows, Korean 
iso-2022-kr
or:
ks_c_5601-1987
950
Windows, Traditional Chinese (Taiwan) 
big5
1250
Windows, East European
Windows-1250
Note case.
1251
Windows, Russian
Windows-1251
Windows, U.S., West European
1253
Windows, Greek
Windows-1253
1254
Windows, Turkish
Windows-1254
1255
Windows, Hebrew
Windows-1255
1256
Windows, Arabic
Windows-1256
X# uses Windows-1252 as the default encoding. You can specify that the encoding attribute be set to match the code page, such as Big5 (code page 950), when using double-byte character sets (DBCS) for DBCS languages for which X# supports code pages. 
When using Windows-1252 and DBCS, no additional character translation is required to display correctly in Internet Explorer. 
However, to make XML more compliant for Web browsers that can interpret UTF-8, you can optionally set the encoding attribute to UTF-8 instead of Windows-1252. The result set undergoes translation to UTF-8 characters only when you set nFlags to 48 (specify the encoding attribute as UTF-8 and translate character data to UTF-8 format). This is required only when the data actually contains double-byte characters. You do not have to use character translation, <b>STRCONV ( )</b>, for example, if you are outputting only Latin (single byte) characters.  

</param>
<param name="nRecords">

Specifies the number of records to output to XML and has a default value is 0. 
If nRecords is 0, all records are output. If nRecords is greater than the number of records remaining in the table, all remaining records are output. 

</param>
<param name="cSchemaName">

Specifies the name and location to contain schema information for the data in cOutput, for example "MySchema.xsd". If no extension is provided, the schema file is created with an .xsd extension.
The following table lists the values for cSchemaName.   

Specifies the name and path of the external file for the schema (scoped to the root element of the XML). 
If cSchemaName contains a file name and cSchemaLocation is not provided or is blank, the contents of cSchemaName xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute in the XML.
In the following example, X# generates a generic XML file named MyXMLFile.xml from the Labels.dbf file in the "Labels" alias and the schema file named MySchema in the same folder. 
 <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "mySchema.xsd")</code>
If cSchemaName includes a URI, the schema is written to the current directory and must be uploaded to the server to be accessed by the browser or parser. External schemas always are written to the same location as the XML file.
"1"
Specifies an inline schema is produced. For example, the following code produces an inline schema: 
 <code language="X#">CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, "1")</code>
""
Specifies that no schema is produced. 

</param>
<param name="cSchemaLocation">

Specifies an optional location where the application reading the XML data should look for the schema file. 
Use this parameter only when you are deploying your schema to a location other than the location of the XML data.
The contents of cSchemaLocation xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute of the XML data produced. The cschemaLocation parameter can be an HTTP address or other URI. You need to copy the schema file to the location you have specified in cSchemaLocation.   
The following example produces XML data:   
 <code language="X#">   CURSORTOXML("LABELS", "myXMLFile.xml", 1, 512, 0, ;
"mySchema.xsd", "http://www.microsoft.com/mySchema.xsd")</code>
containing the following attribute:   
 <code language="X#">   xsi:noNamespaceSchemaLocation=" http://www.microsoft.com/mySchema.xsd"</code>
Specifying cSchemaLocation when cSchemaName is blank causes the same attributes to be written to the XML data. This makes it possible for you to point to an existing schema without recreating the schema each time <b>CURSORTOXML( )</b> is called. 

</param>
<param name="cNamespace">

Specifies the namespace of the XML or schema to be produced and has an empty string ("") as the default value. 
Specifying a value for cNameSpace sets the targetNamespace attribute to the same value and adds the elementFormDefault="qualified" attribute to the schema.   
If you do not specify a cNamespace value, and the schema is external, no namespace declaration is written to the schema. If you do not specify a cNamespace value and the schema is inline, the targetNamespace in the schema is set to an empty string ("").
</param>
<returns>
Numeric data type. <b>CURSORTOXML( )</b> returns the number of bytes written to the file or a memory variable.
</returns>
<remarks>
You can use <b>CURSORTOXML( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported because the <b>_VFP</b> system variable is not supported in the OLE DB Provider.
To use the X# OLE DB Provider with <b>CURSORTOXML( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.

<b>CURSORTOXML( )</b> output adheres to the cursor index order, <b>SET FIELDS TO</b>, and current filter settings. However, it does not preserve the cursor location. After the calling <b>CURSORTOXML( )</b>, if all records are output, the cursor record pointer reports <b>EOF</b>. If not all records are output, it points to the last record output to XML.
The resulting XML from <b>CURSORTOXML( )</b> contains the same scale as the exported table if the table contains <b>Double</b> data type values. For example, if a <b>Double</b> column is created with a scale of 6 using the following codem the resulting XML contains six digits to the right of the decimal point:
 <code language="X#">CREATE TABLE test (col1 b(6))</code>
When you use the <b>CURSORTOXML( )</b> function to export a table or cursor to XML, the root node is always called "VFPData", regardless of the output format.
For <b>Date</b> types only, you can export "EMPTY" <b>Date</b> and <b>DateTime</b> types using <b>CURSORTOXML( )</b>. However, the XML schema validation might fail because "EMPTY" is not valid for these types in an XML schema definition (XSD) schema. This is an issue only if a schema is required, and the resulting XML is validated against an XML parser that can interpret XSD schemas. To work around this issue, you might need to change the data to a nonempty representation by calling the appropriate <b>SELECT</b> statement and use <b>CURSORTOXML( )</b> on the created cursor. For example, you can change the empty <b>Date</b> or <b>DateTime</b> values to .<b>NULL.</b>:
 <code language="X#">SELECT orderid, EVL(shippeddate,.NULL.) as ShippedDate FROM orders</code>
You can also change the empty <b>Date</b> or <b>DateTime</b> to an appropriate representation for "empty":
 <code language="X#">SELECT orderid, IIF(EMPTY(shippeddate),{^1899-12-30 00:00:00},tc11);
</code>
When using flag 32768, the flags 16 and 32 settings can affect which code page is applied depending on the type of data you are writing to XML. The following tables show the possible combinations of settings and the code page each combination applies.
For XML documents written with the 32768 flag set, the following code pages are applied.
Flag 16
Flag 32
Flag 32768 is Set
Not set
Not set
XML documents: Window-1252.
Unicode data: code page 1252.
Character data: default code page, unless a field is marked as <b>NOCPTRANS</b>.
True (.T)
Not set
XML documents: Plus-<b>CodePage</b> property of the cursor. If XMLField <b>CodePage</b> property is greater than zero (0) and it doesn’t match the cursor’s code page, an error is reported.
Unicode data: the <b>Code page</b> property of the cursor object.
Character data: none. Raw data from the X# tables (.dbf) are used instead.
Not set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: Default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
Set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: default code page unless a field is marked as <b>NOCPTRANS</b>, in which case the data are translated to UTF-8 using the <b>SYS(3005)</b> setting.
For XML documents written without setting the 32768 flag, the following code pages are applied.
Flag 16
Flag 32
Without the 32768 flag
Not set
Not set
XML documents: Window-1252.
Unicode data: code page 1252.
Character data: default code page unless a field is marked as <b>NOCPTRANS</b>.
True (.T)
Not set
XML documents: <b>CodePage</b> property of the cursor.
Character data: none. Raw data from the X# tables (.dbf) are used instead.
Unicode data: code page property of the cursor object.
Not set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
Set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case, they are translated to UTF-8 using code page for the current <b>SYS(3005)</b> setting.
</remarks>
</cursortoxml>
<curval>
<summary>
Returns field values directly from disk for a table or a remote data source.
</summary>
<param name="cExpression">

Specifies an expression whose value CURVAL( ) returns from a table or a remote data source. cExpression is typically a field or an expression consisting of a set of fields from the table or remote data source.

</param>
<param name="uArea">

Specifies the alias or workarea number of the table from which the field values are returned from disk for a table or a remote data source.

</param>
<returns>
Character, Currency, Date, DateTime, Double, Float, Logical, Numeric, or Memo
</returns>
<remarks>
The field values returned by CURVAL( ) and OLDVAL( ) can be compared to determine if another user on a network changed the field values while the fields were being edited. CURVAL( ) and OLDVAL( ) can only return different values when optimistic row or table buffering is enabled. Optimistic row or table buffering is enabled with CURSORSETPROP( ).
If you are working with a view in a multiuser environment, the values returned by CURVAL() might not be up to date unless you call the REFRESH() function first. Data returned by a view is buffered, and the CURVAL() function reads values from the buffer. However, if other users have changed data in the underlying tables for the view, the buffered data is not updated until the REFRESH() function is called.
CURVAL( ) returns field values for the current record, and the return value data type is determined by the expression you specify with cExpression.
The value is returned for the table or cursor open in the currently selected work area if CURVAL( ) is issued without the optional cTableAlias or nWorkArea arguments.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
CREATE TABLE mytable FREE (cDigit C(10))
* Store original value
INSERT INTO mytable (cDigit) VALUES ("One")
SET MULTILOCKS ON        &amp;&amp; Allow optimistic table buffering
= CURSORSETPROP("Buffering",5)   &amp;&amp; Optimistic table buffering on
REPLACE cDigit WITH "Two"    &amp;&amp; New value
? "Current value: " + CURVAL("cDigit", "mytable")
? "Old value: " + OLDVAL("cDigit", "mytable")
= TABLEUPDATE(.T.)       &amp;&amp; Commit changes made to table
? "Table changes committed"
? "New current value: " + CURVAL("cDigit", "mytable")
? "New old value: " + OLDVAL("cDigit", "mytable")</code>
</example>
</curval>
<date>
<summary>
Returns the current system date, which is controlled by the operating system, or creates a year 2000-compliant Date value.
</summary>
<param name="nYear">

Specifies the year returned in the year 2000-compliant Date value. nYear can be a value from 100 to 9999.

</param>
<param name="nMonth">

Specifies the month returned in the year 2000-compliant Date value. nMonth can be a value from 1 to 12.

</param>
<param name="nDay">

Specifies the day returned in the year 2000-compliant Date value. nDay can be a value from 1 to 31.
</param>
<returns>
Date
</returns>
<remarks>
DATE( ) returns the current system date if it is issued without the optional arguments. Include the optional arguments to return a year 2000-compliant Date value in the format set in the Regional tab of the Options dialog box. Any NULL parameter is replaced with the current system value.
No X# commands or functions can directly change the system date.
</remarks>
<example>
 <code language="X#">CLEAR
SET CENTURY OFF
? DATE( )  &amp;&amp; Displays today's date without the century
SET CENTURY ON
? DATE( )  &amp;&amp; Displays today's date with the century
? DATE(1998, 02, 16)  &amp;&amp; Displays a year 2000-compliant Date value</code>
</example>
</date>
<datetime>
<summary>
Returns the current date and time as a DateTime value, or creates a year 2000-compliant DateTime value.
</summary>
<param name="nYear">

Specifies the year returned in the year 2000-compliant DateTime value. nYear can be a value from 100 to 9999.

</param>
<param name="nMonth">

Specifies the month returned in the year 2000-compliant DateTime value. nMonth can be a value from 1 to 12.

</param>
<param name="nDay">

Specifies the day returned in the year 2000-compliant DateTime value. nDay can be a value from 1 to 31.

</param>
<param name="nHours">

Specifies the hours returned in the year 2000-compliant DateTime value. nHours can be a value from 0 (midnight) to 23 (11 P.M). Defaults to 0 if omitted.

</param>
<param name="nMinutes">

Specifies the minutes returned in the year 2000-compliant DateTime value. nMinutes can be a value from 0 to 59. Defaults to 0 if omitted.

</param>
<param name="nSeconds">

Specifies the seconds returned in the year 2000-compliant DateTime value. nSeconds can be a value from 0 to 59. Defaults to 0 if omitted.
</param>
<returns>
DateTime
</returns>
<remarks>
DATETIME( ) returns the current system DateTime if it is issued without the optional arguments. Any NULL date parameters are replaced with current system values. A NULL time parameter is replaced with 12:00:00.
Include the optional arguments to return a year 2000-compliant DateTime value in the format specified in the Regional tab of the Options dialog box.
</remarks>
<example>
 <code language="X#">tNewyear = DATETIME(YEAR(DATE( ) ) + 1, 1, 1)  &amp;&amp; Next New Year
tToday = DATETIME( )
nSecondstonewyear = tNewyear - tToday
CLEAR
? "There are " + ALLTRIM (STR(nSecondstonewyear)) ;
+ " seconds to the next New Year."
CLEAR
SET CENTURY ON
SET DATE TO AMERICAN
? DATETIME(1998, 02, 16, 12, 34, 56) &amp;&amp; Displays 02/16/1998 12:34:56 PM</code>
</example>
</datetime>
<day>
<summary>
Returns the numeric day of the month for a given Date or DateTime expression.
</summary>
<param name="dExpression">

Specifies a date from which <b>DAY( )</b> returns a day of the month. dExpression can be a date literal, a Date-type variable, an array element, or a date field.

</param>
<param name="tExpression">

Specifies a date or time from which <b>DAY( )</b> returns a day of the month. dExpression can be a DateTime literal, a DateTime-type variable, an array element, or a DateTime field.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>DAY( )</b> returns a number from 1 through 31.
</remarks>
<example>
 <code language="X#">STORE {^1998-03-05} TO gdBDate
CLEAR
? CDOW(gdBDate)  &amp;&amp; Displays Thursday
? DAY(gdBDate) &amp;&amp; Displays 5
? 'That date is ', CMONTH(gdBDate), STR(DAY(gdBDate),2)</code>
</example>
</day>
<dbalias>
<summary>
Returns database alias of currently set database.
</summary>
<returns>
Character.
</returns>
<remarks>
<b>DBALIAS( )</b> returns the empty string if there is no current database.
</remarks>
<example>

<code language="X#">
OPEN DATABASE HOME(2)+"northwind\northwind" SHARED
OPEN DATABASE HOME(2)+"tastrade\data\tastrade" SHARED
SET DATABASE TO NORTHWIND
? DBALIAS()
SET DATABASE TO TASTRADE
? DBALIAS()
? JUSTSTEM(DBC())
</code>
</example>
</dbalias>
<dbc>
<summary>
Returns the name and path of the current database.
</summary>
<returns>
Character
</returns>
<remarks>

<b>DBC( )</b> returns the empty string if there is no current database.
Use SET DATABASE to specify the current database.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')  &amp;&amp; Opens the DBC.
CLEAR
? DBC( )  &amp;&amp; Displays the path and name of the database</code>
</example>
</dbc>
<dbf>
<summary>
Returns the name of a table open in a specified work area or a table name from a table alias.
</summary>
<param name="cTableAlias">

Specifies the table alias.

</param>
<param name="nWorkArea">

Specifies the work area number.
If you omit cTableAlias and nWorkArea, <b>DBF( )</b> returns the name of the table open in the current work area<b>. DBF( )</b> returns an empty string if a table isn't open in the work area you specify. If a table doesn't have the alias you specify with cTableAlias, X# generates an error message.   
For information on creating an alias for a table, see USE.
</param>
<returns>
Character
</returns>
<remarks>
When SET FULLPATH is ON, <b>DBF( )</b> returns the path to the table with the table name. When SET FULLPATH is OFF, <b>DBF( )</b> returns the drive on which the table resides with the table name.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer IN 2 ALIAS mycust
CLEAR
? DBF(2)  &amp;&amp; Displays customer.dbf with its path
? DBF('mycust')  &amp;&amp; Displays customer.dbf with its path
CLOSE DATABASES
? DBF( )      &amp;&amp; Displays the empty string</code>
</example>
</dbf>
<dbgetprop>
<summary>
Retrieves the value of a property for the current database or for fields, named connections, tables, or views in the current database.
You must open the database before you can retrieve its properties or those of its connections, tables, views, or fields. However, you do not need to open a table or view before retrieving its properties.
</summary>
<param name="cName">

Specifies the name of the current open database or the field, named connection, table, or view in the current open database for which <b>DBGETPROP( )</b> returns information.
To return information about a field in a table or a view, preface the name of the field with the name of the table or view containing the field. For example, to return information about the codecustid/code field in the codecustomer/code table, specify the following for cName:   
 <code language="X#">customer.custid</code>

</param>
<param name="cType">

Specifies whether cName is the current database, or a field, named connection, table, or view in the current database. The following table lists the values for cType.
CONNECTION
cName is a named connection in the current database.
DATABASE
cName is the current database.
FIELD
cName is a field in the current database.
TABLE
cName is a table in the current database.
VIEW
cName is a view in the current database.

</param>
<param name="cProperty">

Specifies the name of the property for which <b>DBGETPROP( )</b> returns information.
The following tables list the values you can specify for cProperty, the return value types, and descriptions of each property. Each description includes the read and write privileges for each property. If a property is read-only, its value cannot be changed with <b>DBSETPROP( )</b>.    
<b>Connection properties</b>

Asynchronous
L
The connection mode. (Default) False (.F.) specifies a synchronous connection. True (.T.) specifies an asynchronous connection.
Read/write.
BatchMode
The batch-processing mode. (Default) True (.T.) specifies the connection that operates in batch mode.
Comment
The text of the connection comment.
ConnectString
The login connection string.
ConnectTimeout
N
The connection timeout interval in seconds. The default is 0 (wait indefinitely).
Database
The name of the server database specified with the DATABASE clause in the CREATE CONNECTION command or in the Connection Designer.
DataSource
The name of the data source as defined in the Odbc.ini file.
DisconnectRollback
Specifies if a pending transaction is committed or rolled back when SQLDISCONNECT( ) is called for the last connection handle.
The default is false (.F.), indicating that a pending transaction is committed when SQLDISCONNECT( ) is called for the last connection handle.
Specify true (.T.) to roll back a pending transaction when SQLDISCONNECT( ) is called for the last connection handle.
Connections with automatic transaction processing are not affected by this setting.
DispLogin
Contains a numeric value that determines when the ODBC Login dialog box is displayed. DispLogin may assume the following values:
1 or DB_PROMPTCOMPLETE (from Foxpro.h). 1 is the default.
2 or DB_PROMPTALWAYS (from Foxpro.h).
3 or DB_PROMPTNEVER (from Foxpro.h).
If 1 or DB_PROMPTCOMPLETE is specified, X# displays the ODBC Login dialog box only if any required information is missing.
If 2 or DB_PROMPTALWAYS is specified, the ODBC Login dialog box is always displayed, allowing you to change settings before connecting.
If 3 or DB_PROMPTNEVER is specified, the ODBC Login dialog box is not displayed and X# generates an error if the required login information is not available.
DispWarnings
Contains a logical value that determines if non-trappable warnings from the remote table, ODBC, or X# are displayed. (Default) True (.T.) specifies that non-trappable errors are displayed.
IdleTimeout
The idle timeout interval in minutes. Timeout is checked no more than once per minute, therefore it is possible that active connections might deactivate one or two minutes later after the specified time interval has elapsed. The default value is 0 (wait indefinitely).
PacketSize
The size of the network packet used by the connection. Adjusting this value can improve performance. The default value is 4096 bytes (4K).
PassWord
The connection password.
QueryTimeout
The query timeout interval in seconds. The default value is 0 (wait indefinitely).
Transactions
Contains a numeric value that determines how the connection manages transactions on the remote table. Transactions may assume the following values:
1 or DB_TRANSAUTO (from Foxpro.h). 1 is the default. Transaction processing for the remote table is handled automatically.
2 or DB_TRANSMANUAL (from Foxpro.h). Transaction processing is handled manually through SQLCOMMIT( ) and SQLROLLBACK( ).
UserId
The user identification.
WaitTime
The amount of time in milliseconds that elapses before X# checks whether the SQL statement has completed executing. The default is 100 milliseconds.
<b>Database properties</b>
The text of the database comment.
DBCEventFileName
Relative path and filename of external program file containing DBC Events code.
DBCEvents
Enabled state of DBC Events. Set to True (.T.) to enable.
Version
The database version number.
Read-only.
<b>Field properties for tables</b>
Caption
The field caption. If an equal sign (=) precedes the value of this property, X# evaluates the value as an expression. Otherwise, it is treated as a string literal.
The text of the field comment.
DefaultValue
The field default value.
DisplayClass
Name of the class used for field mapping.
DisplayClassLibrary
Path to the class library specified with the <b>DisplayClass</b> property.
Format
The field display format. See the Format Property for a list of format settings.
InputMask
The field input format. See the InputMask Property for a list of input mask settings.
RuleExpression
The field rule expression.
RuleText
The field rule error text.
<b>Field properties for views</b>
DataType
The data type for a field in a view. Initially set to the data type for the field in the data source.
To specify a different data type for a field with <b>DBSETPROP( )</b>, use the syntax for creating fields in CREATE TABLE – SQL.
For example, to change the data type of an integer field named iCost in a table named Mytable to numeric type with width 4 and 2 decimal places, use
DBSETPROP('mytable.icost', 'field', ; 'DataType', 'N(4,2)')
You can also include the NOCPTRANS clause to prevent translation of character and memo fields to a different code page. 
Read/write for remote views.
KeyField
Contains True (.T.) if the field is specified in an index key expression; otherwise, contains False (.F.).
Updatable
Contains True (.T.) if the field can be updated; otherwise, contains False (.F.).
UpdateName
The name of the field used when data in the field is updated to the remote table. By default, the remote table field name.
<b>Table properties</b>
The text of the table comment.
DeleteTrigger
The Delete trigger expression.
InsertTrigger
The Insert trigger expression.
The relative path with respect to the DBC to the table including the name of the file.
PrimaryKey
The tag name of the primary key.
The row rule expression.
The row rule error text.
UpdateTrigger
The Update trigger expression.
<b>View properties</b>
AllowSimultaneousFetch
Applies when using remote views, a shared connection, and to cursors created using ODBC. 
AllowSimultaneousFetch contains True (.T.) when similarly configured cursors sharing the connection are permitted to fetch rows simultaneously. 
Otherwise, AllowSimultaneousFetch contains False (.F.) when fetching rows simultaneously is not permitted.
This property is available in X# 8.0 and later. Views created in X# 8.0 and later are not compatible with earlier versions. Calling the <b>VALIDATE DATABASE</b> command in a version prior to X# 8.0 on a database container with remote views created or modified in X# 8.0 and later generate an error. Calling the codeVALIDATE DATABASE RECOVER/code in a version prior to X# 8.0 removes the <b>AllowSimultaneousFetch</b> property from any such views.
BatchUpdateCount
The number of update statements sent to the back end for views. 1 is the default. Adjusting this value can greatly increase update performance.
The text of the view comment.
CompareMemo
Contains true (.T.) (default) if memo fields (of type Memo, General, or Picture, or, for remote views, type Timestamp) are included in the WHERE clause for updates; otherwise, contains false (.F.).
ConnectName
The named connection used when the view is opened.
FetchAsNeeded
If True (.T.), data is fetched only when needed, such as when record pointer moves to a row that has not been fetched.
If False (.F.), additional data is fetched during idle time. (Default)
FetchAsNeeded does not apply when progressive fetching is disabled (FetchSize is -1).
FetchMemo
Contains true (.T.) (default) if memo and general fields are fetched with the view results; otherwise, contains false (.F.).
Use the ISMEMOFETCHED( ) Function to determine if the memo field has been fetched.
Contains the number of records fetched at a time from the remote tables. The default is 100 records. Setting FetchSize to –1 retrieves the complete result set, limited by the MaxRecords setting.
Progressive fetching holds the connection until all rows are retrieved. Use caution coding with FetchSize if ShareConnection is True (.T.).
The maximum number of records fetched when result sets are returned. The default is – 1 (all rows are returned). A value of 0 specifies that the view is executed but no results are fetched.
Offline
Contains true (.T.) if the view is an offline view. 
ParameterList
The WHERE clause parameters. The format for the parameters is ''ParameterName1, 'Type1'; ParameterName2, 'Type2'; ...'' where Type is a one of the following characters specifying the parameter type:
C – Character  D – Date  T – DateTime  N – Numeric  F – Floating  B – Double  I – Integer  Y – Currency  L - Logical
For example, ''MyParam1, 'C' '' specifies a single character type parameter named MyParam1.
For more information about creating parameterized views, see How to: Create Parameterized Views.
Prepared
Contains True (.T.) if SQL statements are prepared for subsequent <b>REQUERY( )</b> function calls. <b>REQUERY( )</b> is used to retrieve data again for a SQL view. See SQLPREPARE( ) for additional information about preparing SQL statements. The default is false (.F.).
The rule text expression displayed when an error occurs when data is edited in a Browse or Edit window.
SendUpdates
Contains true (.T.) if a SQL update query is sent to update remote tables; otherwise, contains false (.F.) (default).
Contains true (.T.) if the view can share its connection handle with other connections; otherwise, contains false (.F.).
SourceType
The view source. SourceType may assume the following values: 1 - The view uses local tables.
2 - The view uses remote tables.
The SQL statement executed when the view is opened.
Tables
A comma-delimited list of the names of the tables.
UpdateType
The update type. Valid values are: 1 or DB_UPDATE (from Foxpro.h). The old data is updated with the new data (default).
2 or DB_DELETEINSERT (from Foxpro.h). The old data is deleted and the new data is inserted.
UseMemoSize
The minimum size (in bytes) for which result columns are returned in memo fields. For example, if the width of a column result is greater than the value of UseMemoSize, the column result is stored in a memo field. UseMemoSize may vary from 1 to 255; the default value is 255.
WhereType
The WHERE clause for updates to remote tables. WhereType may assume the following values: 1 or DB_KEY (from Foxpro.h). The WHERE clause used to update remote tables consists of only the primary fields specified with the <b>KeyFieldList</b> property.
2 or DB_KEYANDUPDATABLE (from Foxpro.h). The WHERE clause used to update remote tables consists of the primary fields specified with the <b>KeyFieldList</b> property and any updatable fields.
3 or DB_KEYANDMODIFIED (from Foxpro.h) (default). The WHERE clause used to update remote tables consists of the primary fields specified with the <b>KeyFieldList</b> property and any other fields that are modified.
4 or DB_KEYANDTIMESTAMP (from Foxpro.h). The WHERE clause used to update remote tables consists of the primary fields specified with the <b>KeyFieldList</b> property and a comparison of the time stamps.
For more information about the <b>WhereType</b> property, see Managing Updates by Using Views.
</param>
<returns>
Character, Numeric, or Logical data type. <b>DBGETPROP( )</b> returns the value for the specified property.
</returns>
<remarks>
For more information about setting property values, see DBSETPROP( ) Function.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
OPEN DATABASE (HOME(2) + 'Data\testdata')
* Displays the primary key field
cResults = DBGETPROP("customer", "Table", "PrimaryKey")
=MESSAGEBOX(cResults)   &amp;&amp; Displays    'cust_id'
* Displays comments for the field 'cust_id'
cResults = DBGETPROP("customer.cust_id", "Field", "Comment")
IF LEN(ALLTRIM(cResults)) = 0
=MESSAGEBOX("No Comment for this field." + CHR(13) + ;
CHR (13) + "Use DBSETPROP( ) to add comments.")
ELSE
=MESSAGEBOX("Cust_id field comments: " + cRESULTS)
ENDIF</code>
</example>
</dbgetprop>
<dbsetprop>
<summary>
Sets a property for the current database or for fields, named connections, tables, or views in the current database.
</summary>
<param name="cName">

Specifies the name of the current open database or the field, named connection, table, or view in the current open database for which <b>DBGETPROP( )</b> returns information.
To set a property for a field in a table or a view, preface the name of the field with the name of the table or view containing the field. For example, to set a property for the codecustid/code field in the codecustomer/code table, specify the following for cName:   
 <code language="X#">customer.custid</code>

</param>
<param name="cType">

Specifies whether cName is the current database or for a field, named connection, table, or view in the current database.
The following table lists the values you can specify for cType:   
CONNECTION
cName is a named connection in the current database.
DATABASE
cName is the current database.
FIELD
cName is a field in the current database.
TABLE
cName is a table in the current database.
VIEW
cName is a view in the current database.

</param>
<param name="cProperty">

Specifies the name of the property to set. If a property is read-only, its value cannot be changed with <b>DBSETPROP( )</b>. If you attempt to set a property that is read-only, X# generates an error message.
For more information on properties you can specify with cProperty, including their data types, see DBGETPROP( ). 

</param>
<param name="ePropertyValue">

Specifies the value to which cProperty is set. ePropertyValue must be the same data type as the property's data type.
X# does not verify that the value you specify is valid for the property. Thus, it is possible to set a property to an invalid value with <b>DBSETPROP( )</b>. For example, <b>DBSETPROP( )</b> can be used to set a field rule expression to an expression that is not valid for the field, and X# will not generate an error. To avoid an error when setting the Tables property of a view, precede ePropertyValue with the database designation in the following syntax:
 <code language="X#">         &lt;databaseName&gt;!ePropertyValue</code>
</param>
<returns>
Logical data type. <b>DBSETPROP( )</b> returns True (.T.) if X# successfully sets the property you specify. X# generates an error if the property you specify cannot be set.
</returns>
<remarks>
For more information about retrieving current property values, see DBGETPROP( ) Function.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer     &amp;&amp; Open customer table
= DBSETPROP("customer.cust_id", "Field", "Comment", ;
"Property has been set by DBSETPROP.")  &amp;&amp; New field comments
cRESULTS = DBGETPROP("customer.cust_id", "Field", "Comment")
WAIT WINDOW "Cust_id field comments: "+ cRESULTS  &amp;&amp; Display comments</code>
</example>
</dbsetprop>
<dbused>
<summary>
Returns true (.T.) if the specified database is open.
</summary>
<param name="cDatabaseName">

Specifies the name of the database for which <b>DBUSED( )</b> returns a logical value indicating whether or not the database is open.
</param>
<returns>
Logical
</returns>
<remarks>

<b>DBUSED( ) </b>returns true (.T.) if the specified database is open; otherwise, it returns false (.F.).
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
CLEAR
? 'Testdata database open? '
?? DBUSED('testdata')     &amp;&amp; Displays .T.
? 'Test database open? '
?? DBUSED('test')     &amp;&amp; Displays .F.</code>
</example>
</dbused>
<ddeaborttrans>
<summary>
Ends an asynchronous dynamic data exchange (DDE) transaction.
</summary>
<param name="nTransactionNumber">

Specifies the transaction number returned by <b>DDEExecute( )</b>, <b>DDEPoke( )</b>, or <b>DDERequest( )</b> when the transaction is sent to the server application.
</param>
<returns>
Logical
</returns>
<remarks>
An asynchronous transaction allows X# program execution to continue without waiting for the server application to respond to a data request.

<b>DDEExecute( )</b>, <b>DDEPoke( )</b>, and <b>DDERequest( )</b> wait for the period specified by <b>DDESetOption( )</b> for a server application to respond, unless you specify a user-defined function to execute when the server application responds. Specifying a user-defined function to execute in these functions creates an asynchronous transaction.
If <b>DDEAbortTrans( )</b> is called before the server has processed the request, the user-defined function will not be called for the transaction.

<b>DDEAbortTrans( )</b> returns true (.T.) if the asynchronous transaction is successfully ended and returns false (.F.) if the asynchronous transaction cannot be ended. Use <b>DDELastError( )</b> to determine why the transaction could not be ended.
</remarks>
</ddeaborttrans>
<ddeadvise>
<summary>
Creates a notify link or an automatic link used in a dynamic data exchange (DDE).
</summary>
<param name="nChannelNumber">

Specifies the channel number.

</param>
<param name="cItemName">

Specifies the item name. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet. The item name R1C1 designates the cell in the first row and first column of the worksheet.

</param>
<param name="cUDFName">

Specifies the user-defined function that is executed when a notify link or an automatic link is established and the item cItemName is modified. When the user-defined function is executed, it is passed the following six parameters in the order given below:
Channel Number
The channel number of the server application.
Action
ADVISE or TERMINATE.
The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
Data
The new data (automatic link) or the empty string (notify link).
Format
The data format; for example, CF_TEXT.
Advise Status
The link type (0 = manual, 1 = notify, 2 = automatic).
The user-defined function should have six parameters in its LPARAMETER or PARAMETER statement to accept the values passed from the server application. If a notify link is established, the user-defined function is executed and the empty string is passed in the Data parameter. You can issue <b>DDERequest( )</b> later to retrieve the data. If an automatic link is established, the user-defined function is executed and the data is passed in the Data parameter.   
The Action parameter contains ADVISE when the link is being updated by the server. The user-defined function is called, and the Action parameter contains TERMINATE when the link is closed by the client or server.   
Any value returned by the user-defined function is ignored. 

</param>
<param name="nLinkType">

Specifies the link type in the following way:
0
Manual
1
Notify
2
Automatic
You can turn off notification from the server application by specifying 0 for nLinkType. If the item changes, the user-defined function is not executed.
</param>
<returns>
Logical
</returns>
<remarks>

<b>DDEAdvise( )</b> is used to create a notify link or an automatic link to an item name in a server application. When a notify link is created with <b>DDEAdvise( )</b>, the server application notifies X# that the item name has been modified. If an automatic link is created, the server application notifies X# that the item name has been modified and passes the new data to X#.
Before you can create a link, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
You can also use <b>DDEAdvise( )</b> to turn off notification from the server.
DDEAdvise( ) returns a true value (.T.) if it executes successfully; otherwise, it returns false (.F.).
</remarks>
<example>
 <code language="X#">PUBLIC mchannum
mchannum = DDEInitiate('Excel', 'Sheet1')
IF mchannum != -1
= DDEAdvise(mchannum, 'R1C1', 'newdata', 1)     &amp;&amp; Notify link
= DDEAdvise(mchannum, 'R1C2', 'newdata', 2)     &amp;&amp; Automatic link
WAIT WINDOW 'Enter data in first two cells in Excel.'
ENDIF
PROCEDURE newdata
PARAMETERS channel, action, item, data, format, advise
IF action = 'ADVISE'
DO CASE
CASE item = 'R1C1'   &amp;&amp; Notify link
newvalue = DDERequest(channel, item)
? 'R1C1 notify link: ' + newvalue
CASE item = 'R1C2'   &amp;&amp; Automatic link
newvalue = data
? 'R1C2 automatic link: ' + newvalue
ENDCASE
ELSE
IF action != "TERMINATE"
= DDETerminate(mchannum)
ENDIF
ENDIF</code>
</example>
</ddeadvise>
<ddeenabled>
<summary>
Enables or disables dynamic data exchange (DDE) processing or returns the status of DDE processing.
</summary>
<param name="lExpression1">

Specify true (.T.) or false (.F.) to globally enable or disable DDE processing. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is successfully enabled or disabled; otherwise false (.F.) is returned.

</param>
<param name="nChannelNumber">

Specifies the channel number for the channel whose DDE processing status <b>DDEEnabled( )</b> returns. <b>DDEEnabled( )</b> returns true (.T.) if DDE processing is enabled for the specified channel and returns false (.F.) if DDE processing is disabled.

</param>
<param name="lExpression2">

To enable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify true (.T.) for lExpression2. To disable DDE processing for a specific channel, include the channel number (nChannelNumber) and specify false (.F.) for lExpression2.
</param>
<returns>
Logical
</returns>
<remarks>
Using <b>DDEEnabled( )</b>, you can globally enable or disable processing. You can also enable or disable DDE processing for specific channels.

<b>DDEEnabled( )</b> can be used to protect critical code or disable links for short periods. When DDE processing is disabled, client requests are queued until DDE processing is enabled.
If <b>DDEEnabled( )</b> is issued without any of its optional arguments, the global DDE processing status is returned. <b>DDEEnabled( </b>) returns true (.T.) if DDE processing has been globally enabled and false (.F.) if DDE processing has been globally disabled.
</remarks>
</ddeenabled>
<ddeexecute>
<summary>
Sends a command to another application, using dynamic data exchange (DDE).
</summary>
<param name="nChannelNumber">

Specifies the channel number.

</param>
<param name="cCommand">

Specifies the command you want to send to the other application. The format of the command is determined by the application you are sending it to. Consult the application's documentation for the correct syntax.

</param>
<param name="cUDFName">

Allows asynchronous command execution requests. If you omit cUDFName, a client application waits for the period specified with <b>DDESetOption( )</b>. If you specify a user-defined function with cUDFName, client program execution continues immediately after the command execution request is made.
When the server application finishes executing the command, the user-defined function you specify with cUDFName is executed. The user-defined function is passed six parameters in the order shown in the following table.   
Channel Number
The channel number of the server application.
Action
XACTCOMPLETE (successful execution).XACTFAIL (failed command execution).
Item
The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
Data
The new data (REQUEST) or data passed (POKE or EXECUTED).
Format
The data format; for example, CF_TEXT.
Transaction Number
The transaction number returned by DDEExecute( ).
Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.   
When you include cUDFName, <b>DDEExecute( )</b> does not return a logical value. Instead, a transaction number is returned; if an error occurs, –1 is returned.
</param>
<returns>
Logical
</returns>
<remarks>
The command sent with <b>DDEExecute( )</b> must be understood by the application. Before you can execute the command, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
For example, Microsoft Excel has an extensive set of macro commands, including DDE commands that let you request data from X# from within Microsoft Excel. If you establish a channel to Microsoft Excel, you can then use <b>DDEExecute( )</b> to send macro commands to Excel from within X#.
If the receiving application successfully executes the command, <b>DDEExecute( )</b> returns true (.T.). If the receiving application cannot successfully execute the command or if the channel number you include is not valid, <b>DDEExecute( )</b> returns false (.F.). If the optional asynchronous user-defined function cUDFName is included, a transaction number is returned. If an error occurs, DDEExecute( ) returns –1.
</remarks>
<example>
 <code language="X#">gnChanNum = DDEInitiate('Excel', 'Sheet1')
IF gnChanNum != -1
glExecute = DDEExecute(gnChanNum, '[App.Maximize]')
IF glExecute != .F.
WAIT WINDOW 'EXCEL window has been zoomed out.'
ENDIF
= DDETerminate(gnChanNum)   &amp;&amp; Close the channel
ENDIF</code>
</example>
</ddeexecute>
<ddeinitiate>
<summary>
Establishes a dynamic data exchange (DDE) channel between X# and another Microsoft Windows-based application.
</summary>
<param name="cServiceName">

Specifies the service name of the server application, which, in most cases, is the name of the executable file without its extension. The default service name for X# is X#. If you are establishing a channel to Microsoft Excel, cServiceName is Excel.

</param>
<param name="cTopicName">

Specifies the topic name. The topic is application-specific and must be understood by the application. For example, one topic supplied by most DDE servers is the System topic. See the application documentation for the service and topic names supported by the application.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>DDEInitiate( ) </b>establishes a DDE channel between X# and a DDE server application. Once a channel is established, X# can request data from the server by referring to the channel in subsequent DDE functions. X# acts as the client, requesting data from the server application through the channel.
If the channel is successfully established, <b>DDEInitiate( )</b> returns the channel number. Channel numbers are non-negative, and the number of channels you can establish is limited only by your system resources.

<b>DDEInitiate( )</b> returns –1 if the channel cannot be established. If the server application is not open, X# asks if you would like to open it. If you choose Yes, X# attempts to open the application. (You can use <b>DDELastError( )</b> to determine why a channel cannot be established.)
To avoid being asked whether you want to open the application, set the <b>DDESetOption( )</b> SAFETY option. You can also use RUN with the /N option to start the application.
A channel can be closed with <b>DDETerminate( )</b>.
</remarks>
<example>
 <code language="X#">mchannum = DDEInitiate('Excel', 'Sheet1')
IF mchannum != -1
* Process client actions
= DDETerminate(mchannum)  &amp;&amp; Close the channel
ENDIF</code>
</example>
</ddeinitiate>
<ddelasterror>
<summary>
Returns an error number for the last dynamic data exchange (DDE) function.
</summary>
<returns>
DDELastError( )Return Value
Numeric
</returns>
<remarks>
You can use <b>DDELastError( )</b> to help determine the cause of an error when a DDE function does not execute successfully.

<b>DDELastError( )</b> returns 0 if the last DDE function executed successfully. It returns a nonzero value if the last DDE function was unsuccessful. The following table lists the error numbers and their descriptions.
1
Service busy
2
Topic busy 
3
Channel busy
4
No such service
5
No such topic
6
Bad channel
7
Insufficient memory
8
Acknowledge timeout
9
Request timeout
10
No DDEInitiate( )
11
Client attempted server transaction
12
Execute timeout
13
Bad parameter
14
Low memory 
15
Memory error
16
Connect failure
17
Request failure
18
Poke timeout
19
Could not display message
20
Multiple synchronous transactions 
21
Server died
22
Internal DDE error
23
Advise timeout
24
Invalid transaction identifier
25
Unknown
</remarks>
</ddelasterror>
<ddepoke>
<summary>
Sends data between client and server applications in a dynamic data exchange (DDE) conversation.
</summary>
<param name="nChannelNumber">

Specifies the channel number of the application data is sent to. If the channel number is a server channel, <b>DDEPoke( )</b> sends the data in response to a request or a previously established notify or automatic link.

</param>
<param name="cItemName">

Specifies the item name to which data is sent. The item name is application-specific and must be understood by the application. For example, Microsoft Excel supports R1C1 as a valid item name that refers to the first cell in a worksheet.

</param>
<param name="cDataSent">

Specifies the data sent to the item name specified with cItemName.

</param>
<param name="cDataFormat">

Specifies the format used to send the data. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a linefeed.

</param>
<param name="cUDFName">

Allows asynchronous data transfer. If cUDFName is omitted, a client waits for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, client program execution continues immediately after the request is made.
When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:   
Channel Number
The channel number of the server application.
Action
XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
Item
The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
Data
The new data (REQUEST) or data passed (POKE or EXECUTED).
Format
The data format; for example, CF_TEXT.
Transaction Number
The transaction number returned by <b>DDEPoke( )</b>.
Use DDEAbortTrans( ) to cancel an uncompleted transaction. If the transaction fails, you can use DDELastError( ) to determine why it failed.   
When you include cUDFName, DDEPoke( ) returns a transaction number if successful or –1 if an error occurs.
</param>
<returns>
Logical
</returns>
<remarks>

<b>DDEPoke( )</b> sends data as a character string to the item name in the application specified by the channel number.
If the data is successfully sent, <b>DDEPoke( )</b> returns true (.T.). If the data cannot be sent, <b>DDEPoke( )</b> returns false (.F.). If the asynchronous user-defined function cUDFName is included, <b>DDEPoke( )</b> returns a transaction number; if an error occurs, <b>DDEPoke( )</b> returns –1.
</remarks>
</ddepoke>
<dderequest>
<summary>
Requests data from a server application in a dynamic data exchange (DDE) conversation.
</summary>
<param name="nChannelNumber">

Specifies the channel number of the server application.

</param>
<param name="cItemName">

Specifies the item name. The item name is application-specific and must be understood by the application. For example, Microsoft Excel uses row and column notation to refer to cells in a worksheet. The item name R1C1 designates the cell in the first row and first column of the worksheet.

</param>
<param name="cDataFormat">

Specifies a format for the data requested. The default format is CF_TEXT. In this format, fields are delimited with tabs and records are delimited with a carriage return and a line feed.

</param>
<param name="cUDFName">

Allows an asynchronous data transfer. If you omit cUDFName, X# waits for the data from the server for the period specified with <b>DDESetOption( )</b>. If you specify the name of a user-defined function with cUDFName, X# continues program execution immediately after the request is made.
When the data is available from the server application, the user-defined function specified with cUDFName is executed. The user-defined function is passed six parameters in this order:   
Channel Number
The channel number of the server application.
Action
XACTCOMPLETE (successful transaction).XACTFAIL (failed transaction).
Item
The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
Data
The new data (REQUEST) or data passed (POKE or EXECUTED).
Format
The data format; for example, CF_TEXT.
Transaction Number
The transaction number returned by <b>DDERequest( )</b>.
Use <b>DDEAbortTrans( )</b> to cancel an uncompleted transaction. If the transaction fails, you can use <b>DDELastError( )</b> to determine why it failed.   
When you include cUDFName, <b>DDERequest( )</b> returns a transaction number equal to or greater than 0 if successful, or –1 if an error occurs.
</param>
<returns>
Character
</returns>
<remarks>
Before you can request data using <b>DDERequest( )</b>, you must establish a channel to the server application with <b>DDEInitiate( )</b>.
If the request for data is successful, <b>DDERequest( )</b> returns the data as a character string. If the request fails, <b>DDERequest( )</b> returns an empty string and <b>DDELastError( )</b> returns a nonzero value. If you include the asynchronous user-defined function cUDFName, DDERequest( ) returns a transaction number if successful, or –1 if an error occurs.
</remarks>
<example>
 <code language="X#">mchannum = DDEInitiate('Excel', 'Sheet1')
IF mchannum != -1
mrequest = DDERequest(mchannum, 'R1C1')
IF !EMPTY(mrequest) AND DDELastError( ) = 0      &amp;&amp; Successful
WAIT WINDOW 'R1C1 contents: ' + mrequest
ENDIF
= DDETerminate(mchannum)            &amp;&amp; Close the channel
ENDIF</code>
</example>
</dderequest>
<ddesetoption>
<summary>
Changes or returns dynamic data exchange (DDE) settings.
</summary>
<param name="cOption">

Specifies the setting options.
TIMEOUT
nTimeoutValue (number of milliseconds)
2000
The number of milliseconds DDE functions wait for the server application to respond; the current TIMEOUT value is returned if you omit nTimeoutValue.
SAFETY
lExpression(true (.T.) or false (.F.))
Specifies whether a dialog is displayed when you use <b>DDEInitiate( )</b> to establish a channel to a server application and the application does not respond; the current SAFETY setting is returned if you omit lExpression.

</param>
<param name="nTimeoutValue">

Specifies the timeout value.

</param>
<param name="lExpression">

Enables or disables dialog display.
</param>
<returns>
Logical or Numeric
</returns>
<remarks>
Use <b>DDESetOption( )</b> to change or return DDE settings. Two options, TIMEOUT and SAFETY, are available.
</remarks>
</ddesetoption>
<ddesetservice>
<summary>
Creates, releases, or modifies DDE service names and settings.
</summary>
<param name="cServiceName">

Specifies the service name to create, release, modify, or return information about.

</param>
<param name="cOption">

Specifies to create, release, or modify a service name or to return information about a service name. The following table lists the options you can specify with cOption, the default values for the options and a description of each option.
DEFINE
–
Creates a new service name.
RELEASE
Releases an existing service name.
ADVISE
.F.
Enables or disables client notification of changes to item names.
EXECUTE
Enables or disables command execution.
POKE
Enables or disables client pokes to the service.
REQUEST
.T.
Enables or disables requests to the service name.
FORMATS
CF_TEXT
Specifies supported data formats.
DEFINE 
Creates a new service name. For example, the following command creates the service name codemyservice/code:  
 <code language="X#">glNewService = DDESetService('myservice', 'DEFINE')</code>
RELEASE 
Releases an existing service name to free up system resources. When a service name is released, all of the service's topic names are also released.
The following command releases the service name created in the previous example:   
 <code language="X#">glRelease = DDESetService('myservice', 'RELEASE')</code>
To release the default X# service, issue this command:   
 <code language="X#">glRelFox = DDESetService('FoxPro', 'RELEASE')</code>
ADVISE 
Specifies whether a client is notified when data changes in an item name or specifies to return the current advise status for a service name. Refer to <b>DDEAdvise( )</b> for additional information about advising clients.
To enable client notification, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client notification.   
To return the current client notification status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client notification is enabled for the service name; it returns false if client notification is disabled. 
EXECUTE 
Allows you to enable or disable command execution requests to a service name or to determine the current execute status for a service name.
To enable client requests to execute a command, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client requests to execute a command. .F. is the default value.   
To return the current command execution status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if client command execution requests are enabled for the service name; otherwise, it returns false.   
The following commands enable command execution and disable data requests from client applications for the service name codemyservice/code. The current command execution status for codemyservice/code is then displayed:   
 <code language="X#">glExecute = DDESetService('myservice', 'EXECUTE', .T.)
glRequest = DDESetService('myservice', 'REQUEST', .F.)
? DDESetService('myservice', 'EXECUTE')</code>
POKE 
Allows you to enable or disable poke requests to the service name. You can also determine the current poke status for a service name. Refer to <b>DDEPoke( )</b> for additional information about poking data to a server or a client.
To enable client poke requests, specify true (.T.) for lExpression. Specifying false (.F.) for lExpression disables client poke requests. .F. is the default value.   
To return the current poke status for the service name, omit lExpression. <b>DDESetService( )</b> returns true if poke requests are enabled for a service name; it returns false if poke requests are disabled. 
REQUEST 
Use REQUEST to enable or disable client requests to a service name or to return the current request status for the service name.
To enable client requests to the service name, specify true (.T.) for lExpression. Specifying false (.F.) disables client requests to the service name. True (.T.) is the default value.   
To return the current request status for a service name, omit lExpression. <b>DDESetService( )</b> returns true if client requests are enabled for the service name; it returns false if client requests are disabled.   
The following commands disable requests from client applications to the service name codemyservice/code and display the current request status for codemyservice/code:   
 <code language="X#">glRequest = DDESetService('myservice', 'REQUEST', .F.)
? DDESetService('myservice', 'REQUEST')</code>
FORMATS [ cDataFormat] 
Specifies the data formats supported by the service name. Server requests for formats not specified with cDataFormat are rejected. When specifying data formats, include a list of the supported formats separated by commas. For example:  
 <code language="X#">=DDESetService('myservice', 'FORMATS', 'CF_TEXT, CF_SYLK')</code>
If you omit cDataFormat, only the CF_TEXT format is supported.
</param>
<param name="lExpression">

Specifies the state of the REQUEST, EXECUTE, POKE, or ADVISE options. Specify true (.T.) for lExpression to enable the option or false (.F.) to disable it.
</param>
<returns>
Logical
</returns>
<remarks>
X# can act as a dynamic data exchange (DDE) server to send data to client Microsoft Windows-based applications. <b>DDESetService( )</b> is used to create, release, or modify service names and settings in X#. Each service name can have a set of topic names created with <b>DDESetTopic( )</b>. Client applications request data from DDE topic names.

<b>DDESetService( )</b> returns true (.T.) if the service name is successfully created, released, or modified. If the service name cannot be created, released, or modified, <b>DDESetService( )</b> returns false (.F.).

<b>DDESetService( )</b> can also be used to return information about a service name. X# has the default service name FoxPro. The X# service name has one topic name called System. The following table lists all the item names supported by the System topic.
Topics
A list of available topic names
Formats
A list of supported formats
Status
Busy or Ready
SysItems
A list of item names
You can use DDESetTopic( ) to modify the FoxPro service name or to release it. For information about manipulating X# service names, see the DDESetTopic( ) options.
</remarks>
</ddesetservice>
<ddesettopic>
<summary>
Creates or releases a topic name from a service name in a dynamic data exchange (DDE) conversation.
</summary>
<param name="cServiceName">

Specifies the service name. Additional service names can be created with DDESetService( ).

</param>
<param name="cTopicName">

Specifies the topic name to create or release. If you include cUDFName, <b>DDESetTopic( )</b> creates the topic name cTopicName. If you omit cUDFName, the topic name cTopicName is released. If cTopicName is an empty string, the user-defined function specified with cUDFName is executed for any topic name that is not explicitly declared.

</param>
<param name="cUDFName">

Specifies the name of the user-defined function executed when a client application makes a request to the topic name. If you omit cUDFName, the topic name cTopicName is released from the service name.
When the user-defined function is executed, it is passed the following six parameters in the order given below:   
Channel Number
The client channel number.
Action
ADVISE, EXECUTE, INITIATE, POKE, REQUEST, or TERMINATE.
Item
The item name; for example, R1C1 for a Microsoft Excel worksheet cell.
Data
Data from the client.
Format
The data format; for example, CF_TEXT.
Advise Status
The link type (0 = manual, 2 = notify or automatic).
The values of the Item, Data, and Advise Status parameters depend on the Action parameter. The following table lists the Action parameter values and the values contained in the Item, Data, and Advise Status parameters. A dash (–) indicates that the parameter value is the empty string.   
Topic name
Item name
New data
New command
Link type
If the user-defined function successfully handles the client request, the user-defined function should return true (.T.). If the request cannot be handled or an error occurs, the user-defined function should return false (.F.). If false is returned when the Action parameter value is INITIATE, the client topic name request is rejected. If false is returned when the value is POKE, REQUEST, or EXECUTE, the request is ignored. If false is returned when the value is ADVISE, the client request for a notify or automatic link is rejected.
</param>
<returns>
Logical
</returns>
<remarks>
After a topic name is created, any client requests to the topic name cause X# to execute the user-defined function specified with cUDFName. The user-defined function is passed a set of parameters whose values are determined by the client request. The user-defined function return value is passed to the client with DDEPoke( ). The return value is a logical value indicating whether the topic name can provide the service requested by the client.

<b>DDESetTopic( )</b> returns true (.T.) if it successfully creates or releases the topic name. It returns false (.F.) if the topic name cannot be created or released. Use DDELastError( ) to determine why a topic name cannot be created or released.
</remarks>
<example>
The following example creates a basic sample server called codemyserver/code that supports X# command execution from a client application. The client application makes requests to codemyserver/code through the DO topic, and macro substitution is used to execute the client's command.
 <code language="X#">*** Set X# up as a DDE server ***
= DDESetService('myserver', 'DEFINE')
= DDESetService('myserver', 'EXECUTE', .T.)
= DDESetTopic('myserver', 'DO', 'DOTOPIC')
WAIT WINDOW 'Server portion service setup ... ' NOWAIT
*** Use X# as a DDE client ***
gnChannel = DDEInitiate('myserver','DO')
=DDEExecute(gnChannel, 'WAIT WINDOW "Command Executed ... "')
=DDETerminate(gnChannel)
PROCEDURE dotopic
PARAMETERS gnChannel, gcAction, gcItem, gData, gcFormat, gnAdvise
glResult = .F.
*** It's necessary to return .T. from an   ***
*** INITIATE action or no connection is made ***
IF gcAction = 'INITIATE'
glResult = .T.
ENDIF
IF gcAction = 'EXECUTE'
&amp;gData
glResult = .T.
ENDIF
IF gcAction = 'TERMINATE'
WAIT WINDOW 'Goodbye ... ' NOWAIT
glResult = .T.
ENDIF
RETURN glResult</code>
After running this example program, you have set up X# service, which other applications can access. If you have Microsoft Excel, you can run the following Excel macro:
 <code language="X#">gnMyChan = INITIATE("myserver","DO")
=EXECUTE(MyChan,"WAIT WINDOW 'Hi, this is EXCEL speaking'")
=RETURN( )</code>
</example>
</ddesettopic>
<ddeterminate>
<summary>
Closes a dynamic data exchange (DDE) channel established with <b>DDEInitiate( )</b>.
</summary>
<param name="nChannelNumber">

Specifies the channel number to close.

</param>
<param name="cServiceName">

Specifies the service name to close.
</param>
<returns>
Logical
</returns>
<remarks>
If the channel is successfully closed, <b>DDETerminate( )</b> returns true (.T.). If the channel cannot be closed, <b>DDETerminate( )</b> returns false (.F.).
Be sure to close channels as soon as they are no longer needed to conserve system resources.
All channels are automatically closed if you exit X# by choosing Exit from the File menu or by issuing QUIT in the Command window or from within a program.
</remarks>
</ddeterminate>
<defaultext>
<summary>
Returns a file name with a new extension if one does not already exist.
</summary>
<param name="cFileName">

 Specifies the filename (with or without a path or extension) to be returned.

</param>
<param name="cDefault">

 Specifies the default extension without a period.
</param>
<returns>
Character
</returns>
</defaultext>
<deleted>
<summary>
Returns a logical value that indicates whether the current record is marked for deletion.
</summary>
<returns>
Logical
</returns>
<remarks>
If the record is marked for deletion, DELETED( ) returns true (.T.); otherwise, DELETED( ) returns false (.F.).
Records can be marked for deletion with DELETE and DELETE – SQL, and they can be unmarked with RECALL.
Rushmore Query Optimization optimizes queries that test the deleted status of records if the table is indexed on DELETED( ).
For information on using Rushmore to optimize queries, see SET OPTIMIZE and Using Rushmore Query Optimization to Speed Data Access.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
DELETE FROM customer WHERE country = 'USA'  &amp;&amp; Mark for deletion
CLEAR
LIST FIELDS company, country FOR DELETED( ) &amp;&amp; List marked records
RECALL ALL  &amp;&amp; Unmark all records marked for deletion</code>
</example>
</deleted>
<descending>
<summary>
Returns a logical value that indicates whether an index tag was created with the DESCENDING keyword or whether the DESCENDING keyword was included in USE, SET INDEX, or SET ORDER.
</summary>
<param name="uIndex">

  Specifies the name or index number of a compound index file with CDXFileName. The compound index file you specify can be the structural compound index file automatically opened with the table or an independent compound index file.
  Specifies which index tag or index file DESCENDING( ) tests. nIndexNumber is typically an integer that starts at 1 and is increased by 1 to return additional values for each index tag.
  If nIndexNumber is 1, a value for the master single-entry .idx index file or master index tag (if one is present) is returned.
  As nIndexNumber increases, values for each tag in the structural compound index (if one is present) are returned. The values are returned for the tags in the order in which the tags were created in the structural compound index.
  After values for all the tags in the structural compound index are returned, values for each tag in any open independent compound indexes are then returned. The values are returned from the tags in the order in which the tags are created in the independent compound indexes.
  The empty string is returned if nIndexNumber is greater than the total number of open, single-entry .idx files and structural compound and independent compound index tags.

</param>
<param name="uArea">
Returns values for index files or tags open in a work area other than the current work area. This specifies the work area number or table alias.
If no table has the alias you specify, X# generates an error message.
</param>
<returns>
Logical
</returns>
<remarks>
You can order records in a table in descending order in two ways:  
You can include the DESCENDING keyword in the INDEX command to create a descending order index tag in a compound .cdx.
You can include the DESCENDING keyword in USE, SET INDEX or SET ORDER to specify a descending order for the master index tag or the master single-entry index (.idx) file.
DESCENDING( ) can determine if an index tag was created in descending order. DESCENDING( ) returns true (.T.) if the index tag you specify was created with the DESCENDING keyword.
DESCENDING( ) can also determine if the master index tag or master index file is in descending order. DESCENDING( ) returns true (.T.) if the DESCENDING keyword was included in USE, SET INDEX, or SET ORDER for the master index tag or a single-entry index (.idx) file you specify.
If you don't include any of the optional arguments, DESCENDING( ) returns a value for the master index tag or master index file. If you don't include any of the optional arguments and a master index tag or .idx file isn't in effect (for example, you've issued SET ORDER TO to place the table in physical record order), DESCENDING( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer     &amp;&amp; Open customer table
CLEAR
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
? TAG(nCount) + ' Descending? ' &amp;&amp; Display tag name
?? DESCENDING(nCount)  &amp;&amp; Display descending status
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found
ENDIF
ENDFOR</code>
</example>
</descending>
<difference>
<summary>
Returns an integer, 0 through 4, which represents the relative phonetic difference between two character expressions.
</summary>
<returns>
Numeric
</returns>
<remarks>
DIFFERENCE( ) is useful for searching tables when the exact spelling of an entry isn't known.
The more alike the two expressions are spelled, the higher the number DIFFERENCE( ) returns. If the character expressions are spelled very similarly, DIFFERENCE( ) returns 4. For two character expressions with little in common phonetically, DIFFERENCE( ) returns 0.
</remarks>
<example>
 <code language="X#">STORE 'Smith' TO gcName1
STORE 'Smythe'  TO gcName2
STORE 'Smittie' TO gcName3
STORE '' TO gcName4
CLEAR
? DIFFERENCE(gcName1, gcName2)  &amp;&amp; Displays 4
? DIFFERENCE(gcName1, gcName3)  &amp;&amp; Displays 4
? DIFFERENCE(gcName1, gcName4)  &amp;&amp; Displays 1</code>
</example>
</difference>
<directory>
<summary>
Locates the specified directory. 
</summary>
<param name="cDirectoryName">

Specifies the name of the directory to locate. If you do not include an absolute path for the directory you specify, X# searches for the directory relative to the X# default directory.

</param>
<param name="nFlags">

Specifies the kind of value <b>DIRECTORY( )</b> returns when the directory exists but might be marked with the <b>Hidden</b> or <b>System</b> attribute. The following table lists the values for nFlags.
0
<b>DIRECTORY( )</b> returns False (.F.) if the directory exists but is marked with a Hidden or System attribute. (Default)
1
<b>DIRECTORY( )</b> returns True (.T.) if the directory exists, regardless of its attributes. Setting nFlags to 1 allows you to check for hidden or system files.
</param>
<returns>
Logical data type. <b>DIRECTORY( )</b> returns True (.T.) if the specified directory is found on the disk; otherwise, it returns False (.F.).
</returns>
<remarks>
The <b>SET DEFAULT</b> command specifies the X# default directory.
You can use the <b>ADIR( )</b> function to determine specific attributes for the directory.
You can use the <b>CD</b> and <b>CHDIR</b> commands to switch to hidden files and directories.
</remarks>
</directory>
<diskspace>
<summary>
Retrieves the number of bytes with the specified type that are available on the default or specified hard disk drive or volume.
</summary>
<param name="cVolumeName">

Specifies the name of the hard disk drive or volume for which the available space is returned. If you omit cVolumeName, the available space is returned for the default disk drive or volume.

</param>
<param name="nType">

Specifies the type of hard disk space to retrieve. The following table lists the values for nType. 
1
Total amount of space on the hard disk drive.
2
Total amount of free space on the hard disk drive. (Default)
3
Total amount of free space available to the user associated with the calling thread.
</param>
<returns>
Numeric. <b>DISKSPACE( )</b> returns the number of bytes with the type specified. If the hard disk is full, <b>DISKSPACE( )</b> returns a value of 0 or -1. If an error occurs when reading the hard disk drive or volume, <b>DISKSPACE( )</b> can also return a value of –1.
The return value of <b>DISKSPACE( )</b> might not be accurate for large network drives on some networks. Additionally, <b>DISKSPACE( )</b> may return -1 for certain long named directories on Windows 98.
</returns>
<remarks>
You can use <b>DISKSPACE( )</b> to determine if sufficient space is available to back up files or to execute commands such as <b>SORT</b> that require additional disk space for temporary work files.
You can specify the default disk drive or volume using the <b>SET DEFAULT</b> command.
</remarks>
<example>
 <code language="X#">*** Check DISKSPACE before sort ***
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
*** Get size of table header ***
gnTableHead = HEADER( )
*** Calculate size of table ***
gnFileSize = gnTableHead + (RECSIZE( ) * RECCOUNT( ) + 1)
IF <b>DISKSPACE( )</b> &gt; (gnFileSize * 3)
WAIT WINDOW 'Sufficient diskspace to sort.'
ELSE
WAIT WINDOW 'Insufficient diskspace. Sort cannot be done.'
ENDIF</code>
</example>
</diskspace>
<displaypath>
<summary>
Truncates long path expressions to a specified length for display.
</summary>
<param name="cFileName">

Specifies the name of the file at the end of the target path. If you specify a string containing only spaces as cFileName, X# returns the current directory. If you specify an empty string as cFileName, DISPLAYPATH( ) returns an empty string. You can obtain the path of the current directory by using the CURDIR( ).
This function does not check the validity of cFileName and will report the truncated path expression even if no such file exists.

</param>
<param name="nMaxLength">

Specifies the maximum length of the truncated result. nMaxLength must be greater than or equal to 10 and less than or equal to 260
Character data type. DisplayPath( ) returns a string and displays the path in lower case.
</param>
<remarks>
DisplayPath( ) returns a string suitable only for display purposes, so you cannot use the result to reference a file. The length of the resulting string is equal to or less than nMaxLength. However, the result does not break directory names. If inclusion of a directory name would exceed nMaxLength, the result is an ellipsis (...). If the filename exceeds nMaxLength, the result is the filename plus extension.
</remarks>
</displaypath>
<dmy>
<summary>
Returns a character expression in day-month-year format (for example, 31 May 1998) from a Date or DateTime expression. The month name isn't abbreviated.
</summary>
<param name="dExpression">

Specifies the Date expression from which <b>DMY( )</b> returns a character string in day-month-year format.

</param>
<param name="tExpression">

Specifies the DateTime expression from which <b>DMY( )</b> returns a character string in day-month-year format.
</param>
<returns>
Character
</returns>
<remarks>
If SET CENTURY is OFF, <b>DMY( )</b> returns a character string in a dd-Month-yy format (for example, 16 February 98). If SET CENTURY is ON, the format is dd-Month-yyyy (for example, 16 February 1998).
</remarks>
<example>
 <code language="X#">CLEAR
SET CENTURY OFF
? DMY(DATE( ))
SET CENTURY ON
? DMY(DATE( ))</code>
</example>
</dmy>
<dodefault>
<summary>
Executes the parent class event or method of the same name from within a subclass. 
For example, if you place <b>DODEFAULT( )</b> in the <b>Click</b> event of a subclass, X# executes the <b>Click</b> event of the parent class. The scope resolution operator (::), unlike <b>DODEFAULT( )</b>, executes a parent class event or method of a different name.
You can place <b>DODEFAULT( )</b> only within an event or method.
</summary>
<returns>
Character, Numeric, Currency, Date, DateTime, Logical, or Memo
</returns>
<remarks>
The value that <b>DODEFAULT( )</b> returns is determined by the return value of the event or method.
In versions prior to X# 8.0, you could not call <b>DODEFAULT( )</b> in a method that did not exist in the parent class without X# generating an error, "Property name is not found (Error 1734)", returning True (.T.), and disregarding <b>DODEFAULT( )</b> and any passed parameters. However, X# now disregards this and does not generate an error, but the following results still occur:
X# disregards any parameters that are passed because no code is executed.
X# always returns True (.T.), which is the default behavior for any procedure without an explicit <b>RETURN</b> statement.
This behavior affects the following scenarios:  
Custom methods that are defined in a class. For example, the line, codex.Test()/code, generated an error prior to X# 8.0 but no longer does:
 <code language="X#">CLEAR
x=CREATEOBJECT("s1")
x.ReadMethod("Init")
x.Test()
DEFINE CLASS s1 AS Session
PROCEDURE Test
DODEFAULT()
ENDPROC
PROCEDURE ReadMethod(cMethod)
DODEFAULT(cMethod)
ENDPROC
PROCEDURE Error(nError, cMethod, nLine)
? "Error:", nError, cMethod, nLine
ENDPROC
ENDDEFINE</code>
Native methods that are marked with the <b>HIDDEN</b> key word in the parent class. For example:
 <code language="X#">CLEAR
x=CREATEOBJECT("s2")
x.Test()
DEFINE CLASS s2 AS s1
PROCEDURE Test
THIS.ReadMethod("Init")
ENDPROC
PROCEDURE ReadMethod(cMethod)
DODEFAULT(cMethod)
ENDPROC
ENDDEFINE
DEFINE CLASS s1 AS Session
HIDDEN PROCEDURE ReadMethod(cMethod)
DODEFAULT(cMethod)
ENDPROC
PROCEDURE Error(nError, cMethod, nLine)
? "Error:", nError, cMethod, nLine
ENDPROC
ENDDEFINE</code>
Starting in X# 7.0, calling a native method in a base class that contains <b>DODEFAULT( )</b> does not cause an error. For example:
 <code language="X#">CLEAR
x=CREATEOBJECT("s1")
x.ReadMethod("Init")
DEFINE CLASS s1 AS Session
PROCEDURE ReadMethod(cMethod)
DODEFAULT(cMethod)
ENDPROC
PROCEDURE Error(nError, cMethod, nLine)
? "Error:", nError, cMethod, nLine
ENDPROC
ENDDEFINE</code>
</remarks>
</dodefault>
<dow>
<summary>
Returns a numeric day-of-the-week value from a Date or DateTime expression.
</summary>
<param name="dExpression">

Specifies the Date expression from which DOW( ) returns the day number.

</param>
<param name="tExpression">

Specifies the DateTime expression from which DOW( ) returns the day number.

</param>
<param name="nFirstDayOfWeek">

Specifies the first day of the week. nFirstDayOfWeek may be one of the following values.
0
DOW( ) uses whatever day is currently selected in the Week Starts On list box, which appears on the Regional Tab in the Options dialog box.
1
Sunday. This is the default when nFirstDayOfWeek is omitted, and is the first day of the week used in earlier FoxPro versions.
2
Monday
3
Tuesday
4
Wednesday
5
Thursday
6
Friday
7
Saturday
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">STORE DATE( ) TO gdDayNum
CLEAR
? DOW(gdDayNum)
? CDOW(gdDayNum)</code>
</example>
</dow>
<drivetype>
<summary>
Returns the type of the specified drive.
</summary>
<param name="cDrive">

The drive designator. The colon in drive names (for example, "C:") is optional.
</param>
<returns>
Numeric
</returns>
<remarks>
The following table explains the number DRIVETYPE( ) returns and the corresponding drive type description.
1
No type
2
Floppy disk
3
Hard disk
4
Removable drive or network drive
5
CD-ROM
6
RAM disk1
1 Because there are many different types of RAM disks, you might get inconsistent return results.
</remarks>
</drivetype>
<dropoffline>
<summary>
Discards all changes made to an offline view and takes the offline view back online.
</summary>
<param name="cViewName">

Specifies the name of the offline view to take back online.
</param>
<returns>
Logical
</returns>
<remarks>
DROPOFFLINE( ) returns a logical true (.T.) if the offline view is successfully taken back online; otherwise it returns false (.F.).
</remarks>
</dropoffline>
<dtoc>
<summary>
Returns a Character-type date from a Date or DateTime expression.
</summary>
<param name="dExpression">

Specifies a Date-type variable, array element, or field for which DTOC( ) returns a Character-type date.

</param>
<param name="tExpression">

Specifies a DateTime-type variable, array element, or field for which DTOC( ) returns a Character-type date.
1 
Returns the date in a format suitable for indexing. This is particularly useful for maintaining the table records in chronological sequence.
For example, to order table records in entry sequence, you could issue this command:   
 <code language="X#">INDEX ON DTOC(gdInvDate, 1) + gnInvTime TAG Timeindx</code>
codegdInvDate/code and codegnInvTime/code are fields containing the date and time when the data was entered in the record. 
</param>
<returns>
Character
</returns>
<remarks>
DTOC( ) returns a character string corresponding to a Date or DateTime expression. The date format is determined by SET CENTURY and SET DATE.
</remarks>
<example>
 <code language="X#">SET STRICTDATE TO 1
STORE CTOD('10/31/98') TO gdThisDate
CLEAR
? DTOC(gdThisDate)
STORE DTOC({^1998-10-31}+90) TO gcExpireDate
? 'Your 90-day warranty expires ', gcExpireDate
? DTOC({^1998-10-31},1)</code>
</example>
</dtoc>
<dtor>
<summary>
Converts degrees to radians.
</summary>
<param name="nExpression">

Specifies the numeric expression whose value you want to convert to radians. An angle expressed in a degree:minute:second format should be converted to its decimal equivalent.
</param>
<returns>
Numeric
</returns>
<remarks>
DTOR( ) converts the value of a numeric expression given in degrees to an equivalent value in radians. DTOR( ) is useful for working with the X# trigonometric functions: ACOS( ), ASIN( ), COS( ), SIN( ), TAN( ).
Use RTOD( ) to convert radians to degrees. 
</remarks>
<example>
 <code language="X#">CLEAR
? DTOR(0)  &amp;&amp; Displays 0.00
? DTOR(45) &amp;&amp; Displays 0.79
? DTOR(90) &amp;&amp; Displays 1.57
? DTOR(180)  &amp;&amp; Displays 3.14
? COS(DTOR(90))  &amp;&amp; Displays 0.00</code>
</example>
</dtor>
<dtos>
<summary>
Returns a character-string date in a yyyymmdd format from a specified Date or DateTime expression.
</summary>
<param name="dExpression">

Specifies the Date expression DTOS( ) converts to an eight-digit character string.

</param>
<param name="tExpression">

Specifies the DateTime expression DTOS( ) converts to an eight-digit character string.
</param>
<returns>
Character
</returns>
<remarks>
This function is useful for indexing tables on a Date or DateTime field. It is equivalent to DTOC( ) when its optional 1 argument is included.
The character string returned by DTOS( ) isn't affected by SET DATE or SET CENTURY.
</remarks>
<example>
 <code language="X#">CLEAR
? DTOS(DATE( ))</code>
</example>
</dtos>
<editsource>
<summary>
Opens the X# editor and, optionally positions the cursor. 
</summary>
<param name="cShortCutID">

Specifies the valid shortcut ID.

</param>
<param name="cFileName">

Specifies the name of the file to open. If the file is already open, X# activates it.

</param>
<param name="nLineNo">

Specifies the line at which to position the cursor. If you use 0, the cursor is positioned at the last location saved in the resource file. If you provide an invalid or non-existent nlineno, the cursor is positioned at the beginning of the current file. A negative nlineno value will generate an error.

</param>
<param name="cClassName">

Specifies the name of a class or data environment to be edited. If you open a class file (.vcx) without naming a class, the Class Designer opens instead of the editor.

</param>
<param name="cMethodName">

Specifies the name of a method to be edited. Use a valid object-referenced method in the form cObject.nMethodName.

</param>
<param name="cProcName">

Specifies the name of a procedure to be edited in a class type file (.vcx, .scx, .frx, .lbx).
</param>
<returns>
Logical. Returns true (.T.) if the target file opens successfully, otherwise returns error codes according to the following table:
0
Successful file opening.
132, 705
File in use. Cannot be opened.
200
File not opened due to invalid object reference. Verify the presence of cMethodName in the object referenced by the cClassName parameter.
901, 925
File opened but invalid object reference in cMethodName. Check the reference in the cMethodName parameter. Use a reference such as MyForm.MyList.CLICK. Forms and classes return 925; reports return 901.
</returns>
<remarks>
You can pass cShortCutID without any additional information and have the editor open at that location. The cShortCutID is the unique ID value for a shortcut record stored in the Foxtask system table (_VFP.FoxTask). The Task List application uses this table to ensure that it can get the latest line position of the shortcut. X# maintains, internally, current shortcut information, but only writes line position updates to Foxtask when a file is saved.
The file extension determines which X# editor opens, according to the following table:
PRG
Text Editor
MODIFY COMMAND
MPR
Text Editor
MODIFY COMMAND
QPR
Text Editor
MODIFY COMMAND
TXT
Text Editor
MODIFY FILE
SCX
Code Editor
MODIFY FORM
VCX
Code Editor
MODIFY CLASS
FRX
Code Editor
MODIFY REPORT
LBX
Code Editor
MODIFY LABEL
MNX
Menu Editor
MODIFY MENU
DBC
Stored Procedures
MODIFY PROCEDURE
&lt;other&gt;
Text Editor
MODIFY FILE
Program (.prg), database (.dbc stored procedures) and text files support only the nLineNo parameter.
Menu file (.mnx) are opened as text files without reference to objects or to line numbers.
</remarks>
</editsource>
<empty>
<summary>
Determines whether an expression evaluates to empty.
</summary>
<param name="eExpression">

Specifies the expression that <b>EMPTY( )</b> evaluates. You can specify an expression with <b>Character</b>, <b>Numeric</b>, <b>Date</b>, <b>Varbinary</b>, <b>Blob</b>, or <b>Logical</b> type, or the name of a <b>Memo</b> or <b>General</b> field in an open table.
</param>
<returns>
Logical. <b>EMPTY( )</b> returns True (.T.) if the expression eExpression evaluates to empty; otherwise, <b>EMPTY( )</b> returns False (.F.).
When expression types evaluate to the values in the following table, <b>EMPTY( )</b> returns True (.T.).

<b>Blob</b>

Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on

<b>Character</b>

Empty string, spaces, tabs, carriage returns, linefeeds, or any combination of these

<b>Currency</b>

0

<b>Date</b>

Empty, for example, CTOD('')

<b>DateTime</b>

Empty, for example, CTOT('')

<b>Double</b>

0

<b>Float</b>

0

<b>General</b>

Empty (no OLE object)

<b>Integer</b>

0

<b>Logical</b>

False (.F.) 

<b>Memo</b>

Empty (no contents)

<b>Numeric</b>

0

<b>Varbinary</b>

Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on
</returns>
<remarks>
You cannot use <b>EMPTY( )</b> to determine whether a variable object reference is empty. For example, a variable can contain an object reference for a form. If the form is closed by clicking Close from the form's pop-up menu or by issuing <b>CLEAR WINDOWS</b>, the variable contains the null value.
The following program example demonstrates how to use <b>TYPE( )</b> and <b>ISNULL( )</b> to determine if a variable object reference is valid.
 <code language="X#">goMyForm = CREATEOBJECT('Form')
WAIT WINDOW IIF(TYPE('goMyForm') = 'O' AND !ISNULL(goMyForm), ;
'goMyForm has valid object reference',;
'goMyForm does not have valid object reference')</code>
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer     &amp;&amp; Open customer table
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for empty string
? TAG(nCount)  &amp;&amp; Display tag name
? CANDIDATE(nCount)  &amp;&amp; Display candidate status
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found
ENDIF
ENDFOR</code>
</example>
</empty>
<eof>
<summary>
Determines whether the record pointer is positioned past the last record in the current or specified table.
</summary>
<param name="nWorkArea">

Specifies the work area number of the table.

</param>
<param name="cTableAlias">

Specifies the alias of the table.
EOF( ) returns false (.F.) if a table isn't open in the work area you specify.   
If you do not specify a work area or alias, the table that is open in the currently selected work area is tested for the end of the table condition.
</param>
<returns>
Logical
</returns>
<remarks>
EOF( ) returns true (.T.) if the record pointer reaches the end of the table file (EOF). The end of the table is reached when the record pointer passes the last record in the table. For example, when a FIND, LOCATE, or SEEK is unsuccessful, X# moves the record pointer past the last record, and EOF( ) returns true (.T.). EOF( ) returns false (.F.) if the record pointer isn't at the end of the table.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
OPEN DATABASE (HOME() + "samples\data\testdata")
USE customer
GO TOP
local recCtr, btnValue
recCtr = 0
btnValue = 1
DO WHILE btnValue = 1 AND NOT EOF()
? "Company : " + company
recCtr = recCtr + 1
if (recCtr % 20) = 0 then
btnValue =MESSAGEBOX ("Click OK to continue, ;
Cancel to quit.",33)
clear
endif
Skip 1    &amp;&amp; Move down one record
ENDDO
=MESSAGEBOX("Listing complete.",48)</code>
</example>
</eof>
<error>
<summary>
Returns the error number for the error that triggered an ON ERROR routine.
</summary>
<returns>
ERROR( )Return Value
Numeric
</returns>
<remarks>
ERROR( ) returns the number of the most recent error. An ON ERROR routine must be active for ERROR( ) to return a value other than 0.
When an error is trapped during program execution, the error type can be returned by ERROR( ) in an ON ERROR routine. The corresponding error message can be returned by MESSAGE( ).
The value ERROR( ) returns is reset by RETURN or RETRY.
</remarks>
<example>
 <code language="X#">CLEAR
ON ERROR DO errhand WITH ERROR( ), MESSAGE( )
*** The next line generates an error - there is no BRWSE command
BRWSE
ON ERROR
RETURN
*** Error handler ***
PROCEDURE errhand
PARAMETER errnum,message
? Message
? 'Error number: '+ ALLTRIM(STR(Errnum))
RETURN</code>
</example>
</error>
<evaluate>
<summary>
Evaluates a character expression and returns the result.
</summary>
<param name="cExpression">

Specifies the expression to evaluate. cExpression can be a literal character string, or a valid X# expression, variable, array element, or field of any data type, enclosed in quotation marks. cExpression cannot exceed 255 characters.
Whenever possible, use EVALUATE( ) or a name expression to replace macro substitution using the &amp; Command. EVALUATE and name expressions execute faster than macro substitution.
</param>
<returns>
Character, Numeric, Currency, Date, DateTime, Logical, or Memo
</returns>
<remarks>
EVALUATE( ) is similar to TYPE( ) but returns the result of an expression instead of the expression type. An expression containing EVALUATE( ) cannot be optimized by Rushmore Query Optimization.
Including the EVALUATE( ) function in the WHERE clause of a SQL query can return incorrect data.
</remarks>
<example>
 <code language="X#">cMathFunc="INT(4.33)"
nResult=EVALUATE(cMathFunc)
?nResult</code>
</example>
</evaluate>
<eventhandler>
<summary>
Binds a COM server event to implemented interface methods on a X# object. 
For information about binding events from native X# objects, see Event Binding for X# Objects.
</summary>
<param name="oCOMObject">

Specifies the object reference to the object whose events are to be bound. oCOMObject must be a valid COM object.

</param>
<param name="oVFPObject">

Specifies the object reference to the X# object that contains user-defined method code, which maps to corresponding COM object events. The class must implement the events interface for the particular COM object being passed in the first parameter. For example, you must implement the RecordsetEvents interface to bind to an ADO Recordset object.

</param>
<param name="lUnbind">

X# automatically releases the COM object when it goes out of scope. By passing this parameter with a value of .T., you can release the event binding while both objects remain in scope.
</param>
<returns>
Logical data type. <b>EVENTHANDLER( )</b> returns True (.T.) if successful and False (.F.) if unsuccessful.
</returns>
<remarks>
You can bind a single COM object to several X# objects, or you can bind several COM objects to the same X# object. 
Event handling is automatically unbound when either the X# or the COM object is released. You can explicitly call the EVENTHANDLER( ) function and pass the lUnbind parameter to unbind objects without releasing object references.
</remarks>
<example>
 <code language="X#">LOCAL oEvents
LOCAL oRS AS adodb.recordset
LOCAL oConn AS adodb.Connection
oEvents = NEWOBJECT("myclass")
oConn = NEWOBJECT("adodb.connection")
oConn.Provider="MSDASQL"
* Make sure to set the SourceDB property
* below to your TESTDATA location.
oConn.ConnectionString="DSN=X# Database;" + ;
"SourceType=DBC; SourceDB=D:\VFP\DATA\TESTDATA.DBC"
oConn.Open
oRS = oConn.Execute("select * from customer")
? EVENTHANDLER(oRS, oEvents)
?
? PADR(oRS.Fields(0).Value,20)
? EVENTHANDLER (oRS, oEvents, .T.)
oRS.MoveNext
? PADR(oRS.Fields(0).Value,20)
oRS.MoveNext
CLEAR all
RETURN
DEFINE CLASS myclass AS session
IMPLEMENTS RecordsetEvents IN "adodb.recordset"
PROCEDURE Recordsetevents_WillChangeField(cFields AS Number @, Fields AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_FieldChangeComplete(cFields AS Number @, Fields AS VARIANT @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_WillChangeRecord(adReason AS VARIANT @, cRecords AS Number @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_RecordChangeComplete(adReason AS VARIANT @, cRecords AS Number @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_WillChangeRecordset(adReason AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
?adreason,adstatus,precordset.recordcount
PROCEDURE Recordsetevents_RecordsetChangeComplete(adReason AS VARIANT @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_WillMove(adReason AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_MoveComplete(adReason AS VARIANT @, pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_EndOfRecordset(fMoreData AS LOGICAL @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_FetchProgress(Progress AS Number @, MaxProgress AS Number @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
PROCEDURE Recordsetevents_FetchComplete(pError AS VARIANT @, adStatus AS VARIANT @, pRecordset AS VARIANT @) AS VARIANT
? " "+program() + ' ' + TRANSFORM(DATETIME())
ENDDEFINE</code>
</example>
</eventhandler>
<evl>
<summary>
Returns a non-empty value from two expressions. 
You can use the <b>EVL( )</b> function to return an appropriate substitute value instead of an empty value, such as False (.F.) or 0, from two expressions. You can also use this functionality to remove empty values from calculations or operations where empty values are not supported or relevant.
The X# <b>Logical</b> value, False (.F.), and the <b>Numeric</b> value of 0 also evaluate to empty.
</summary>
<returns>
Character, Date, DateTime, Numeric, Currency, Logical, Object. <b>EVL( )</b> returns eExpression1 if it does not evaluate to an empty value; otherwise, it returns eExpresssion2.
</returns>
<example>
The following examples create the memory variables, codeglEmptyDate/code, which contains an empty <b>Date</b> value, and codeglEmptyNum/code, which contains an empty <b>Numeric</b> value, 0.
When performing <b>EVL( )</b> with codeglEmptyDate/code, <b>EVL( )</b> returns an empty string ("") when evaluating codeglEmptyDate/code and an empty string, and code"None"/code when evaluating codeglEmptyDate/code and code"None"/code.
 <code language="X#">STORE {  /  /  } TO glEmptyDate
? EVL(glEmptyDate,"")
? EVL(glEmptyDate, "None")</code>
When performing EVL( ) with glEmptyNum, EVL( ) returns an empty string when evaluating glEmptyNum and an empty string, and "Empty" when evaluating glEmptyNum and "Empty".
 <code language="X#">STORE 0 TO glEmptyNum
? EVL(glEmptyNum,"")
? EVL(glEmptyNum, "Empty")      </code>
</example>
</evl>
<execscript>
<summary>
Enables you to run multiple lines of code from variables, tables, and other text at runtime. 
</summary>
<param name="cExpression">
  Represents the text, a variable, type string, or memo to be executed as code.
</param>
<param name="eParameter1">
Optional. Specify parameters passed to a script that has a parameter statement in first line.
</param>
  <param name="eParameter1">
    Optional. Specify parameters passed to a script that has a parameter statement in first line.
  </param>

  <returns>
The return value is the value returned by the script in cExpression. If the script returns no value, X# returns .T.
</returns>
<remarks>
ExecScript( ), unlike macro expansion, provides the same effect as selecting several lines of code in the command window then pressing the Enter key.
</remarks>
<example>
 <code language="X#">?EXECSCRIPT("oForm=CREATEOBJECT('Form')"+CHR(13)+"?oForm.AutoCenter")</code>
</example>
</execscript>
<exp>
<summary>
Returns the value of ex where x is a specified numeric expression.
</summary>
<param name="nExpression">

Specifies the exponent, ix/i, in the exponential expression ie/ix.
</param>
<returns>
Numeric
</returns>
<remarks>
The value of e, the base of natural logarithms, is approximately 2.71828. The number of decimal places returned by EXP( ) is specified with SET DECIMALS.
</remarks>
<example>
 <code language="X#">? EXP(0)  &amp;&amp; Displays 1.00
? EXP(1)  &amp;&amp; Displays 2.72</code>
</example>
</exp>
<fchsize>
<summary>
Changes the size of a file opened with a low-level file function.
</summary>
<param name="nFileHandle">

Specifies the file handle of the file whose size you wish to change. The file handle is returned by <b>FOPEN( )</b> when you open the file or by <b>FCREATE( )</b> when you create the file. If a file is opened with <b>FOPEN( )</b>, it must be opened with write or read/write privileges to be able to change its size.

</param>
<param name="nNewFileSize">

Specifies the new file size in bytes. If nNewFileSize is less than the original file size, the file is truncated. If nNewFileSize is greater than the original file size, the file size is increased.
</param>
<returns>
Numeric
</returns>
<remarks>
Use <b>FCHSIZE( )</b> to increase the file's size or truncate the file after a specified byte.
When a file's size is increased, X# allocates sectors for the file on the drive where the file is opened. Since <b>FCHSIZE( )</b> does not initialize the new file space, the space can contain previous data. Be sure to manage the new file space.
The final size of the file in bytes is returned. X# returns –1 if <b>FCHSIZE( )</b> is unable to change the file size if, for example, an invalid file handle is specified because of insufficient disk space, or if the file is read-only.
This function can be used to truncate a file to length 0.
</remarks>
</fchsize>
<fclose>
<summary>
Flushes and closes a file or communication port opened with a low-level file function.
</summary>
<param name="nFileHandle">

Specifies the file handle of the low-level file to close. The numeric file handle is returned when you create the file with <b>FCREATE( )</b> or open the file with <b>FOPEN( )</b>.
</param>
<returns>
Logical
</returns>
<remarks>
If the file is successfully closed, <b>FCLOSE( )</b> returns true (.T.) and releases the file handle. If the file cannot be closed, <b>FCLOSE( )</b> returns false (.F.).
CLOSE ALL also closes low-level files.
</remarks>
</fclose>
<fcount>
<summary>
Returns the number of fields in a table.
</summary>
<param name="nWorkArea">

Specifies the work area of the table for which <b>FCOUNT( )</b> returns the number of fields.
<b>FCOUNT( )</b> returns 0 if a table isn't open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which <b>FCOUNT( )</b> returns the number of fields.
X# generates an error message if you specify a table alias that doesn't exist.
</param>
<returns>
Numeric
</returns>
<remarks>
If you omit the optional arguments, <b>FCOUNT( )</b> returns the number of fields in the table open in the currently selected work area.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
SELECT 0
USE employee  &amp;&amp; Opens employee table
CLEAR
? FCOUNT('CUSTOMER')     &amp;&amp; Displays 13, # of fields in Customer
? FCOUNT('EMPLOYEE')  &amp;&amp; Displays 22, # of fields in Employee</code>
</example>
</fcount>
<fcreate>
<summary>
Creates and opens a low-level file.
</summary>
<param name="cFileName">

Specifies the name of the file to create. You can include a drive designator and path with the file name. If a drive designator or path isn't included, the file is created in the default directory.
X# does not recognize a path name properly if a disk or directory name contains an exclamation point (!).

</param>
<param name="nFileAttribute">

Specifies the attributes of the file created. The following table lists the file attributes you can specify.
nFileAttribute
0
(Default) Read/write
1
Read-only 
2
Hidden 
3
Read-only/Hidden 
4
System 
5
Read-only/System 
6
System/Hidden 
7
Read-only/Hidden/System
Note that a file created with nFileAttribute other than 0 cannot be written to with <b>FPUTS( )</b> or <b>FWRITE( )</b> until the file is closed and opened again.   
Use DISPLAY STATUS or LIST STATUS to display or print information about files created and opened with <b>FCREATE( )</b>. DISPLAY STATUS and LIST STATUS give the following information about each file opened or created with a low-level file function:   
The drive, directory, and file name
The file handle number
The file pointer position
The read/write attributes
</param>
<returns>
Numeric
</returns>
<remarks>
If a file with the name you specify already exists, it is overwritten without warning.

<b>FCREATE( )</b> assigns a file handle number to the file, which you can use to identify the file in other X# low-level file functions. <b>FCREATE( )</b> returns the file handle number when a file is created, or returns –1 if the file cannot be created.
Assign the file handle number to a memory variable so you can access the file by the variable in other low-level file functions.
You cannot open a communication port with <b>FCREATE( )</b>. Use <b>FOPEN( )</b> to open a communication port.
</remarks>
<example>
 <code language="X#">IF FILE('errors.txt')  &amp;&amp; Does file exist?
gnErrFile = FOPEN('errors.txt',12)     &amp;&amp; If so, open read/write
ELSE
gnErrFile = FCREATE('errors.txt')  &amp;&amp; If not create it
ENDIF
IF gnErrFile &lt; 0     &amp;&amp; Check for error opening file
WAIT 'Cannot open or create output file' WINDOW NOWAIT
ELSE  &amp;&amp; If no error, write to file
=FWRITE(gnErrFile , 'Error information to be written here')
ENDIF
=FCLOSE(gnErrFile )     &amp;&amp; Close file
IF gnErrFile &gt; 0
MODIFY FILE errors.txt NOWAIT  &amp;&amp; Open file in edit window
ENDIF  </code>
</example>
</fcreate>
<fdate>
<summary>
Returns the last modification Date or DateTime for a file.
</summary>
<param name="cFileName">

Specifies the name of the file whose last modification date <b>FDATE( )</b> returns. cFileName can include a path with the file name. If a path is not included with the file name, X# searches for the file in the default directory and in any directories or folders specified with SET PATH.

</param>
<param name="nType">

Specifies that <b>FDATE( )</b> returns the last modification date or DateTime of the file specified with cFileName. If nType is 0, the last modification date is returned. Including 0 is identical to omitting nType. If nType is 1, the last modification DateTime is returned.
</param>
<returns>
Date
</returns>
<remarks>
The Date or DateTime value that <b>FDATE( )</b> returns is assigned to the file by the operating system.
Use LUPDATE( ) to determine the last modification date for an open table.
</remarks>
<example>
 <code language="X#">? FDATE('FOXUSER.DBF', 1)  &amp;&amp; Displays the last modification DateTime</code>
</example>
</fdate>
<feof>
<summary>
Determines whether the file pointer is positioned at the end of a file.
</summary>
<param name="nFileHandle">

Specifies the file handle number of the file to check for the end-of-file condition. <b>FEOF( )</b> always returns true (.T.) if you specify a file handle number of a communication port opened with <b>FOPEN( )</b>.
</param>
<returns>
Logical
</returns>
<remarks>
This low-level file function returns true (.T.) if the file pointer is positioned at the end of a file opened with a low-level file function. <b>FEOF( )</b> returns false (.F.) if the file pointer isn't at the end of the file.
</remarks>
<example>
 <code language="X#">*** Open the file test.txt ***
gnFileHandle = FOPEN('test.txt')
*** Move the file pointer to BOF ***
gnPosition = FSEEK(gnFileHandle, 0)
*** If file pointer is at BOF and EOF, the file is empty ***
*** Otherwise the file must have something in it ***
IF FEOF(gnFileHandle)
WAIT WINDOW 'This file is empty!' NOWAIT
ELSE
WAIT WINDOW 'This file has something in it!' NOWAIT
ENDIF
= FCLOSE(gnFileHandle)</code>
</example>
</feof>
<ferror>
<summary>
Returns a number corresponding to the most recent low-level file function error.
</summary>
<returns>
FERROR( )Return Value
Numeric
</returns>
<remarks>

<b>FERROR( )</b> returns 0 if a low-level file function executes successfully. A positive value is returned if a function doesn't execute successfully. The following table lists each error number returned by <b>FERROR( )</b> and the cause of the error.
2
File not found
4
Too many files open (out of file handles)
5
Access denied
6
Invalid file handle given
8
Out of memory
25
Seek error (can't seek before the start of a file)
29
Disk full
31
Error opening file
</remarks>
</ferror>
<fflush>
<summary>
Flushes to disk a file opened with a low-level function.
</summary>
<param name="nFileHandle">

Specifies the file handle of the file to flush to disk.

</param>
<param name="lForce">

If you specify a logical true (.T.) for lForce, Windows is used to immediately flush the file to disk.
If you specify a logical false (.F.) (the default if lForce is omitted), X# flushes the file to disk at its earliest opportunity.
</param>
<returns>
Logical
</returns>
<remarks>

<b>FFLUSH( )</b> also releases the memory used by the file's buffer.
FLUSH is different from the <b>FFLUSH( )</b> function. FLUSH doesn't operate on low-level files but rather on tables and indexes.
</remarks>
<example>
 <code language="X#">IF FILE('input.dat')
gnTestFile = FOPEN('input.dat',2)
ELSE
gnTestFile = FCREATE('input.dat')
ENDIF
gnIOBytes = FWRITE(gnTestFile,'Test output')
gnIOBytes = FWRITE(gnTestFile,' for low-level file I/O')
glFlushOk = FFLUSH(gnTestFile, .T.)
gnIOBytes = FWRITE(gnTestFile,'Test output2')
gnIOBytes = FWRITE(gnTestFile,' for low-level file I/O')
glFlushOk = FFLUSH(gnTestFile)
glCloseOk = FCLOSE(gnTestFile)
MODIFY FILE input.dat NOWAIT NOEDIT</code>
</example>
</fflush>
<fgets>
<summary>
Returns a series of bytes from a file or a communication port opened with a low-level file function until it encounters a carriage return.
</summary>
<param name="nFileHandle">

Specifies the numeric file handle of the file or communication port from which <b>FGETS( )</b> returns data.

</param>
<param name="nBytes">

Specifies the number of bytes <b>FGETS( )</b> returns. <b>FGETS( )</b> returns nBytes bytes unless a carriage return is encountered first. <b>FGETS( )</b> returns data between the starting file-pointer position and the carriage return if a carriage return is encountered within nBytes bytes.
<b>FGETS( )</b> returns a maximum of 8192 bytes. If you omit nBytes, <b>FGETS( )</b>returns 254 bytes by default. 
</param>
<returns>
Character
</returns>
<remarks>
You can read a file line by line by issuing a series of <b>FGETS( )</b>.

<b>FGETS( )</b> returns a series of bytes as a character string. Data is returned starting from the current file's pointer position and continuing until a carriage return is encountered. The file pointer is then positioned on the byte immediately following the carriage return. The carriage return is not returned as part of the string, and line feeds are discarded.
</remarks>
<example>
 <code language="X#">*** TEST.TXT must exist ***
STORE FOPEN('test.txt') TO gnFileHandle    &amp;&amp; Open the file
STORE FSEEK(gnFileHandle, 0, 2) TO gnEnd    &amp;&amp; Move pointer to EOF
STORE FSEEK(gnFileHandle, 0) TO gnTop     &amp;&amp; Move pointer to BOF
IF gnEnd &lt;= 0  &amp;&amp; Is file empty?
WAIT WINDOW 'This file is empty!' NOWAIT
ELSE  &amp;&amp; If not
gcString = FGETS(gnFileHandle, gnEnd)  &amp;&amp; Store contents
? gcString
ENDIF
= FCLOSE(gnFileHandle)  &amp;&amp; Close the file</code>
</example>
</fgets>
<field>
<summary>
Returns the name of a field, referenced by number, in a table.
</summary>
<param name="nFieldNumber">

Specifies the field number. If nFieldNumber is 1, the name of the first field in the table is returned; if nFieldNumber is 2, the name of the second field is returned, and so on. The empty string is returned if nFieldNumber is greater than the number of fields. Field names are returned in upper case.

</param>
<param name="cFieldName">

Specifies the name of a field. This is used primarily to retrieve the actual field caption as stored in a database container (DBC) when used with the nFlags parameter. 
If the field caption is an expression (=), the expression is evaluated. Otherwise, the actual string literal is returned. If the expression cannot be evaluated at run time, an error is raised, and the actual field name is returned. 

</param>
<param name="nWorkArea">

Specifies the work area of the table for which <b>FIELD( )</b> returns field names.
<b>FIELD( )</b> returns the empty string if a table is not open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which <b>FIELD( )</b> returns field names.
X# generates an error message if you specify a table alias that does not exist. 

</param>
<param name="nFlags">

Specifies whether the actual field name or field caption is returned.
nFlags
0
Return actual field name.
<b>FIELD( )</b> preserves the case of the returned field name, as long as the table is stored in a DBC.
1
Return field caption. If the field caption is an expression, return its evaluated value.
</param>
<returns>
Character data type. If you omit the optional arguments, <b>FIELD( )</b> returns the names of the fields in the table open in the currently selected work area.
</returns>
<remarks>
You can use the <b>SELECT( )</b> function to determine the current work area for nWorkArea. You can use the <b>ALIAS( )</b> function to determine the alias of the table in the current work area for cTableAlias. For more information, see SELECT( ) Function and ALIAS( ) Function.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
CLEAR
FOR gnCount = 1 TO FCOUNT( )  &amp;&amp; Loop for number of fields
? FIELD(gnCount)  &amp;&amp; Display each field
NEXT
?
? 'Number of fields: ' + ALLTRIM(STR(gnCount -1))</code>
</example>
</field>
<file>
<summary>
Locates the specified file.
</summary>
<param name="cFileName">

Specifies the name of the file to locate. cFileName must include the file extension. You can include a path with the file name to search for a file in a directory or on a drive other than the current directory or drive.
If you do not include a path with the file name, X# searches in the default directory for the file. If it cannot find the file in the default directory, X# searches along the X# path, which is established with <b>SET PATH</b>. 

</param>
<param name="nFlags">

Specifies the kind of value <b>FILE( )</b> returns when the file exists but might be marked with the <b>Hidden</b> or <b>System</b> attribute. The following table lists the values for nFlags.
0
<b>FILE( )</b> returns False (.F.) if the file exists but is marked with a <b>Hidden</b> or <b>System</b> attribute. (Default)
1
<b>FILE( )</b> returns True (.T.) if the file exists, regardless of its file attributes. Setting nFlags to 1 allows you to check for hidden or system files.
</param>
<returns>
Logical data type. <b>FILE( )</b> returns True (.T.) if the specified file is included in an application or found on a disk; otherwise, it returns False (.F.).
</returns>
<remarks>
You can use the <b>ADIR( )</b> function to retrieve specific attributes for the file.
You can use the <b>CD</b> and <b>CHDIR</b> commands to switch to hidden files and directories.
</remarks>
<example>
 
<code language="X#">SET PATH TO HOME( )
CLEAR
IF FILE('foxuser.dbf')
WAIT WINDOW 'X# resource file present'
ELSE
WAIT WINDOW 'X# resource file not present'
ENDIF</code>
</example>
</file>
<filetostr>
<summary>
Returns the contents of a file as a character string.
</summary>
<param name="cFileName">

Specifies the name of the file whose contents are returned as a character string. If the file is in a directory other than the current default directory, include a path with the file name.
</param>
<returns>
Character
</returns>
<remarks>
Note that the size of the character string FILETOSTR( ) returns can be very large. The amount of available memory or disk space determines if you can store the character string to a memory variable, array element, or memo field. Also, character fields in X# are limited to 254 characters. See X# System Capacities for more information about limitations on character type data.
</remarks>
<example>
 <code language="X#">CD HOME()
cRedist=FILETOSTR("REDIST.TXT")
?OCCURS(".MSM",cRedist)</code>
</example>
</filetostr>
<filter>
<summary>
Returns the table filter expression specified in SET FILTER.
</summary>
<param name="nWorkArea">

Specifies the work area of the table for which FILTER( ) returns the filter expression.
FILTER( ) returns the empty string if a table isn't open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which FILTER( ) returns the filter expression.
X# generates an error message if you specify a table alias that doesn't exist.
</param>
<returns>
Character
</returns>
<remarks>
If you omit the optional arguments, FILTER( ) returns the filter expression for the table open in the currently selected work area. For more information about creating a filter, see SET FILTER.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
SET TALK ON
SET FILTER TO SUBSTR(cust_id,1) = 'B'
CLEAR
? FILTER( )  &amp;&amp; Display filter expression
STORE FILTER('customer') TO gcOldFilter    &amp;&amp; Save filter expression
SET FILTER TO country = 'USA'
? FILTER( )  &amp;&amp; Display filter expression
SET FILTER TO &amp;gcOldFilter    &amp;&amp; Restore filter expression
? FILTER( )  &amp;&amp; Display filter expression
LIST FIELDS cust_id, contact  &amp;&amp; Demonstrate filter condition</code>
</example>
</filter>
<fklabel>
<summary>
Returns the name of the function key (F1, F2, F3 ...) from the key's corresponding function key number.
</summary>
<param name="nFunctionKeyNumber">

Specifies the function key number. The value of nFunctionKeyNumber should be from 0 through the number of function keys minus 1. FKLABEL( ) returns the empty string if nFunctionKeyNumber is greater than the number of function keys minus 1. The number of function keys can be determined with FKMAX( ).
</param>
<returns>
Character
</returns>
<remarks>
Function keys can be programmed with SET FUNCTION.
The value returned by FKLABEL( ) is affected by SET COMPATIBLE. When COMPATIBLE is set to FOXPLUS (the default), FKLABEL( ) returns the function keys. When COMPATIBLE is set to DB4, FKLABEL( ) returns the function key and function key combinations (F1, CTRL+F1, SHIFT+F1, F2, CTRL+F2, SHIFT+F2, ...).
</remarks>
<example>
 <code language="X#">CLEAR
SET COMPATIBLE OFF
? 'COMPATIBLE OFF'
?
FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
ENDFOR
SET COMPATIBLE ON
?
? 'COMPATIBLE ON'
?
FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
ENDFOR</code>
</example>
</fklabel>
<fkmax>
<summary>
Returns the number of programmable function keys or function key combinations on your keyboard.
</summary>
<returns>
FKMAX( )Return Value
Numeric
</returns>
<remarks>
The value returned by FKMAX( ) is affected by SET COMPATIBLE. When SET COMPATIBLE is set to FOXPLUS (the default), FKMAX( ) returns the number of function keys. When SET COMPATIBLE is set to DB4, FKMAX( ) returns the number of function key and function key combinations (F1, CTRL+F1, SHIFT+F1, F2, CTRL+F2, SHIFT+F2, ...).
</remarks>
<example>
 <code language="X#">CLEAR
SET COMPATIBLE OFF
? 'COMPATIBLE OFF'
?
FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
ENDFOR
SET COMPATIBLE ON
?
? 'COMPATIBLE ON'
?
FOR nCount = 1 TO FKMAX( )  &amp;&amp; Loop for # of function keys
? FKLABEL(nCount)  &amp;&amp; Display programmable function keys
ENDFOR</code>
</example>
</fkmax>
<fldlist>
<summary>
Included for compatibility with dBASE.
 
</summary>
</fldlist>
<flock>
<summary>
Attempts to lock the current or specified table.
</summary>
<param name="nWorkArea">

Specifies the work area of the table that FLOCK( ) attempts to lock. Omitting nWorkArea or cTableAlias causes FLOCK( ) to attempt locking the table that is open in the currently selected work area.

</param>
<param name="cTableAlias">

Specifies the alias of the table that FLOCK( ) attempts to lock.
X# generates an error message if you specify a table alias that does not exist.
</param>
<returns>
Logical. FLOCK( ) returns True (.T.) if the table is successfully locked. Otherwise, it returns False (.F.) under the following conditions:  
The table or a record in the table is already locked by another user.
A table is not open in the work area you specify.
If FLOCK() fails to lock a table and returns False (.F.), FLOCK() does not generate an error. As a result, you cannot use FLOCK() to trigger an ON ERROR routine.
</returns>
<remarks>
When a table is locked, the table is available for both read and write access by the user who placed the lock. Other users on the network have read-only access to the table. For information on how to lock a table and prevent access to it by other users, see SET EXCLUSIVE Command and USE Command.
A table remains locked until it is unlocked by the user who placed the lock. The table can be unlocked by issuing UNLOCK, closing the table, or quitting X#. Tables can be closed with USE, CLEAR ALL, or CLOSE DATABASES.
By default, FLOCK( ) attempts to lock a table once. Use SET REPROCESS to automatically retry a table lock when the first attempt fails. SET REPROCESS determines the number of lock attempts, or the length of time during which lock attempts are made when the initial lock attempt is unsuccessful. For more information, see SET REPROCESS Command.
You can establish relations between two or more tables with SET RELATION. Placing a file lock on a table that is related to one or more tables doesn't place a file lock on the related tables. You must explicitly place and remove locks on the related tables.
For additional information about record and file locking and sharing tables on a network, see Programming for Shared Access.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE products  &amp;&amp; Opens products table
SET REPROCESS TO 3 SECONDS
SELECT * FROM products INTO TABLE newprods
IF FLOCK( )
*** New product initialization ***
REPLACE ALL in_stock  WITH 0.00
REPLACE ALL on_order WITH 0.00
WAIT 'Initialization Complete' WINDOW NOWAIT
ELSE
*** File is locked, warn user ***
WAIT WINDOW 'Unable to open products file; try again later!' NOWAIT
ENDIF
BROWSE FIELDS in_stock, on_order &amp;&amp; Displays newprods table
USE
ERASE newprods.dbf</code>
</example>
</flock>
<floor>
<summary>
Returns the nearest integer that is less than or equal to the specified numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression for which FLOOR( ) returns the nearest integer that is less than or equal to the numeric expression.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">STORE  10.9 TO gnNumber1
STORE -10.1 TO gnNumber2
CLEAR
? FLOOR(gnNumber1)  &amp;&amp; Displays 10
? FLOOR(gnNumber2)  &amp;&amp; Displays -11
? FLOOR(10.0)  &amp;&amp; Displays 10
? FLOOR(-10.0)  &amp;&amp; Displays -10</code>
</example>
</floor>
<fontmetric>
<summary>
Returns font attributes for the current installed operating system fonts.
</summary>
<param name="nAttribute">

Determines the font attribute FONTMETRIC( ) returns. If you omit cFontName, nFontSize, and cFontStyle, FONTMETRIC( ) returns the attribute for the current font in the active output window.
The following table lists values for nAttribute and the corresponding font attributes returned.   
NAttribute
1
Character height in pixels
2
Character ascent (units above baseline) in pixels
3
Character descent (units below baseline) in pixels
4
Leading (space between lines) in pixels
5
Extra leading in pixels
6
Average character width in pixels
7
Maximum character width in pixels
8
Font weight.
9
Italic (0 = no, nonzero = yes)
10
Underlined (0 = no, nonzero = yes)
11
Strikeout (0 = no, nonzero = yes)
12
First character defined in font
13
Last character defined in font
14
Default character (substituted for characters not in font)
15
Word-break character
16
Pitch and family
17
Character set
18
Overhang (extra added width)
19
Horizontal aspect for font device
20
Vertical aspect for font device
For more information about the numeric values returned by FONTMETRIC( ), see the TEXTMETRIC function in the Microsoft Windows Programmer's Reference. 

</param>
<param name="cFontName">

Specifies the name of an installed font.

</param>
<param name="nFontSize">

Specifies the point size of the font specified with cFontName.

</param>
<param name="cFontStyle">

Specifies a font style code for the font specified with cFontName. If you omit cFontStyle, FONTMETRIC( ) returns the attribute for the Normal font style.
cFontStyle can be a character or a combination of characters listed in the following font style table. For example, the combination BI specifies the Bold Italic font style.   
Outline
Q
Opaque
Shadow
–
Strikeout
Transparent
U
Underline
</param>
<returns>
Numeric
</returns>
<remarks>
FONTMETRIC( ) returns font attributes for the current font for the active output window. WFONT( ) can be used to determine the current window font.
</remarks>
</fontmetric>
<fopen>
<summary>
Opens a file for use with low-level file functions.
</summary>
<param name="cFileName">

Specifies the name of the file to open. cFileName can include a path to open files in directories, folders, drives, or volumes not in the current X# search path. If a path isn't included, X# searches for the file in the following locations:
Default directory
Path established with SET PATH 
X# will not recognize a path name properly if a disk or directory name contains an exclamation point (!).

</param>
<param name="nAttribute">

Specifies read/write privileges or a buffering scheme for the file you open. The following table lists each number you can include in nAttribute, and the read/write file privileges and buffering scheme it establishes.
0
(Default) Read-only
Buffered
1
Write-only
2
Read and Write
10
Unbuffered
11
12
If nAttribute isn't included, or if nAttribute evaluates to 0, the file is opened as read-only and is buffered.   
X# will not recognize a path name properly if a disk or directory name contains an exclamation point (!).
</param>
<returns>
Numeric
</returns>
<remarks>
If <b>FOPEN( )</b> successfully opens the file, the file handle number of the file is returned. <b>FOPEN( )</b> returns –1 if the file cannot be opened.
Assign the file handle number to a memory variable so you can access the file by the memory variable in other low-level file functions.
The following information about files opened with <b>FOPEN( )</b> can be displayed or sent to a printer with DISPLAY STATUS or LIST STATUS.
Drive and directory or volume and folder, and file name
File handle number
File pointer position
Read/write attributes
</remarks>
<example>
 <code language="X#">IF FILE('errors.txt')  &amp;&amp; Does file exist?
gnErrFile = FOPEN('errors.txt',12)  &amp;&amp; If so, open read/write
ELSE
gnErrFile = FCREATE('errors.txt')  &amp;&amp; If not, create it
ENDIF
IF gnErrFile &lt; 0  &amp;&amp; Check for error opening file
WAIT 'Cannot open or create output file' WINDOW NOWAIT
ELSE  &amp;&amp; If no error, write to file
=FWRITE(gnErrFile, 'Error information to be written here')
ENDIF
=FCLOSE(gnErrFile)  &amp;&amp; Close file
MODIFY FILE errors.txt NOWAIT  &amp;&amp; Open file in edit window </code>
</example>
</fopen>
<for>
<summary>
Returns the index filter expression, in uppercase, of an open single-entry index (.idx) file or an index tag.
</summary>
<param name="nIndexNumber">

Specifies the index file or tag for which the filter expression is returned. <b>FOR( )</b> returns filter expressions in the following order as nIndexNumber increases from 1 to the total number of open single-entry files and structural compound and independent compound index tags:
Filter expressions from single-entry index files (if any are open) are returned first. The order the single-entry index files are included in USE or SET INDEX determines the order in which the filter expressions are returned.
Filter expressions for each tag in the structural compound index (if one is present) are returned next. The filter expressions are returned from the tags in the order the tags are created in the structural index.
Filter expressions for each tag in any open independent compound indexes are returned last. The filter expressions are returned from the tags in the order in which the tags are created in the independent compound indexes. 
The empty string is returned if an index or index tag is created without a FOR clause or if nIndexNumber is greater than the total number of open single-entry files and structural compound and independent compound index tags. 

</param>
<param name="nWorkArea">

Specifies the work area of the table for which <b>FOR( )</b> returns the index filter expressions.
<b>FOR( )</b> returns the empty string if a table isn't open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which <b>FOR( )</b> returns the index filter expressions.
X# generates an error message if you specify a table alias that doesn't exist.
</param>
<returns>
Character
</returns>
<remarks>
If you don't include any of the optional arguments, <b>FOR( )</b> returns the index filter expression for the master index file or index tag. If a master index file or index tag isn't in effect (for example, you've issued <b>SET ORDER TO</b> to place the table in physical record order), <b>FOR( )</b> returns the empty string.
You can create filtered indexes in X#. If you include the optional FOR lExpression clause in INDEX, the index file acts as a filter on the table. Only records that match the filter expression lExpression are available for display and access. Index keys are created in the index file for just those records matching the filter expression.

<b>USE</b> and <b>SET INDEX</b> both support an index file name list that makes it possible for you to open multiple index files for a table. Any combination of single-entry index file names, structural compound, or independent compound index file names can be included in the index file name list. <b>FOR( )</b> is similar to SYS(2021) and is provided for compatibility with dBASE IV.
</remarks>
</for>
<found>
<summary>
Determines whether the most recently executed <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was successful or if the record pointer was moved in a related table.
You can use <b>FOUND( ) </b>to determine if a child table has a record that matches the parent record.
</summary>
<param name="nWorkArea">

Specifies the work area of the table that the most recent <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was called on.

</param>
<param name="cTableAlias">

Specifies the alias of the table that the most recent <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was called on. 
If you specify a table alias that does not exist, X# generates an error message.
</param>
<returns>
Logical. <b>FOUND( )</b> returns True (.T.) if the most recent <b>CONTINUE</b>, <b>FIND</b>, <b>LOCATE</b>, or <b>SEEK</b> command was successful; otherwise, it returns False (.F.). If a table is not open in the work area you specify, <b>FOUND( )</b> returns False. When <b>FOUND( )</b> encounters an end-of-file, which can be determined by the <b>EOF( )</b> function, it always returns False.
</returns>
<remarks>
If you call <b>FOUND( )</b> without arguments, <b>FOUND( )</b> is called on the table open in the currently selected work area.
The following example locates and counts all customers whose Country field in the Customer table contains "GERMANY". <b>CLOSE DATABASES</b> closes all databases, and <b>OPEN DATABASE</b> opens the sample X# database, TestData.dbc. <b>USE</b> opens the Customer table.

<b>STORE</b> stores a value of 0 in the variable gnCount. <b>LOCATE</b> searches for the first record in which the Country field contains the value "GERMANY". The <b>DO WHILE</b> loop increments the variable gnCount by 1 and uses <b>CONTINUE</b> to perform another <b>LOCATE</b> operation. When there are no more matching records, the total number of customers is displayed.
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\TestData')
USE Customer
STORE 0 TO gnCount
LOCATE FOR UPPER(Country)='GERMANY'
DO WHILE FOUND()
gnCount = gnCount + 1
CONTINUE
ENDDO
? "Total customers from Germany: "+LTRIM(STR(gnCount))</code>
</remarks>
</found>
<fputs>
<summary>
Writes a character string, carriage return, and line feed to a file opened with a low-level file function.
</summary>
<param name="nFileHandle">

Specifies the file handle number for the file to which <b>FPUTS( )</b> writes data.

</param>
<param name="cExpression">

Specifies the character expression that <b>FPUTS( )</b> writes to the file.

</param>
<param name="nCharactersWritten">

Specifies the number of characters in cExpression to write to the file.
<b>FPUTS( )</b> writes the entire character expression cExpression to the file if you omit nCharactersWritten. If you include nCharactersWritten, nCharactersWritten characters are written to the file. If nCharactersWritten is less than the number of characters in cExpression, only nCharactersWritten characters are written to the file. All of cExpression is written to the file if nCharactersWritten is equal to or greater than the number of characters in cExpression. 
</param>
<returns>
Numeric
</returns>
<remarks>
FPUTS( ) returns the number of bytes written to the file. Zero is returned if <b>FPUTS( )</b> cannot write to the file for any reason.
</remarks>
</fputs>
<fread>
<summary>
Returns a specified number of bytes from a file opened with a low-level function.
</summary>
<param name="nFileHandle">

Specifies the file handle number for the file from which <b>FREAD( )</b> returns data. You can obtain nFileHandle from the return value of successful FOPEN( ) or FCREATE( ) statements.

</param>
<param name="nByte">

Specifies the number of bytes returned by <b>FREAD( )</b> with a limit of 65,535 bytes. <b>FREAD( )</b> returns data starting from the current file pointer position and continues until it returns nBytes bytes or until it encounters the end of the file.
</param>
<returns>
Character
</returns>
<example>
 <code language="X#">Local gnFileHandle,nSize,cString
gnFileHandle = FOPEN("test.txt")
* Seek to end of file to determine number of bytes in the file.
nSize =  FSEEK(gnFileHandle, 0, 2)     &amp;&amp; Move pointer to EOF
IF nSize &lt;= 0
* If file is empty, display an error message.
WAIT WINDOW "This file is empty!" NOWAIT
ELSE
* If file is not empty, store the file's contents in memory
* and display the text in the main X# window.
= FSEEK(gnFileHandle, 0, 0)      &amp;&amp; Move pointer to BOF
cString = FREAD(gnFileHandle, nSize)
? cString
ENDIF
= FCLOSE(gnFileHandle)         &amp;&amp; Close the file</code>
</example>
</fread>
<fseek>
<summary>
Moves the file pointer in a file opened with a low-level file function.
</summary>
<param name="nFileHandle">

Specifies the file handle for the file in which FSEEK( ) moves the file pointer. A file handle number is returned by FCREATE( ) or FOPEN( ) when the file is created or opened.

</param>
<param name="nBytesMoved">

Specifies the number of bytes to move the file pointer. The file pointer is moved toward the end of the file if nBytesMoved is positive. The file pointer is moved toward the beginning of the file if nBytesMoved is negative.

</param>
<param name="nRelativePosition">

Moves the file pointer to a relative position in the file. By default, the file pointer is moved relative to the beginning of the file. You can also move the file pointer relative to the current file pointer or the end of the file by including nRelativePosition. The following table lists values for nRelativePosition and from where the file pointer is moved.
0
(Default) The beginning of the file.
1
The current file pointer position.
2
The end of the file.
</param>
<returns>
Numeric
</returns>
<remarks>
After moving the file pointer, FSEEK( ) returns the number of bytes the file pointer is positioned from the beginning of the file. The file pointer can also be moved with FREAD( ) and FWRITE( ).
</remarks>
<example>
 <code language="X#">FUNCTION fsize2
PARAMETERS gcFileName  &amp;&amp; File to be checked
PRIVATE pnHandle,pnSize
IF PARAMETERS( ) = 0
RETURN -2  &amp;&amp; Return -2 if no parameter passed
ELSE
IF !FILE(gcFileName)
RETURN -1  &amp;&amp; Return -1 if file does not exist
ENDIF
ENDIF
pnHandle = FOPEN(gcFileName)   &amp;&amp; Open file
pnSize = FSEEK(pnHandle,0,2)   &amp;&amp; Determine file size, assign to pnSize
=FCLOSE(pnHandle)  &amp;&amp; Close file
RETURN pnSize  &amp;&amp; Return value</code>
</example>
</fseek>
<fsize>
<summary>
Returns the size in bytes of a specified field or file.
</summary>
<param name="cFieldName">

Specifies the name of the field.

</param>
<param name="nWorkArea">

Specifies the work area of the table for which FSIZE( ) returns a field size.
FSIZE( ) returns 0 if a table isn't open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which FSIZE( ) returns a field size.
X# generates an error message if you specify a table alias that doesn't exist. 

</param>
<param name="cFileName">

Specifies a file for which FSIZE( ) returns the size in bytes.
</param>
<returns>
Numeric
</returns>
<remarks>
The current setting of SET COMPATIBLE determines if FSIZE( ) returns the size of a field or a file. If SET COMPATIBLE is set to OFF or FOXPLUS (the default), FSIZE( ) returns the size of a field. If SET COMPATIBLE is set to ON or DB4, FSIZE( ) returns the size of a file.
The following table shows the default size (in bytes) for each fixed-length field type.
Currency
8
Date
8
DateTime
8
Double
8
Integer
4
Logical
1
Memo
4
General
4
The size of a field can be displayed with DISPLAY STRUCTURE and LIST STRUCTURE.
If you omit the optional nWorkArea and cTableAlias arguments, FSIZE( ) returns the field size for a field in the current table and work area.
</remarks>
<example>
 <code language="X#">SET COMPATIBLE OFF
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Open Customer table
CLEAR
? FSIZE('contact')  &amp;&amp; Displays 30
? FSIZE('cust_id')  &amp;&amp; Displays 6</code>
</example>
</fsize>
<ftime>
<summary>
Returns the last modification time for a file.
</summary>
<param name="cFileName">

Specifies the name of the file whose last modification time FTIME( ) returns. cFileName can include a path with the file name. If a path is not included with the file name, X# searches for the file in the default directory and in any directories or folders specified with SET PATH.
</param>
<returns>
Character
</returns>
<remarks>
The time that FTIME( ) returns is assigned to the file by the operating system.
</remarks>
<example>
 <code language="X#">? FTIME('FOXUSER.DBF')  &amp;&amp; Displays the last modification time</code>
</example>
</ftime>
<fullpath>
<summary>
Returns the path to a specified file or the path relative to another file.
</summary>
<param name="cFileName1">

Specifies the file for which X# searches. 
Be sure to include the file name extension.
If the file is located in the X# path, the path is returned with the file name. You can specify the X# path using the SET PATH command. 
If the file cannot be located in the X# path, FULLPATH( ) returns the current directory the path and file name as if the file was located in the current default directory.

</param>
<param name="nMSDOSPath">

Specifies to search the MS-DOS path instead of the X# path. nMSDOSPath can have any numeric value. 
If the file cannot be located in the MS-DOS path, FULLPATH( ) returns the path and the file name as if the file was located in the current default directory.

</param>
<param name="cFileName2">

Specifies a second file name to search for. 
Be sure to include the file name extension.
FULLPATH( ) returns the path for the first file relative to the second file.
</param>
<returns>
Character. FULLPATH( ) returns a file path.
</returns>
<remarks>
Use the <b>FILE( )</b> function to verify that the file actually exists; otherwise, if the file does not exist, the function returns the file name with the current directory.
</remarks>
</fullpath>
<fv>
<summary>
Returns the future value of a financial investment.
</summary>
<param name="nPayment">

Specifies the constant periodic payment (which can be negative or positive).

</param>
<param name="nInterestRate">

Specifies the periodic interest rate. If the interest rate is annual but the payments are made monthly, divide the annual interest rate by 12.

</param>
<param name="nPeriods">

Specifies the number of periods over which payments are made. FV( ) assumes that the periodic payments are made at the end of each period.
</param>
<returns>
Numeric
</returns>
<remarks>
FV( ) computes the future value of a series of constant periodic payments earning fixed compound interest. The future value is the total of all payments and the interest.
</remarks>
<example>
 <code language="X#">STORE 500 TO gnPayment  &amp;&amp; Monthly payment
STORE .075/12 TO gnInterest     &amp;&amp; 7.5% annual interest rate
STORE 48 TO gnPeriods  &amp;&amp; Four years (48 months)
CLEAR
? FV(gnPayment, gnInterest, gnPeriods)    &amp;&amp; Displays 27887.93</code>
</example>
</fv>
<fwrite>
<summary>
Writes a character string to a file opened with a low-level file function.
</summary>
<param name="nFileHandle">

Specifies the file handle number for the file to which FWRITE( ) writes.

</param>
<param name="cExpression">

Specifies the character expression that FWRITE( ) writes to the file specified with nFileHandle.

</param>
<param name="nCharactersWritten">

FWRITE( ) writes the entire character expression to the file unless you include nCharactersWritten. When you include nCharactersWritten, nCharactersWritten characters are written to the file. If nCharactersWritten is less than the number of characters in cExpression, only nCharactersWritten characters are written to the file. All of the characters in cExpression are written to the file if nCharactersWritten is equal to or greater than the number of characters in cExpression.
</param>
<returns>
Numeric
</returns>
<remarks>
Unlike FPUTS( ), FWRITE( ) doesn't place a carriage return and a line feed at the end of the character string.
FWRITE( ) returns the number of bytes written to the file. If FWRITE( ) can't write to the file for any reason, 0 is returned.
</remarks>
</fwrite>
<getautoincvalue>
<summary>
Returns the last value generated for an autoincremented field within a data session.
</summary>
<param name="nDataSessionNumber">

Specifies the data session number of the data session for which the autoincremented field value is returned.
The autoincremented field value is returned for the current data session if you omit the nDataSessionNumber and 0 parameters.
Use SET DATASESSION to activate a specific data session.

</param>
<param name="0">

Specifies that the last autoincremented field value returned is derived from the current scope (function, method, procedure). Use this to prevent events outside of that current code block, such as ON KEY LABEL, from executing code that could alter the value unexpectedly.
</param>
<returns>
Numeric data type. The value returned by GETAUTOINCVALUE( ) is the last autoincrement value generated, even if a field was not successfully updated with the autoincrement value. .NULL. is returned if an autoincrement value hasn't yet been generated for a data session. For example, .NULL. is returned if a data session is opened and no updates have occurred.
</returns>
<remarks>
The autoincremented field value is updated for table operations such as APPEND Command, INSERT Command, APPEND FROM Command, and BLANK Command when the AUTOINC option is included. See Autoincrementing Field Values in Tables for more information about autoincrementing fields.
</remarks>
</getautoincvalue>
<getbar>
<summary>
Returns the number of an item on a menu defined with DEFINE POPUP or the X# system menu.
</summary>
<param name="MenuItemName">

Specifies the menu item.

</param>
<param name="nMenuPosition">

Specifies a position on the menu. nMenuPosition can range from 1 through the number of items within the menu. 1 corresponds to the first item on the menu, 2 to the second item, and so on.
</param>
<returns>
Numeric
</returns>
<remarks>
Use GETBAR( ) to determine which item occupies a specific position on a menu. This function is useful when items on a menu are added, removed, or rearranged. Use DEFINE BAR to add an item to a menu or RELEASE BAR to remove an item. The position of items in a menu can be changed if MOVER is included when the menu is created with DEFINE POPUP.
</remarks>
<example>
 <code language="X#">CLEAR
ON KEY LABEL CTRL+Z DO showorder
WAIT WINDOW "Press CTRL+Z to refresh." NOWAIT
DEFINE POPUP popDemo MOVER FROM 2,2
DEFINE BAR 1 OF popDemo PROMPT 'One'
DEFINE BAR 2 OF popDemo PROMPT 'Two'
DEFINE BAR 3 OF popDemo PROMPT 'Three'
DEFINE BAR 4 OF popDemo PROMPT 'Four'
DO showorder
ACTIVATE POPUP popDemo
PROCEDURE showorder
CLEAR
@ 3,12 SAY  '1 ' + PRMBAR('popDemo', GETBAR('popDemo',1))
@ 4,12 SAY  '2 ' + PRMBAR('popDemo', GETBAR('popDemo',2))
@ 5,12 SAY  '3 ' + PRMBAR('popDemo', GETBAR('popDemo',3))
@ 6,12 SAY  '4 ' + PRMBAR('popDemo', GETBAR('popDemo',4))
RETURN</code>
</example>
</getbar>
<getcolor>
<summary>
Displays the Windows Color dialog box and returns the color number of the chosen color.
</summary>
<param name="nDefaultColorNumber">

Specifies the color that is initially selected when the Color dialog box is displayed. If nDefaultColorNumber doesn't correspond to a color in the Color dialog box, the first color in the Color dialog box is selected. If you omit nDefaultColorNumber, black is selected.
</param>
<returns>
Numeric
</returns>
<remarks>
GETCOLOR( ) returns – 1 if you exit the Color dialog box by pressing ESC, choosing the Cancel button, or choosing Close from the Control menu.
</remarks>
<example>
 <code language="X#">CLEAR
? GETCOLOR(255)</code>
</example>
</getcolor>
<getcp>
<summary>
Prompts for a code page by displaying the Code Page dialog box, and then returns the number of the code page chosen.
</summary>
<param name="nCodePage">

Specifies the number of the code page that is initially selected when the Code Page dialog box is displayed. If nCodePage is 0 or if you omit nCodePage, a code page isn't selected when the Code Page dialog box is displayed.

</param>
<param name="cText">

Specifies the text displayed in the Code Page dialog box. If you omit cText, X# displays the following text: "Please select a code page for cross-platform data sharing."

</param>
<param name="cDialogTitle">

Specifies the title that appears in the Code Page dialog box title bar. If you omit cDialogTitle, the title "Code Page" is displayed.
</param>
<returns>
Numeric
</returns>
<remarks>
GETCP( ) returns 0 if you exit the Code Page dialog box by pressing ESC, choosing the Cancel button, or choosing Close from the Control menu.
The code pages listed in the Code Page dialog box are determined by FOXPRO.INT, the X# International code page support file.
You can include GETCP( ) in commands such as MODIFY COMMAND, APPEND FROM, and COPY TO that support the AS nCodePage clause. The Code Page dialog box is displayed, making it possible for you to specify the code page of the file opened, appended, or created. Because no code page 0 exists, you must trap for 0 in case the user chooses ESC, the Cancel button, or Close from the Control menu.
</remarks>
<example>
 <code language="X#">? GETCP(1252, "Select a Code Page", "Code Page Selection")</code>
</example>
</getcp>
<getcursoradapter>
<summary>
Returns an object reference to a <b>CursorAdapter</b> object at run time by referencing the cursor name.
</summary>
<param name="cAlias">

Specifies the alias of the cursor. If you do not supply an alias, X# uses the alias for the cursor in the current work area.
</param>
<returns>
An object reference to a <b>CursorAdapter</b> object.
</returns>
<remarks>
Applies To: CursorAdapter Class
</remarks>
</getcursoradapter>
<getdir>
<summary>
Displays the Select Directory dialog box from which you can choose a directory.
</summary>
<param name="cDirectory">

Specifies the directory that is initially displayed in the dialog box. When cDirectory is not specified, the dialog box opens with the X# default directory displayed.

</param>
<param name="cText">

Specifies the text for the directory list in the dialog box.

</param>
<param name="cCaption">

Specifies the caption to display in the dialog title bar. The Windows default is "Select Directory".

</param>
<param name="nFlags">

Specify the options for the dialog box. nFlags can include zero or an additive combination of the values. The following table includes some of more common flags. For more information, see SHBrowseForFolder in MSDN.
1
BIF_RETURNONLYFSDIRS
Return only file system directories (physical locations). If a user selects folders that are not part of the file system, the OK button is grayed. 
2
BIF_DONTGOBELOWDOMAIN
Do not include network folders below the domain level in the tree view control (For example, My Computer and My Networks). 
8
BIF_RETURNFSANCESTORS
Return only file system ancestors. If a user selects anything other than a file system ancestor, the OK button is grayed. 
16
BIF_EDITBOX
The browse dialog includes an edit control in which the user can type the name of an item. Available on Windows 98 and above, or with Internet Explorer 4.0 or higher (assuming shell integration option selected). Requires version 4.71 of shell32.dll.
BIF_VALIDATE
Validates the editbox contents. If the editbox is used, it is necessary to validate the user-specified content. If the user types an invalid name into the edit box, the Cancel button becomes the only selection available. This flag is ignored if BIF_EDITBOX is not specified.
64
BIF_NEWDIALOGSTYLE
Use the new user-interface. Setting this flag provides the user with a larger, resizable dialog box. Additional functionality includes: drag and drop capability within the dialog box, reordering, context menus, new folders, delete, and other context menu commands. Support in Windows 2000 and above. Requires version 5.00 of shell32.dll.
16384
BIF_BROWSEINCLUDEFILES
The browse dialog will display files as well as folders. Available on Windows 98 and above, or with Internet Explorer 4.0 or higher (assuming shell integration option selected). Requires version 4.71 of shell32.dll.

</param>
<param name="lRootOnly">

Specifies that only cDirectory and its subfolders display. This parameter prevents navigation above the root folder. If you do not specify cDirectory, the default directory (SET DEFAULT value) is used.
</param>
<returns>
Character
</returns>
<remarks>
GETDIR( ) returns as a character string the name of the directory you choose.
If you do not choose a directory (you click Cancel, press ESC, or choose Close from the window menu), GETDIR( ) returns the empty string.
Beginning with X# 7, GETDIR( ) supports two different dialog boxes. If you provide fewer than three parameters, GETDIR( ) returns the dialog box from earlier versions. If you provide more than two parameters, X# uses the <b>SHBrowseForFolder </b>routine from the Win32 API to provide the dialog.
</remarks>
</getdir>
<getenv>
<summary>
Returns the contents of the specified MS-DOS environment variable.
</summary>
<param name="cVariableName">

Specifies the name of the environment variable. The empty string is returned if the environment variable you specify doesn't exist.
You can locate the Windows directory with the WINDIR environmental variable, which Windows sets when it starts.
</param>
<returns>
Character
</returns>
<remarks>
Two environment variables are always available: COMSPEC and PATH. You can create your own environment variables with the command shell SET command.
For additional information on creating environment variables, see the Windows product documentation.
</remarks>
<example>
 <code language="X#">CLEAR
? GETENV('PATH')  &amp;&amp; Displays the search path</code>
</example>
</getenv>
<getfile>
<summary>
Displays the Open dialog box.
</summary>
<param name="cFileExtensions">

Specifies the file name extensions for the files to display in the Open dialog box when the All Files type is not chosen. When passing a value as a literal, enclose it with quotation marks (""). Do not include a period (.) in front of file name extensions.
The cFileExtensions parameter cannot exceed 254 characters in length. 
cFileExtensions can take a variety of forms:
If cFileExtensions contains a single extension, for example, "prg", the Open dialog box displays only those file names with that extension.
If cFileExtensions is the empty string, the Open dialog box displays all files in the current directory.
cFileExtensions can contain wildcard characters such as * and ?. The Open dialog box displays all file names with extensions that meet the wildcard criteria. For example, if cFileExtensions is "?X?", the Open dialog box displays all file names with the extension .fxp, .exe, and .txt.
cFileExtensions can contain a file description followed by a file extension or a list of file extensions separated with commas. The file description appears in the Open dialog box in the Files of Type list. Separate the file description from the file extension or list of file extensions with a colon (:). Separate multiple file descriptions and their file extensions with a semicolon (;). 
For example, if cFileExtensions is "Text:TXT", the Open dialog box displays the file description "Text" in the Files of Type list and displays all files with a .txt extension.
If cFileExtensions is "Tables:DBF; Files:TXT,BAK" the file descriptions "Tables" and "Files" appear in the Files of Type list. When "Tables" is chosen from the Files of Type list, all files with a .dbf extension are displayed. When "Files" is chosen from the Files of Type list, all files with .txt and .bak extensions are displayed. 
If cFileExtensions contains just a semicolon (";"), the Open dialog box displays all files without extensions.

</param>
<param name="cText">

Specifies text to display for the File Name label in the Open dialog box.

</param>
<param name="cOpenButtonCaption">

Specifies a caption for the OK button in the Open dialog box.

</param>
<param name="nButtonType">

Specifies the number and type of buttons that appear in the Open dialog box. The following table lists the values for nButtonType.
0 (or omitted)
OK, Cancel
1
OK, New, Cancel
2
OK, None, Cancel
GETFILE( ) returns the string "Untitled" with the path specified in the Open dialog box when nButtonType is set to 1 and the user clicks New, or when nButtonType is set to 2 and the user clicks None.

</param>
<param name="cTitleBarCaption">

Specifies the caption for the title bar of the Open dialog box.
</param>
<returns>
Character. GETFILE( ) returns the name of the file chosen in the Open dialog box or the empty string if the user closes the Open dialog box by pressing ESC, clicking Cancel or the Close button on the Open dialog box.
</returns>
<example>
 <code language="X#">CLOSE DATABASES
SELECT 0
gcTable=GETFILE('DBF', 'Browse or Create a .DBF:',
'Browse', 1, 'Browse or Create')
DO CASE
CASE 'Untitled' $ gcTable
CREATE (gcTable)
CASE EMPTY(gcTable)
RETURN
OTHERWISE
USE (gcTable)
BROWSE
ENDCASE</code>
</example>
</getfile>
<getfldstate>
<summary>
Returns a numeric value indicating if a field in a table or cursor has been modified or had a record appended, or if the deleted status of the current record has been changed.
</summary>
<param name="cTableAlias">

Specifies the alias of the table or cursor for which the field modification or record deletion status is returned.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor for which the field modification or record deletion status is returned.
If you do not specify an alias or work area, GETFLDSTATE( ) returns a value for a field in the currently selected table or cursor.
</param>
<returns>
Numeric, Character, or .NULL.
</returns>
<remarks>
The following table lists the character return values and the corresponding modification or deletion status.
1
Field has not been modified or deletion status has not changed.
2
Field has been modified or deletion status has changed.
3
Field in an appended record has not been modified or deletion status has not changed for the appended record.
4
Field in an appended record has been modified or deletion status has changed for the appended record.
.NULL.
At EOF( )
Row or table buffering must first be enabled with CURSORSETPROP( ) for GETFLDSTATE( ) to operate on local tables.
The modification or deletion status is returned for the table or cursor open in the currently selected work area if GETFLDSTATE( ) is issued without the optional cTableAlias or nWorkArea arguments.
Any change in a field will cause GETFLDSTATE() to return a value showing that the field has been modified, whether the change is explicit or implicit. An example of an explicit modification would be including the field in a REPLACE or INSERT INTO command. An implicit modification occurs in a field that has a default value when any command is issued that adds a new record.
The following example demonstrates how you can use GETFLDSTATE( ) to determine if the contents of a field have changed. MULTILOCKS is set to ON, a requirement for table buffering. The codecustomer/code table in the codetestdata/code database is opened, and CURSORSETPROP( ) is then used to set the buffering mode to optimistic table buffering (5).
GETFLDSTATE( ) is issued to display a value (1) corresponding to the unmodified state of the codecust_id/code field before it is modified. The codecust_id/code field is modified with REPLACE, and GETFLDSTATE( ) is issued again to display a value (2) corresponding to the modified state of the codecust_id/code field. TABLEREVERT( ) is used to return the table to its original state, and GETFLDSTATE( ) is issued again to display a value (1) corresponding to the original state of the codecust_id/code field.
 <code language="X#">CLOSE DATABASES
CLEAR
SET MULTILOCKS ON         &amp;&amp; Allow table buffering
OPEN DATABASE (HOME(2) + 'data\testdata')
USE Customer             &amp;&amp; Open customer table
=CURSORSETPROP("Buffering",5,"customer")  &amp;&amp; Enable table buffering
* Get field state on original cust_id field and display state
nState=<b>GETFLDSTATE(</b>"cust_id"<b>)</b>
DO DisplayState WITH nState, "Original"
* Change field contents and display state
REPLACE cust_id    WITH "***"
nState=<b>GETFLDSTATE(</b>"cust_id"<b>)</b>
DO DisplayState WITH nState, "After Replace"
* Discard table changes and display state
= TABLEREVERT(.T.)        &amp;&amp; Discard all table changes
nState=<b>GETFLDSTATE(</b>"cust_id"<b>)</b>
DO DisplayState WITH nState, "After Revert"
PROCEDURE DisplayState
PARAMETER nState,cOperation
DO CASE
CASE nState=1
=MESSAGEBOX("Field has not been modified",0,cOperation)
OTHERWISE
=MESSAGEBOX("Field has been modified",0,cOperation)
ENDCASE
</code>
The following example shows the difference in behavior between fields with and without default values.
 <code language="X#">SET MULTILOCKS ON
CREATE DATABASE example
CREATE TABLE customer (cust_id C(6),state C(2) DEFAULT "FL")
CLOSE TABLES
USE customer
=CURSORSETPROP("Buffering",5,"customer")
APPEND BLANK
?GETFLDSTATE("cust_id")     &amp;&amp; Returns 3, field in an appended record has
&amp;&amp; not been modified.
?GETFLDSTATE("state")    &amp;&amp; Returns 4, field in an appended record has
&amp;&amp; been modified.
</code>
</remarks>
</getfldstate>
<getfont>
<summary>
Displays the Font dialog box and returns information about the font you choose.
</summary>
<param name="cFontName">

Specifies the name of the font initially selected in the Font dialog box. If the font you specify is not installed, the default font is selected initially.

</param>
<param name="nFontSize">

Specifies the font size selected initially in the Font dialog box. If the font size you specify is not supported, the default font size is selected initially. If you omit nFontSize or if nFontSize is less than or equal to zero, the font size selected defaults to 10 point.
The dialog box permits you to select sizes between code4/code and code127/code, inclusive. You can specify other values for nFontSize when calling the <b>GETFONT</b> function; no error occurs.  If you do so, however, the user must select a size within the designated range of values before clicking <b>OK</b> in the dialog box.  Otherwise, the dialog box displays an alert and does not accept the value.  

</param>
<param name="cFontStyle">

Specifies the font style selected initially in the Font dialog box or to display only those fonts available on the selected printer. If the font style you specify is not supported, the default font style is selected initially.
The following table lists the values available for cFontStyle.   
B
Select Bold font style initially.
Select Italic font style initially.
BI
Select Bold Italic font style initially.
P
Display only those fonts available on the current default printer.

</param>
<param name="nFontCharSet">

Specifies a value for the language script. The values you can specify differ depending on your version of Windows.
Omitting this value disables the script drop-down list in the dialog box. 
The following table describes some example values for nFontCharSet.
nFontCharSet
0
Western
1
Default
2
Symbol
128
Japanese
161
Greek
162
Turkish
163
Vietnamese
177
Hebrew
178
Arabic
186
Baltic
204
Cyrillic
238
Central European
If you specify 1 for nFontCharSet, the dialog box that <b>GETFONT( )</b> opened displays the default language script on the operating system. <b>GETFONT( )</b> never returns 1 because it returns the value for the language script selected in the <b>GETFONT( )</b> dialog box.
For more information, see FontCharSet Property.
</param>
<returns>
Character. <b>GETFONT( )</b> returns one of the following, depending on certain conditions:
A character string containing three types of font information with commas separating the items returned: font name, size and style.  This behavior occurs when you choose one in the Font dialog box and you have not included the fourth optional argument when calling the <b>GETFONT( )</b> function.
A character string containing four types of font information with commas separating the items returned: font name, size, style and language script.  This behavior occurs if you include a value for the nFontCharSet parameter.
In versions of X# previous to X# 9.0, if you included a value of code0/code as the fourth argument to <b>GETFONT()</b>, you received the same return information as if you did not include the fourth argument at all.  The script drop-down list was not enabled, and the return value contained only three types of font information. In X# 9.0, a value of code0/code explicitly indicates the numeric value corresponding to Western script.  The script drop-down list might also initially display Western if you specify code1/code for this value, but only if Western is the default script for your regional settings.
An empty string if you exit the Font dialog box by clicking <b>Cancel</b>, <b>Close</b> on the Control menu, or pressing the <b>ESC</b> key.
</returns>
<remarks>
You can abbreviate some X# commands and functions to four characters when conflicts with other commands and functions do not exist. In the case of <b>GETFONT( )</b> and <b>GETFILE( )</b>, which both begin with the same four letters, precedence is given to <b>GETFILE( )</b>; therefore, issuing codeGETF( )/code displays the <b>Open</b> dialog box.
</remarks>
<example>
 <code language="X#">* Invoke the dialog with script drop-down list disabled:
? GETFONT("Arial",12,"B") &amp;&amp; press OK in the dialog box
* return value is the string:
* "Arial,12,B"
* Enable the script drop-down list, Western script selected:
? GETFONT("Arial",12,"B",0) &amp;&amp; press OK after selections
* sample return value is the string:
* "Verdana,16,N,161"
* Return from the dialog box without making a selection:
? GETFONT("Arial",12,"B") &amp;&amp; press Cancel in the dialog box
* return value is an empty string
? GETFONT("Arial",12,"B",0) &amp;&amp; press Cancel in the dialog box
* return value is still an empty string
</code>
</example>
</getfont>
<getinterface>
<summary>
Provides access to COM object properties, methods, and events through early binding.
</summary>
<param name="oObject">

Specifies the target COM object.

</param>
<param name="cIID">

Specifies the GUID of the target interface of oObject. cIID can be an interface such as "IContextState" or it can be a GUID, such as "{94631BEC-EE81-479A-AE64-A6CFC37B4799}". If it's "IDispatch", then GetInterface() returns an IDispatch (late-bound) reference to the object. If cIID is not specified, then GetInterface() will return the early binding interface for the object.

</param>
<param name="cInterface">

Specifies the interface name.

</param>
<param name="cTypelib">

Specifies the name of the type library containing the oObject class.

</param>
<param name="cProgID">

Specifies the name of the program to be used to lookup the type library.
COM Object Interface reference
</param>
<remarks>
GetInterface( ) applies only to COM objects. If you use native X# objects, GetInterface( ) generates an error. GetInterface( ) returns an early-bound Object reference.
When a DLL is built on a Windows 95, Windows 98, or Windows Me platform, X# does not include the type library inside the DLL. When you use GETINTERFACE( ) and refer to a DLL built on one of these platforms, you must use the Type Library name instead of the DLL name as in the following code:
 <code language="X#">oX = GETINTERFACE(x, "Imyclass", "myclass1.TLB")</code>
You can use the following code for a DLL built on Windows XP, Windows 2000, or Windows NT:
 <code language="X#">oX = GETINTERFACE(x, "Imyclass", "myclass1.DLL")</code>
</remarks>
<example>
 <code language="X#">LOCAL oMTX, oContext, oContextState
LOCAL lTxnState, lGetTxnState, lDone, lGetDone
lGetDone = .F.     &amp;&amp; initialize setting
lGetTxnState = 0  &amp;&amp; initialize setting
oMTX = CREATEOBJECT("MTXAS.APPSERVER.1")
oContext = oMTX.GetObjectContext()
oContextState = GetInterface(oContext,"IContextState")
* Handle activation setting (Doneness)
* Values: .T. - Deactivate, .F. - Leave activated
lDone = .T.
oContextState.SetDeactivateOnReturn(lDone)
oContextState.GetDeactivateOnReturn(@lGetDone)

* Handle transaction setting (Consistency)
* Values: 0 - commit, 1 - abort
lTxnState = 1
oContextState.SetMyTransactionVote(lTxnState)
oContextState.GetMyTransactionVote(@lGetTxnState)</code>
</example>
</getinterface>
<getnextmodified>
<summary>
Returns the record number for the next modified record in a buffered table or cursor.
</summary>
<param name="nRecordNumber">

Specifies the record number after which <b>GETNEXTMODIFIED( )</b> searches for the next modified record. Specify 0 for nRecordNumber to determine the first record in the table or cursor that has been modified.

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor for which <b>GETNEXTMODIFIED( )</b> returns the number of the next modified record.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor for which <b>GETNEXTMODIFIED( )</b> returns the number of the next modified record.
If you do not specify an alias or work area, <b>GETNEXTMODIFIED( )</b> returns the record number for the next modified record in the currently selected table or cursor. 

</param>
<param name="lNoFire">

Specifies that all firing of rules are suppressed.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>GETNEXTMODIFIED( )</b> returns 0 if there are no modified records after the record you specify. Because of this, if you modify only one record, to verify its modification you must first use the <b>GO TOP</b> command to position the cursor before the changed record. A record is considered modified if the contents of any of its fields are changed in any way (even if the original field contents are restored) or the record's deletion status is changed.

<b>GETNEXTMODIFIED( )</b> can operate only on tables and cursors for which table buffering is enabled. Table buffering is enabled with <b>CURSORSETPROP( )</b>.
Since triggers are unaffected by <b>GETNEXTMODIFIED( )</b>, lNoFire suppresses only field and record rules, and the "Uniqueness of index ID is violated" error. lNoFire prevents the flushing of temporary data, such as data stored in controls or updates made to the current record, to the underlying cursor.
</remarks>
<example>
 <code language="X#">LOCAL lnCurRec
CLEAR
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE Customer
* Enable table buffering.
SET MULTILOCKS ON
=CURSORSETPROP("Buffering", 5, "customer")
* Increase MAXORDAMT by 10% for customers in Mexico.
UPDATE Customer SET MaxOrdAmt=MaxOrdAmt * 1.1 WHERE Country = "Mexico"
* Start with the first modified record.
lnCurRec = <b>GETNEXTMODIFIED</b>(0)
* DO until all modified records are processed.
DO WHILE .T.
* Move to the current modified record.
GOTO (m.lnCurRec)
* Process modified row here.
? Customer.Company, Customer.MaxOrdAmt
IF Customer.MaxOrdAmt &gt; 8500
=TABLEREVERT(.F.)
ENDIF
?? Customer.MaxOrdAmt
* Get the next modified record from here.
lnCurRec = <b>GETNEXTMODIFIED</b>(m.lnCurRec)
IF m.lnCurRec = 0 &amp;&amp; No more modified records.
EXIT
ENDIF
ENDDO
=TABLEREVERT(.T.)  &amp;&amp; Restore sample data and discard all changes.</code>
</example>
</getnextmodified>
<getobject>
<summary>
Activates an Automation object and creates a reference to the object.
</summary>
<param name="cFileName">

Specifies the full path and name of the file to activate. The application does not need to be specified, because the OLE dynamic link libraries determine the application to start based on the file name you provide.
For example, the following code launches Microsoft Excel, opens a file named BUDGET.XLS, and creates a reference through an object variable named MBUDVAR:   
 <code language="X#">MBUDVAR = GETOBJECT('C:\EXCEL\WORK\BUDGET.XLS')</code>
Moniker 
The identifier of a COM object that implements the IMoniker interface. A moniker can be any of the following types: file, item, generic composite, anti-, pointer, and URL. For details about COM monikers, search for "IMoniker" on the Microsoft Developer Network.
</param>
<param name="cClassName">

Specifies the class name of the object to retrieve. Some applications can store more than one object type in the same file, making it possible for you to use the class name to specify the object to activate. For example, if a word processing application stores its documents, macro definitions, and ToolBar objects in the same file, you can create a reference to the document file with the following command:  
 <code language="X#">MDOCFILE = GETOBJECT('C:\WRDPROC\MYDOC.DOC','WrdProc.Document')</code>
With some server applications, each time you issue <b>GETOBJECT( )</b>, an additional instance of the application is started, using additional memory. If the application is already running, you can prevent additional instances of the application from starting by omitting FileName and including ClassName, as in this example:   
 <code language="X#">oleApp = GETOBJECT(, "Excel.Application")</code>
Object reference
</param>
<remarks>
Use <b>GETOBJECT( )</b> to activate an Automation object from a file and to assign a reference to the object through a memory variable or array element.
If you specify an invalid file or class name, an OLE error is displayed, and the <b>GETOBJECT( )</b> function returns an empty string.
</remarks>
<example>
 <code language="X#">   *  Replace "DomainName" with the domain name, and "UserLoginID"
*  with the login ID of the user you are looking up.
oUser = GetObject("WinNT://DomainName/UserLoginID,user")
? oUser.FullName</code>
</example>
</getobject>
<getpad>
<summary>
Returns the menu title for a given position on the menu bar.
</summary>
<param name="cMenuBarName">

Specifies the menu bar name.

</param>
<param name="nMenuBarPosition">

Specifies a position on the menu bar. nMenuPosition can range from 1 (the leftmost menu title on the menu bar) through the number of menu titles on the menu bar.
</param>
<returns>
Character
</returns>
<remarks>
Menu names on a titles bar can be added, removed, or rearranged. Use DEFINE PAD to add a menu name to a title bar or RELEASE PAD to remove a menu title.
</remarks>
<example>
 <code language="X#">FOR gnCount = 1 TO CNTPAD('_msysmenu')      &amp;&amp; Number of pads
IF PRMPAD('_msysmenu', GETPAD('_msysmenu', gnCount)) = 'Edit'
RELEASE PAD (GETPAD('_msysmenu', gnCount)) OF _msysmenu
EXIT
ENDIF
ENDFOR</code>
</example>
</getpad>
<getpem>
<summary>
Returns the current value for a property or program code for an event or method at design time.
</summary>
<param name="oObjectName">

Specifies the object for which a property value or event or method program code is returned. oObjectName can be any expression that evaluates to an object, such as an object reference, an object memory variable, or an object array element.

</param>
<param name="cClassName">

Specifies the class for which a property value or event or method program code is returned.

</param>
<param name="cProperty">

Specifies the property whose value is returned.

</param>
<param name="cEvent">

Specifies the event for which program code is returned.

</param>
<param name="cMethod">

Specifies the method for which program code is returned.
</param>
<returns>
Character, Currency, Date, DateTime, Numeric, or Logical
</returns>
<remarks>
In X# 6.0 and later, using <b>GETPEM( )</b> to return method code is supported only during an interactive X# session. You can, however, obtain method code from an object by using its Class property, as in the following code:
 <code language="X#">LOCAL oObject, lcCode
oObject = NEWOBJECT("_form", HOME()+"ffc\_base.vcx")
lcCode = GETPEM(oObject.class, "Release")</code>
</remarks>
</getpem>
<getpict>
<summary>
Displays the Open Picture dialog box and returns the name of the picture file you chose.
You can preview images in Windows 2000 and later by clicking the View Menu icon and then Thumbnails. X# uses the Thumbnails view as the default setting to provide mini-previews of images. Therefore, the Open Picture dialog box no longer includes a frame for displaying an image. The Preview check box appears in the Open Picture dialog box only when running X# on operating systems earlier than Windows 2000.
</summary>
<param name="cFileExtensions">

Specifies the file extensions of the picture files displayed in the scrollable list when the All Files menu item isn't chosen.
cFileExtensions can take the following forms:   
If cFileExtensions contains a single extension (for example, .bmp), only files with that extension are displayed.
cFileExtensions can also contain wildcards (* and ?). All files with extensions that meet the wildcard criteria are displayed. For example, if cFileExtensions is ?X?, all files with the extension .fxp, .exe, and .txt are displayed.
If cFileExtensions contains an empty string (""), all available graphics files (for example, files with the extensions .bmp and .dib ) are displayed.

</param>
<param name="CFileNameCaption">

Specifies the caption displayed to the left of the File Name text box. cFileNameCaption replaces "File Name" that appears when cFileNameCaption is omitted.

</param>
<param name="cOpenButtonCaption">

Specifies a caption for the OK button.
</param>
<returns>
Character data type. Returns the name of the picture file you chose.
</returns>
<remarks>
The GETPICT( ) function returns the empty string if you exit the Open Picture dialog box by pressing ESC, choosing the Cancel button, or clicking the Close button. The Open Picture dialog box displayed by typing <b>GETPICT( )</b> in the Command window makes it possible for you to quickly locate all the graphic files supported in X#. In versions earlier than X# 8.0, check the Preview check box in the Picture Open dialog box to display the currently selected graphics file.
The following table lists the graphic file formats that X# supports.
Animated Cursor
.ani
Bitmap
.bmp
Cursor
.cur
Device Independent Bitmap
.dib
Exchangeable Image File
.exif
Graphics Interchange Format
.gif, .gfa
Joint Photographic Electronic Group, JPEG File Interchange Format
.jpg, .jpeg, .jpe, .jfif
Icon
.ico
Portable Networks Graphics
.png
Tag Image File Format
.tif, .tiff
Windows Enhanced Metafile
.emf
In X#, cursor, animated cursor, and icon files can be used as graphics files. For example, you can specify an animated cursor file for the Picture property for the Image control (however, the Image control displays the static representation of the cursor).
Use the CLEAR RESOURCES command to clear all cached graphic files, including .gif and .jpg files.
</remarks>
</getpict>
<getprinter>
<summary>
Displays the Printer dialog box and returns the name of the selected printer.
</summary>
<returns>
GETPRINTER( )Return Value
Character. <b>GETPRINTER( )</b> returns the name of the selected printer. If you exit the Printer dialog box by pressing ESC or by clicking Cancel or Close, <b>GETPRINTER( )</b> returns an empty string.
</returns>
<remarks>
The contents of the Printer dialog box can differ between versions of Windows. For example, the Printer dialog box might contain only the printer name or include a network path.
</remarks>
<example>
 <code language="X#">CLEAR
cPrinter = GETPRINTER( )
WAIT WINDOW IIF(EMPTY(cPrinter), 'No printer chosen', cPrinter)</code>
</example>
</getprinter>
<getresultset>
<summary>
Retrieves the work area number of a cursor marked by <b>SETRESULTSET( )</b> in the current data session.
</summary>
<returns>
GETRESULTSET( )Return Value
Numeric. <b>GETRESULTSET( )</b> returns the work area number of the marked cursor in the current data session or zero (0) if no cursor is marked in the current data session.
</returns>
<remarks>

<b>GETRESULTSET( )</b> is supported in X# and the X# OLE DB Provider. You can use <b>GETRESULTSET( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider. 
</remarks>
</getresultset>
<getwordcount>
<summary>
Counts the words in a string.
</summary>
<param name="cString">

Specifies the string whose words will be counted.

</param>
<param name="cDelimiters">

Optional. Specifies one or more optional characters used to separate words in cString. The default delimiters are space, tab, carriage return, and line feed. Note that <b>GetWordCount( )</b> uses each of the characters in cDelimiters as individual delimiters, not the entire string as a single delimiter.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>GetWordCount( )</b> by default assumes that words are delimited by spaces or tabs. If you specify another character as delimiter, this function ignores spaces and tabs and uses only the specified character.
If you use "AAA aaa, BBB bbb, CCC ccc." as the target string for <b>GetWordCount( ),</b> you can get all the following results.
 <code language="X#">cString = "AAA aaa, BBB bbb, CCC ccc."
? GetWordCount(cString)               &amp;&amp; 6 - character groups, delimited by " "
? GetWordCount(cString, ",")               &amp;&amp; 3 - character groups, delimited by ","
? GetWordCount(cString, ".")               &amp;&amp; 1 - character group, delimited by "."</code>
</remarks>
</getwordcount>
<getwordnum>
<summary>
Returns a specified word from a string.
</summary>
<param name="cString">

Specifies the string to be evaluated

</param>
<param name="nIndex">

Specifies the index position of the word to be returned. For example, if nIndex is 3, <b>GetWordNum( )</b> returns the third word (if cString contains three or more words).

</param>
<param name="cDelimiters">

Optional. Specifies one or more optional characters used to separate words in cString. The default delimiters are space, tab, carriage return, and line feed. Note that <b>GetWordNum( )</b> uses each of the characters in cDelimiters as individual delimiters, not the entire string as a single delimiter.
</param>
<returns>
Character
</returns>
<remarks>
Returns the word at the position specified by nIndex in the target string, cString. If cString contains fewer than nIndex words, <b>GetWordNum( )</b> returns an empty string.
</remarks>
</getwordnum>
<gomonth>
<summary>
Returns the date that is a specified number of months before or after a given Date or Date/Time expression.
</summary>
<returns>
Date
</returns>
<remarks>
GOMONTH( ) does not support dates earlier than 1753. 
</remarks>
<example>
 <code language="X#">SET CENTURY ON
STORE GOMONTH({^1998-02-16}, 5) TO gdDeadLine
CLEAR
? gdDeadLine  &amp;&amp; Displays 07/16/1998
? GOMONTH({^1998-12-31}, 2)  &amp;&amp; Displays 02/28/1999
? GOMONTH({^1998-12-31}, -2)  &amp;&amp; Displays 10/31/1998</code>
</example>
</gomonth>
<header>
<summary>
Returns the number of bytes in the header of the current or specified table file.
</summary>
<returns>
Numeric
</returns>
<remarks>
A table header contains information about the table itself, such as the field names and sizes and the presence of a memo file or structural index.
</remarks>
</header>
<home>
<summary>
Returns the names of the X# and Visual Studio directories.
</summary>
<param name="nLocation">

Specifies that <b>HOME( )</b> returns the name of a specific X# or Visual Studio directory. Omitting nLocation is identical to HOME(0).
The following table lists the values for nLocation and the directory that <b>HOME( )</b> returns. The directories listed below assume that you chose the default installation directory when you installed X# or Visual Studio.   
0 or omitted
The directory from which X# was started
1
The directory in which X# is installed
2
The directory containing the X# samples. This directory is identical to the samples directory in the _SAMPLES system variable.
Visual Studio Common directory
X# Graphics directory
5
Visual Studio MSDN directory
Visual Studio Tools directory
7
X# subdirectory in the user's X# Application Data directory
X# Projects subdirectory in the user's X# My Documents directory. This directory is the default location for new projects and files created by X#.
</param>
<returns>
Character data type. <b>HOME( )</b> returns the names of specific X# and Visual Studio directories.
</returns>
<example>
 <code language="X#">CLEAR
? 'X# startup directory:           ', HOME( )
? 'X# installation directory:      ', HOME(1)
? 'X# samples directory:           ', HOME(2)
? 'Visual Studio common directory:            ', HOME(3)
? 'X# graphics directory:          ', HOME(4)
? 'MSDN samples directory:                    ', HOME(5)
? 'Visual Studio tools directory:             ', HOME(6)
? 'X# user app data subdirectory:  ', HOME(7)
? 'X# user documents subdirectory: ', HOME(8)</code>
</example>
</home>

<idxcollate>
<summary>
Returns the collating sequence for an index or index tag.
</summary>
<param name="cCDXFileName">

Specifies the name of the compound index file. The compound index file you specify can be the structural compound index file automatically opened with the table or an independent compound index file.

</param>
<param name="nIndexNumber">

Specifies the index or index tag for which <b>IDXCOLLATE( )</b> returns the collating sequence. <b>IDXCOLLATE( )</b> returns the collating sequence for indexes and index tags in the following order as nIndexNumber increases from 1 to the total number of open index files and index tags:
Collating sequences for single-entry .idx index files (if any are open) are returned first. The order in which the single-entry index files are included in <b>USE</b> or <b>SET INDEX</b> determines how the collating sequences are returned.
Collation sequences for tags in the structural compound index (if one is present) are returned next. The collating sequences are returned for the tags in the order in which the tags are created in the structural compound index.
Collating sequences for tags in any open independent compound indexes are returned last. The collation sequences are returned for the tags in the order in which the tags are created in the independent compound indexes.
The empty string is returned if nIndexNumber is greater than the total number of open single-entry .idx files and structural compound and independent compound index tags. 

</param>
<param name="nWorkArea">

Specifies the work area of the table for which <b>IDXCOLLATE( )</b> returns index file and index tag collating sequences.
<b>IDXCOLLATE( )</b> returns the empty string if a table isn't open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which <b>IDXCOLLATE( )</b> returns index file and index tag collation sequences.
X# generates an error message if you specify a table alias that doesn't exist.
</param>
<returns>
Character
</returns>
<remarks>

<b>IDXCOLLATE( )</b> can be used to return the collating sequence for each tag in multiple-entry compound index files, allowing you to completely delete an index file and rebuild it correctly, using a series of <b>SET COLLATE</b> and <b>INDEX</b> commands.
Note that IDXCOLLATE( ) is not required for the proper functioning of <b>REINDEX</b>, because the collation sequence information is present in existing indexes and index tags.
For additional information about X#'s international support, see Developing International Applications.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer     &amp;&amp; Open Customer table.
CLEAR
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index.
? TAG(nCount) + ' '  &amp;&amp; Display tag name.
?? IDXCOLLATE(nCount)  &amp;&amp; Display collation sequence.
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found.
ENDIF
ENDFOR</code>
</example>
</idxcollate>
<iif>
<summary>
Returns one of two values depending on the value of a logical expression.
</summary>
<param name="lExpression">

Specifies the logical expression that <b>IIF( )</b> evaluates.

eExpression1, eExpression2
If lExpression evaluates to True (.T.), eExpression1 is returned and eExpression2 is not evaluated. If lExpression evaluates to False (.F.) or null (.NULL.), eExpression2 is returned and eExpression1 is not evaluated.
</param>
<returns>
Character, Numeric, Currency, Date, or DateTime
</returns>
<remarks>
This function, also known as Immediate <b>IF</b>, evaluates a logical expression and then returns one of two expressions. If the logical expression evaluates to True (.T.), <b>IIF( )</b> returns the first expression. If the logical expression evaluates to False (.F.) or null (.NULL.), <b>IIF( )</b> returns the second expression.
This function can be used in place of <b>IF ... ENDIF</b> for simple conditional expressions, and is especially useful in report and label expressions that conditionally specify field contents. The <b>IIF( )</b> function also executes faster than an equivalent <b>IF ... ENDIF</b>.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE employee  &amp;&amp; Open Employee table
CLEAR
SCAN
? IIF(EMPTY(notes), 'No notes', notes)    &amp;&amp; Empty memo field?
ENDSCAN</code>
</example>
</iif>
<imestatus>
<summary>
Turns the IME (Input Method Editor) window on or off or returns the current IME status.
</summary>
<param name="nExpression">

Turns the IME window on or off. The following table lists the values for nExpression and the corresponding state of the IME window.
0
Turns the IME window off.
1
Turns the IME window on.
If nExpression is omitted, <b>IMESTATUS( )</b> returns the current IME status. The following table lists the values returned for the IME status. Use VERSION(3) to determine the current locale.   
The following table lists the values returned for the IME status in the Japanese locale.   
No IME installed
IME on
IME off
IME disabled
Hiragana mode (double-byte)
Katakana mode (double-byte)
Katakana mode (single-byte)
Alphanumeric mode (double-byte)
8
Alphanumeric mode (single-byte)
The following table lists the values returned for the IME status in the Korean locale.   
Hangul mode (single-byte)
English mode (single-byte)
English mode (double-byte)
Hangul mode (double-byte)
Hanja conversion mode (Hangul + single-byte mode)
31
Hanja conversion mode (Hangul + double-byte mode)
</param>
<returns>
Numeric
</returns>
<remarks>
For more information, see Developing International Applications.
This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
</remarks>
</imestatus>
<indbc>
<summary>
Returns true (.T.) if the specified database object is in the current database; otherwise returns false (.F.).
</summary>
<param name="cDatabaseObjectName">

Specifies the name of a named connection, field, index, table, or SQL view for which INDBC( ) returns a logical value indicating whether or not the object is in the current database.

</param>
<param name="cType">

Specifies the database object type of cDatabaseObjectName. The following table lists the values for cType and the corresponding database object type.
CONNECTION
Named connection
FIELD
Field
INDEX
Index
TABLE
Table
VIEW
SQL View
The CONNECTION, FIELD, INDEX, TABLE, and VIEW settings cannot be abbreviated.
</param>
<returns>
Logical
</returns>
<remarks>
A database must be open and current when <b>INDBC( )</b> is issued; otherwise X# generates an error message.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CREATE DATABASE mydbc  &amp;&amp; Creates a new database
CREATE TABLE mytable (field1 C(10)) &amp;&amp; Automatically added to database
? 'MyTable in the database? '
?? INDBC('mytable', 'TABLE')  &amp;&amp; Returns .T.
CLOSE DATABASES
DELETE DATABASE mydbc DELETETABLES</code>
</example>
</indbc>
<indexseek>
<summary>
Without moving the record pointer, searches an indexed table for the first occurrence of a record whose index key matches a specified expression.
</summary>
<param name="eExpression">

Specifies the index key expression for which you want INDEXSEEK( ) to search.

</param>
<param name="lMovePointer">

Specifies if the record pointer is moved to the matching record. If lMovePointer is true (.T.) and a matching record exists, the record pointer is moved to the matching record. If lMovePointer is true (.T.) and a matching record doesn't exist, the record pointer isn't moved. If lMovePointer is false (.F.) or is omitted, the record pointer isn't moved even if a matching record exists.

</param>
<param name="nWorkArea">

Specifies the work area number of the table that is searched for the index key.

</param>
<param name="cTableAlias">

Specifies the alias of the table that is searched. If you omit nWorkArea and cTableAlias, the table in the currently selected work area is searched.

</param>
<param name="nIndexNumber">

Specifies the number of the index file or tag that is used to search for the index key. nIndexNumber refers to the index files as they are listed in USE or SET INDEX. Open .IDX files are numbered first in the order in which they appear in USE or SET INDEX. Tags in the structural .cdx file (if one exists) are then numbered in the order in which they were created. Finally, tags in any open independent .cdx files are numbered in the order in which they were created. For more information about index numbering, see SET ORDER.

</param>
<param name="cIDXIndexFileName">

Specifies an .idx file that is used to search for the index key.

</param>
<param name="cTagName">

Specifies a tag of a .cdx file that is used to search for the index key. The tag name can be from a structural .cdx file or any open independent .cdx file.
The .idx file takes precedence if duplicate .idx file and tag names exist.
</param>
<returns>
Logical
</returns>
<remarks>

<b>INDEXSEEK( )</b> returns true (.T.) if a match is found; otherwise false (.F.) is returned. You can use <b>INDEXSEEK( )</b> only with a table with an index order set, and you can search only for an index key. The match must be exact unless <b>SET EXACT</b> is set to OFF.

<b>INDEXSEEK( )</b> provides a fast way to search for records without moving the record pointer. Because the record pointer isn't moved, rules and triggers aren't executed. If <b>INDEXSEEK( )</b> returns true (.T.) indicating that a matching record is found, you can execute <b>INDEXSEEK( )</b> again with the second parameter lMovePointer set to true (.T.) to move to the matching record.

<b>INDEXSEEK( )</b> returns false (.F.) when you are attempting to find a value in the most recently created record (created with <b>INSERT INTO</b> or <b>APPEND BLANK</b>) until the record pointer is moved. You can execute a <b>GO BOTTOM</b> command to cause <b>INDEXSEEK( )</b> to find the most recently created record.
</remarks>
</indexseek>
<inkey>
<summary>
Returns a number corresponding to the first mouse click or key press in the type-ahead buffer.
</summary>
<param name="nSeconds">

Specifies the number of seconds to wait for a keystroke. If you do not specify a value for nSeconds, <b>INKEY( )</b> returns a value for a keystroke immediately. If nSeconds is 0, <b>INKEY( )</b> waits indefinitely for a keystroke.

</param>
<param name="cHideCursor">

Shows or hides the cursor, or checks for a mouse click. 
The following table lists values for cHideCursor.   
Show cursor.
Hide cursor.
M
Check for a mouse click.
E
Expand the keyboard macro if a keyboard macro is assigned to a key or key combination. To return successive values for each keystroke in a macro, execute <b>INKEY( )</b> repeatedly with E included. 
If both S and H are included in cHideCursor, the latter character specified takes precedence. You can combine values for cHideCursor, for example, to check for a mouse click and show the cursor, include M and S. To check for a mouse click and hide the cursor, include H and M. <b>INKEY( )</b> disregards characters other than S, H, M, and E in cHideCursor.
</param>
<returns>
Numeric. <b>INKEY( )</b> returns 0 if a key has not been pressed. If several keys are present in the type-ahead buffer, <b>INKEY( )</b> returns the value of the first key entered in the buffer. <b>INKEY( )</b> also returns the following values according to certain conditions:
If M is included for cHideCursor, <b>INKEY( )</b> returns the value 151.
If E is included, <b>INKEY( )</b> returns a value corresponding to the first keystroke assigned to the keyboard macro. If you omit E, <b>INKEY( )</b> returns the value for the key or key combination that triggers the keyboard macro.
For single keys and key combinations using the SHIFT, CTRL, and ALT keys, the following table lists the return values for <b>INKEY( )</b>. A dash (–) indicates that the key combination returns no value.
F1
28
84
94
104
F2
–1
85
95
105
F3
–2
86
96
106
F4
–3
87
97
107
F5
–4
88
98
108
F6
–5
89
99
109
F7
–6
90
100
110
F8
–7
91
101
111
F9
–8
92
102
112
F10
–9
93
103
113
F11
133
135
137
139
F12
134
136
138
140
1
49
33
–
120
2
50
64
–
121
3
51
35
–
122
4
52
36
–
123
5
53
37
–
124
6
54
94
–
125
7
55
38
–
126
8
56
42
–
127
9
57
40
–
128
0
48
41
–
19
a
97
65
1
30
b
98
66
2
48
c
99
67
3
46
d
100
68
4
32
e
101
69
5
18
f
102
70
6
33
g
103
71
7
34
h
104
72
127
35
I
105
73
9
23
j
106
74
10
36
k
107
75
11
37
l
108
76
12
38
m
109
77
13
50
n
110
78
14
49
o
111
79
15
24
p
112
80
16
25
q
113
81
17
16
r
114
82
18
19
s
115
83
19
31
t
116
84
20
20
u
117
85
21
22
v
118
86
22
47
w
119
87
23
17
x
120
88
24
45
y
121
89
25
21
z
122
90
26
44
INS
22
22
146
162
HOME
1
55
29
151
DEL
7
7
147
163
END
6
49
23
159
PAGE UP
18
57
31
153
PAGE DOWN
3
51
30
161
UP ARROW
5
56
141
152
DOWN ARROW
24
50
145
160
RIGHT ARROW
4
54
2
157
LEFT ARROW
19
52
26
155
ESC
27
–/27
–*/27
–*/1
ENTER 
13
13
10
–/166
BACKSPACE 
127
127
127
14
TAB
9
15
148/*
*
SPACEBAR
32
32
32/–
57
` or ~
96
126
 
41
- or _
45
95
 
 
= or +
61
43
 
13
[ or {
91
123
27
26
] or }
93
125
29
27
\ or |
92
124
28
43
; or :
59
58
 
39
' or "
39
34
 
40
, or &lt;
44
60
 
51
. or &gt;
46
62
 
52
/ or ?
47
63
 
53
* Keystroke reserved by Windows.
</returns>
</inkey>
<inlist>
<summary>
Determines whether an expression matches another expression in a set of expressions.
</summary>
<param name="eExpression1">

Specifies the expression INLIST( ) searches for in the set of expressions.

eExpression2[, eExpression3...] 
Specifies the set of expressions to search. You must include at least one expression (eExpression2), and can include up to 25 expressions (eExpression2, eExpression3, and so on).
All the expressions in the set of expressions must be of the same data type.
</param>
<returns>
Logical or null value
</returns>
<remarks>
INLIST( ) returns true (.T.) if it finds the expression in the set of expressions; otherwise INLIST( ) returns false (.F.). The null value is returned if eExpression1 is the null value. The null value is also returned if eExpression1 is not the null value, eExpression1 does not match another expression, and at least one of the other expressions is the null value.
</remarks>
<example>
 <code language="X#">SET TALK ON
STORE CMONTH(DATE( )) TO gcMonth
DO CASE
CASE INLIST(gcMonth,'January','February','March')
STORE 'First Quarter' TO gcReporTitle
CASE INLIST(gcMonth,'April','May','June')
STORE 'Second Quarter' TO gcReporTitle
CASE INLIST(gcMonth,'July','August','September')
STORE 'Third Quarter' TO gcReporTitle
OTHERWISE
STORE 'Fourth Quarter' TO gcReporTitle
ENDCASE
WAIT WINDOW gcReporTitle</code>
</example>
</inlist>
<inputbox>
<summary>
Displays a modal dialog used by a parameterized view for input of a single string.
</summary>
<param name="cInputPrompt">

Specifies the Prompt displayed above the text entry box.

</param>
<param name="cDialogCaption">

Specifies the text to display in the title bar of the dialog box. 

</param>
<param name="cDefaultValue">

Specifies a default value to display in the text entry box.

</param>
<param name="nTimeout">

Specifies a timeout value in 1/1000 seconds. 
Specify zero in nTimeout to prevent the dialog from timing out. This is identical to omitting nTimeout.

</param>
<param name="cTimeoutValue">

Specifies value to return if a timeout occurs. cTimeoutValue isn't returned if nTimeout is set to zero or is omitted.

</param>
<param name="cCancelValue">

Specifies a character value to return if the user exits the dialog box by choosing the <b>Cancel</b> button or pressing the Esc key.
</param>
<remarks>
The dialog box displays an edit box and <b>OK</b> and <b>Cancel</b> buttons. The <b>OK</b> button returns the contents of the edit box. A timeout returns the text specified in cTimeoutValue or an empty string if cTimeoutValue is unspecified. The Cancel button or the Esc key returns the text specified in cCancelValue or an empty string if cCancelValue is unspecified.
 <code language="X#">Y = "Nothing at all"
Y = INPUTBOX("TypeHere","Input ",Y,5000)
&amp;&amp; Displays dialog box for 5 seconds, </code>
The following example displays a dialog box for five seconds and displays the return value in the main X# window. If the user clicks OK, the edit box returns the text which is either the default value, "Nothing at all," or user-specified text. If the user clicks Cancel or hits the ESC key, the edit box returns "Canceled." If the user waits the timeout period, the edit box closes and returns "Timed Out."
 <code language="X#">CLEAR
Y = INPUTBOX("Type Here:", "Input Title",  ;
"Nothing at all", 5000, 'Timed Out', 'Canceled')
? Y</code>
</remarks>
</inputbox>
<insmode>
<summary>
Returns the current insert mode, or sets the insert mode on or off.
</summary>
<param name="lExpression">

Turns the insert mode on or off. INSMODE(.T.) turns the insert mode on and INSMODE(.F.) turns it off. A logical value corresponding to the insert mode setting before INSMODE(.T.) or INSMODE(.F.) was issued is returned.
</param>
<returns>
Logical
</returns>
<remarks>
If you omit the optional argument and the insert mode is on (characters are inserted before the cursor), INSMODE( ) returns true (.T.). If the insert mode is off (characters are overwritten at the insertion point), INSMODE( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">SET TALK ON
=INSMODE(.T.)  &amp;&amp; Set insert mode on
? INSMODE( )
= INSMODE(!INSMODE( ))  &amp;&amp; Toggle insert mode to opposite state
? INSMODE( )</code>
</example>
</insmode>
<int>
<summary>
Evaluates a numeric expression and returns the integer portion of the expression.
</summary>
<param name="nExpression">

Specifies the numeric expression for which INT( ) returns the integer portion.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">CLEAR
? INT(12.5)  &amp;&amp; Displays 12
? INT(6.25 * 2)  &amp;&amp; Displays 12
? INT(-12.5)  &amp;&amp; Displays -12
STORE -12.5 TO gnNumber
? INT(gnNumber)  &amp;&amp; Displays -12</code>
</example>
</int>
<isalpha>
<summary>
Determines whether the leftmost character in a character expression is alphabetic.
</summary>
<param name="cExpression">

Specifies the character expression that ISALPHA( ) evaluates. Any characters after the first character in cExpression are ignored.
</param>
<returns>
Logical
</returns>
<remarks>
ISALPHA( ) returns true (.T.) if the leftmost character in the specified character expression is an alphabetic character; otherwise ISALPHA( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer     &amp;&amp; Open customer table
CLEAR
DISPLAY contact
? ISALPHA(contact)  &amp;&amp; Displays .T.
DISPLAY maxordamt
? ISALPHA(cust_id)  &amp;&amp; Displays .F.</code>
</example>
</isalpha>
<isblank>
<summary>
Determines whether an expression is blank. 
</summary>
<param name="eExpression">

Specifies the expression for <b>ISBLANK( )</b> to evaluate. eExpression can be a field in a table, a variable or array element, or an expression.
</param>
<returns>
Logical. <b>ISBLANK( )</b> returns True (.T.) if the expression eExpression is blank; otherwise, <b>ISBLANK( )</b> returns False (.F.).

<b>ISBLANK( )</b> returns True (.T.) for fields when those fields contain certain values. The following table lists the values that field types contain for <b>ISBLANK( )</b> to return True. 

<b>Blob</b>

Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on

<b>Character</b>

Empty string, spaces, or no value, such as a newly appended blank record or cleared with <b>BLANK</b>

<b>Date</b>

Blank date ({ / / }) or no value, such as a newly appended blank record or cleared with <b>BLANK</b>

<b>DateTime</b>

Blank datetime ({ / / : : }) or no value, such as a newly appended blank record or cleared with <b>BLANK</b>

<b>Float</b>

No value, such as a newly appended blank record or cleared with <b>BLANK</b>

<b>General</b>

Empty, for example, no OLE object

<b>Logical</b>

No value, such as a newly appended blank record or cleared with <b>BLANK</b>

<b>Memo</b>

Empty, for example, no memo contents

<b>Numeric</b>

No value, such as a newly appended blank record or cleared with <b>BLANK</b>

<b>Varbinary</b>

Empty (0h) or contains only zero bytes, for example, 0h00, 0h000000, and so on
Expressions with <b>Currency</b>, <b>Integer</b>, or <b>Double</b> type are never blank; therefore, <b>ISBLANK( )</b> always returns False (.F.) for these expression types.
</returns>
<remarks>
To create a blank record, use the <b>APPEND BLANK</b> and <b>BLANK</b> commands. You can also use <b>BLANK</b> to clear data from fields in a record.

<b>ISBLANK( ) </b>differs from <b>EMPTY( )</b> and <b>ISNULL( )</b>. For example, <b>EMPTY( )</b> returns True (.T.) if a character expression evaluates to empty, for example, it contains spaces, tabs, carriage returns, or line feeds. <b>ISBLANK( )</b> returns True (.T.) if the character expression contains only the empty string ("") or spaces.
</remarks>
<example>
 <code language="X#">CREATE TABLE mytable FREE (myfield C(20))
APPEND BLANK  &amp;&amp; Add new blank record
CLEAR
? ISBLANK(myfield)  &amp;&amp; Displays .T.
REPLACE myfield WITH 'John Smith'  &amp;&amp; Insert a value in the field
? ISBLANK(myfield)  &amp;&amp; Displays .F.</code>
</example>
</isblank>
<isdigit>
<summary>
Determines whether the leftmost character of the specified character expression is a digit (0 through 9).
</summary>
<param name="cExpression">

Specifies the character expression that ISDIGIT( ) tests. Any characters after the first character in cExpression are ignored.
</param>
<returns>
Logical
</returns>
<remarks>
ISDIGIT( ) returns true (.T.) if the leftmost character of the specified character expression is a digit (0 through 9); otherwise, ISDIGIT( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE orders  &amp;&amp; Open Orders table
CLEAR
DISPLAY cust_id
? ISDIGIT(cust_id)  &amp;&amp; Displays .F.
DISPLAY order_dsc
? ISDIGIT(ALLTRIM(STR(order_dsc)))  &amp;&amp; Displays .T.</code>
</example>
</isdigit>
<isexclusive>
<summary>
Returns true (.T.) if a table or database is opened for exclusive use; otherwise, returns false (.F.).
</summary>
<param name="cTableAlias">

Specifies the alias of the table for which the exclusive use status is returned. X# generates an error message if you specify a table alias that doesn't exist.

</param>
<param name="nWorkArea">

Specifies the work area of the table for which the exclusive use status is returned. ISEXCLUSIVE( ) returns false (.F.) if a table isn't open in the work area you specify.

</param>
<param name="cDatabaseName">

Specifies the name of the database for which the exclusive use status is returned.

</param>
<param name="nType">

Specifies whether the exclusive status is returned for a table or a database. The following table lists the values for nType and the corresponding status returned.
1
Table
2
Database
To determine the exclusive status for a database, you must include nType with a value of 2.
</param>
<returns>
Logical
</returns>
<remarks>
ISEXCLUSIVE( ) returns a value for the table open in the currently selected work area if you omit the optional cTableAlias, nWorkArea, or cDatabaseName arguments.
A table is opened for exclusive use by including the EXCLUSIVE keyword in USE, or by setting SET EXCLUSIVE to ON before the table is opened.
A database is opened for exclusive use by including the EXCLUSIVE keyword in OPEN DATABASE.
</remarks>
<example>
 <code language="X#">cExclusive = SET('EXCLUSIVE')
SET EXCLUSIVE OFF
SET PATH TO (HOME(2) + 'data\')
OPEN DATA testdata  &amp;&amp; Opens the test databsase
USE customer     &amp;&amp; Not opened exclusively
USE employee IN 0 EXCLUSIVE    &amp;&amp; Opened exclusively in another work area
IF ISEXCLUSIVE( )
REINDEX  &amp;&amp; Can only be done if table opened exclusively
ELSE
WAIT WINDOW 'The table has to be exclusively opened'
ENDIF
SET EXCLUSIVE &amp;cExclusive</code>
</example>
</isexclusive>
<isflocked>
<summary>
Returns the table lock status.
</summary>
<param name="nWorkArea">

Specifies the work area number of the table for which the lock status is returned. If you omit cTableAlias and nWorkArea, the lock status is returned for the table open in the current work area.

</param>
<param name="cTableAlias">

Specifies the alias of the table for which the lock status is returned. An "Alias not found" error message is generated if you specify an alias of a table that isn't open.
</param>
<returns>
Logical
</returns>
<remarks>
ISFLOCKED( ) returns a logical true (.T.) if the table is locked; otherwise a logical false (.F.) is returned. ISFLOCKED( ) is similar to SYS(2011), but returns a logical value which does not require localization for international applications.
ISFLOCKED() only returns .T. at the workstation that applied the file lock.
</remarks>
</isflocked>
<isleadbyte>
<summary>
Returns true (.T.) if the first byte of the first character in a character expression is the lead byte of a double-byte character.
</summary>
<param name="cExpression">

Specifies the character expression that ISLEADBYTE( ) evaluates. Any bytes after the first byte in the first character in cExpression are ignored.
</param>
<returns>
Logical
</returns>
<remarks>
ISLEADBYTE( ) returns true (.T.) if the first byte of the first character in a character expression is the lead byte in a double-byte character. If ISLEADBYTE( ) returns false (.F.), the character being tested is a single-byte character.
This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
</remarks>
</isleadbyte>
<islower>
<summary>
Determines whether the leftmost character of the specified character expression is a lowercase alphabetic character.
</summary>
<param name="cExpression">

Specifies the character expression that ISLOWER( ) tests. ISLOWER( ) ignores any characters after the first character in cExpression.
</param>
<returns>
Logical
</returns>
<remarks>
ISLOWER( ) returns true (.T.) if the leftmost character in the specified character expression is a lowercase alphabetic character; otherwise, ISLOWER( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">CLEAR
? ISLOWER('redmond')  &amp;&amp; Displays .T.
? ISLOWER('Redmond')  &amp;&amp; Displays .F.</code>
</example>
</islower>
<ismemofetched>
<summary>
Determines if a memo field has been fetched during a delayed memo fetch.
</summary>
<param name="cFieldName">

Specifies the name of the memo field for which the fetch status is returned.

</param>
<param name="nFieldNumber">

Specifies the field number (based on the physical structure of the table or cursor) of the memo field for which the fetch status is returned.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor containing the memo field for which the fetch status is returned.

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor containing the memo field for which the fetch status is returned.
</param>
<returns>
Logical. A logical true (.T.) is returned if the specified memo field has been fetched, otherwise a logical false (.F.) is returned. True (.T.) is always returned for local data. The null value (.NULL.) is returned for a cursor if the record pointer is positioned at the beginning or end of the cursor. Use the BOF( ) Function and the EOF( ) Function to determine if the record pointer is positioned at the beginning or end of the cursor.
</returns>
<remarks>
It can often take a while for a memo field fetch to occur with remote data, so you may choose to not download a memo field until it is absolutely needed.
The FetchMemo setting in the DBGETPROP( ) Function and CURSORGETPROP( ) Function functions determine if a memo field is retrieved with View results or on demand. ISMEMOFETCHED( ) return true (.T.) when the memo field is fetched for delayed Memo data (FetchMemo=.F.).
ISMEMOFETCHED( ) works with both memo and general fields. 
</remarks>
</ismemofetched>
<isnull>
<summary>
Returns true (.T.) if an expression evaluates to a null value; otherwise, ISNULL( ) returns false (.F.).
</summary>
<param name="eExpression">

Specifies the expression to evaluate.
</param>
<returns>
Logical
</returns>
<remarks>
Use ISNULL( ) to determine if the contents of a field, memory variable, or array element contains a null value, or if an expression evaluates to a null value.
</remarks>
<example>
 <code language="X#">STORE .NULL. TO mNullvalue  &amp;&amp; Store a null value to a memory variable
CLEAR
? mNullvalue  &amp;&amp; Display the value of the memory variable
? ISNULL(mNullvalue)  &amp;&amp; Returns .T., indicating a null value
? TYPE('mNullvalue')     &amp;&amp; Returns L, indicating a logical value
? (mNullvalue = .NULL.)  &amp;&amp; Returns .NULL., bad test for null values</code>
</example>
</isnull>
<ispen>
<summary>
Determines if the last Tablet PC mouse event was a pen tap.
</summary>
<remarks>
ISPEN( )Remarks
The ISPEN( ) function returns a logical true (.T.) if the last Tablet PC mouse event was a pen tap. A logical false (.F.) is returned if the last mouse event wasn't a pen tap.
</remarks>
</ispen>
<isreadonly>
<summary>
Determines whether a table or database is opened read-only.
</summary>
<returns>
Logical
</returns>
<remarks>
ISREADONLY( ) returns true (.T.) if a table is opened read-only; otherwise, ISREADONLY( ) returns false (.F.).
You can open a table read-only by including the NOUPDATE option when opening the table with USE, by checking the Read Only check box when opening the table from the Open dialog box, or by assigning MS-DOS read-only attributes to the table.
You cannot pass a non-current database alias to the ISREADONLY( ) function. To ensure that a database is present, you can use code such as the following:
 <code language="X#">!EMPTY(DBC())</code>
A cursor created with the SELECT – SQL command is always read-only.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer    NOUPDATE  &amp;&amp; Open customer table read-only
CLEAR
? ISREADONLY('customer')  &amp;&amp; Returns .T.</code>
</example>
</isreadonly>
<isrlocked>
<summary>
Returns the record lock status.
</summary>
<param name="nRecordNumber">

Specifies the number of the record for which the lock status is returned. If nRecordNumber is omitted, the record lock status is returned for the current record.

</param>
<param name="nWorkArea">

Specifies the work area number of the table for which the record lock status is returned. If you omit cTableAlias and nWorkArea, the record lock status is returned for the table open in the current work area.

</param>
<param name="cTableAlias">

Specifies the alias of the table for which the record lock status is returned.
</param>
<returns>
Logical
</returns>
<remarks>
ISRLOCKED( ) returns a logical true (.T.) if the record is locked by the current application; otherwise a logical false (.F.) is returned.
ISRLOCKED( ) only returns .T. in the data session that applied the record lock.
</remarks>
</isrlocked>
<istransactable>
<summary>
Returns a logical value indicating if a free table or free cursor supports transactions.
</summary>
<param name="nWorkArea">

Specifies the work area of the free table or free cursor for which ISTRANSACTABLE( ) determines if transactions are supported.

</param>
<param name="cAlias">

Specifies the alias of the table or cursor for which ISTRANSACTABLE( ) determines if transactions are supported.
</param>
<returns>
Logical. Returns a logical true (.T.) if a free table or free cursor supports transactions, otherwise a logical false (.F.) is returned.
</returns>
<remarks>
Use the MAKETRANSACTABLE( ) Function to allow a free table or free cursor to support transactions.
</remarks>
</istransactable>
<isupper>
<summary>
Determines whether the first character in a character expression is an uppercase alphabetic character.
</summary>
<param name="cExpression">

Specifies the character expression that ISUPPER( ) evaluates. Any characters after the first character in icExpression/i are ignored.
</param>
<returns>
Logical
</returns>
<remarks>
ISUPPER( ) returns true (.T.) if the first character in a character expression is an uppercase alphabetic character; otherwise, ISUPPER( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">? ISUPPER('Redmond')  &amp;&amp; Displays .T.
? ISUPPER('redmond')  &amp;&amp; Displays .F.</code>
</example>
</isupper>



<key>
<summary>
Returns the index key expression for an index tag or index file.
</summary>
<param name="CDXFileName">

Specifies the name of a compound index file. KEY( ) returns the index key expressions of the .cdx file's index tag. The compound index file you specify can be the structural compound index file automatically opened with the table, or it can be an independent compound index file.

</param>
<param name="nIndexNumber">

Specifies which index key expression to return.
USE and SET INDEX both support an index file list that lets you open multiple indexes for a table. Any combination of single-entry .idx index files, structural compound index files, or independent compound index files can be included in the index file list.   
The numeric expression nIndexNumber specifies which index expression to return from the open index files. KEY( ) returns index expressions from open index files in the following order as nIndexNumber increases from 1 to the total number of open single-entry .idx files and structural compound and independent compound index tags:   
Index expressions from single-entry .idx index files (if any are open) are returned first. The order in which the single-entry index files are included in USE or SET INDEX determines how the index expressions are returned.
Index expressions for each tag in the structural compound index (if one is present) are returned next. The index expressions are returned from the tags in the order in which the tags are created in the structural compound index.
Index expressions for each tag in any open independent compound indexes are returned last. The index expressions are returned from the tags in the order in which the tags are created in the independent compound indexes.
The empty string is returned if nIndexNumber is greater than the total number of open single-entry .idx files and structural compound and independent compound index tags. 

</param>
<param name="nWorkArea">

Specifies the work area number of the table whose index key expressions you want KEY( ) to return.
If a table isn't open in the work area you specify, KEY( ) returns the empty string. 

</param>
<param name="cTableAlias">

Specifies the alias of the table whose index key expressions you want KEY( ) to return.
If no table has the alias you specify, X# generates an error message.   
If you omit nWorkArea and cTableAlias, the index key expressions are returned for the table open in the current work area.
</param>
<returns>
Character
</returns>
<remarks>
An index key expression is specified when an index tag or index file is created with INDEX. The index key expression determines how a table is displayed and accessed when the index tag or index file is opened as the master controlling index tag or file.
For more information on creating index tags, index files, and index key expressions, see INDEX.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer     &amp;&amp; Open customer table
CLEAR
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
? TAG(nCount) + ' '  &amp;&amp; Display tag name
?? KEY(nCount)  &amp;&amp; Display index expression
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found
ENDIF
ENDFOR</code>
</example>
</key>
<keymatch>
<summary>
Searches an index tag or index file for an index key.
</summary>
<param name="eIndexKey">

Specifies the index key that KEYMATCH( ) searches for. The index keys in an index file or index tag are determined by the index expression. An index expression is specified when an index file or index tag is created with INDEX. KEY( ) and SYS(14) can be used to return the index expressions for index files and index tags. For more information on creating index files, index expressions, and index keys, see INDEX.
If you don't include any of the optional parameters, KEYMATCH( ) searches the master index file or master index tag for the index key you specify. If a master index file or index tag isn't in effect (for example, you've issued SET ORDER TO without any parameters to place the table in physical record order), X# generates an error message. 

</param>
<param name="nIndexNumber">

Specifies which index file or index tag is searched. nIndexNumber is typically an integer that starts at 1 and is increased by 1 to search additional index tags.
If nIndexNumber is 1, the master single-entry .idx index file or master index tag (if one is present) is searched.   
As nIndexNumber increases, subsequent tags in the structural compound index (if one is present) are searched. The tags are searched in the order in which the tags were created in the structural compound index.   
As nIndexNumber continues to increase and all the tags in the structural compound index have been searched, tags in any open independent compound indexes are then searched. The tags are searched in the order in which the tags were created in the independent compound indexes.   
An error message is generated if nIndexNumber is greater than the total number of open single-entry .idx files and structural compound and independent compound index tags. 

nWorkArea| cTableAlias
Searches index files or tags open in another work area. nWorkArea specifies the work area number and cTableAlias specifies the table alias. If you omit the work area and alias, KEYMATCH( ) searches index files or tags open for the table in the current work area.
If no table has the alias you specify, X# generates an error message.
</param>
<returns>
Logical
</returns>
<remarks>
KEYMATCH( ) searches an index tag or index file for a specific index key and returns true (.T.) if the index key is found; otherwise, KEYMATCH( ) returns false (.F.). KEYMATCH( ) can be used to prevent duplicate index keys.
KEYMATCH( ) returns the record pointer to the record on which it was originally positioned before KEYMATCH( ) was issued.
</remarks>
</keymatch>
<lastkey>
<summary>
Returns an integer corresponding to the last key pressed.
</summary>
<returns>
LASTKEY( )Return Value
Numeric
</returns>
<remarks>
The values returned by <b>LASTKEY( )</b> are the same as the values returned by <b>INKEY( )</b>. See INKEY( ) for a list of keys and their return values.

<b>LASTKEY( )</b> is updated when you move between controls.
</remarks>
</lastkey>
<left>
<summary>
Returns a specified number of characters from a character expression, starting with the leftmost character.
</summary>
<param name="cExpression">

Specifies the character expression that <b>LEFT( )</b> returns characters from.

</param>
<param name="nExpression">

Specifies the number of characters returned from the character expression. If nExpression is greater than the length of cExpression, all of the character expression is returned. If nExpression is negative or 0, <b>LEFT( )</b> returns an empty string.
<b>LEFT( )</b> uses a starting position of 1 and is identical to <b>SUBSTR( )</b>. 
</param>
<returns>
Character. <b>LEFT( )</b> returns a character string.
</returns>
<example>
 <code language="X#">? LEFT('Redmond, WA', 4)          &amp;&amp; Displays the string, Redm.
myString = LEFT('Redmond, WA', 4) &amp;&amp; Stores result in myString.
? myString                        &amp;&amp; Displays result in myString.</code>
</example>
</left>
<len>
<summary>
Determines the number of characters in a character expression, indicating the length of the expression.
</summary>
<param name="cExpression">

Specifies the character expression for which <b>LEN( )</b> returns the number of characters.
</param>
<returns>
Numeric. <b>LEN( )</b> returns the number of characters in a character expression.
</returns>
<example>
 <code language="X#">CLEAR
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer
? 'Width of contact field: '
?? LEN(contact)
? 'Width of cust_id field: '
?? LEN(cust_id)</code>
</example>
</len>
<like>
<summary>
Determines if a character expression matches another character expression.
</summary>
<param name="cExpression1">

Specifies the character expression that <b>LIKE( )</b> compares with cExpression2. cExpression1 can contain the wildcards such as * and ?. The question mark (?) matches any single character in cExpression2 and the asterisk (*) matches any number of characters. You can mix any number of wildcards in any combination in cExpression1.

</param>
<param name="cExpression2">

Specifies the character expression <b>LIKE( )</b> compares with cExpression1. cExpression2 must match cExpression1 letter for letter in order for <b>LIKE( )</b> to return true (.T.).
</param>
<returns>
Logical
</returns>
<remarks>

<b>LIKE( )</b> returns true (.T.) if cExpression1 matches cExpression2; otherwise, it returns false (.F.).

<b>SET COMPATIBLE</b> determines how <b>LIKE( )</b> evaluates cExpression1 and cExpression2. If <b>SET COMPATIBLE</b> is set to ON or DB4, cExpression1 and cExpression2 have all trailing blanks removed before they are compared. If <b>SET COMPATIBLE</b> is set to OFF or FOXPLUS, any trailing blanks in cExpression1 and cExpression2 are used in the comparison.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE products  &amp;&amp; Open Products table
CLEAR
? 'All product names with first two letters Ch:'
?
SCAN FOR LIKE('Ch*', prod_name)
? prod_name
ENDSCAN
USE</code>
</example>
</like>
<lineno>
<summary>
Returns the line number of a line being executed in a program relative to the first line of the main program.
</summary>
<returns>
Numeric
</returns>
<remarks>
Program lines are counted starting from the top of the program. Comment lines, continuation lines, and blank lines are included in the line number count. If a program is suspended during execution, LINENO( ) returns the number of the program line at which program execution was suspended. LINENO( ) returns 0 if a program is canceled.
By default, line numbers are returned relative to the beginning of the main program. If a procedure is called, line numbering continues from the top of the calling program.
LINENO( ) is useful for debugging programs. You can set a breakpoint to stop program execution at a specific line number by opening the Breakpoints window, setting the Type to 'Break when expression is true' and adding codeLINENO( ) = nExpression/code in the Expression textbox.
</remarks>
<example>
 <code language="X#">ON ERROR DO bug_proc WITH LINENO( )
BRWS  &amp;&amp; Causes an error
ON ERROR
*** Bug_Proc error handler ***
PROCEDURE bug_proc
PARAMETERS gnBadLine
WAIT WINDOW 'Error occurred at line: ' + ALLTRIM(STR(gnBadLine))
RETURN</code>
</example>
</lineno>
<loadpicture>
<summary>
Creates an object reference for a bitmap, icon, or Windows meta file.
</summary>
<param name="cFileName">

Specifies the image file on disk for which an object is created. br
brThe following image types are supported:/Pbr
<b>Supported Image Types</b>




Image Type Groups

Filename Extensions


bitmaps

.bmp, .jpg, .jpeg, .jpe, .jfif, .gif, .giff, .gfa
icons
.ico
windows metafiles
.wmf
windows enhanced metafiles
.emf
cursor
.cur

brThe following restrictions (tested with VFP 9 SP2 and OlePro32.dll Version 6.0.6002.18005) exist:/Pbr
<b>Known Limitations</b>
Restrictions &amp; Issues
Loading these <b>.tif</b> and <b>.png</b> formats will cause an OLE error.
Icons are allowed with sizes up to 128x128 and must not have more than 256 colors. Even if there is more than one icon stored in the icon file, always only the smallest icon gets displayed. The icon file may contain much more icons - even with more colors and larger sizes - as long as there is at least one that complies with the rules above, then no exception is thrown.
Cursor files must not have more than 1K of file size, otherwise an OLE error is generated. Cursor files containing 16 color cursors can be loaded flawlessly, but only monochrome output is supported. Loading an animated cursor (.ani) causes an OLE error to be raised.
<b>Null Picture Support</b>
If cFileName is omitted, the "null picture" is returned.br
You can include GETPICT( ) as cFileName to display the Open dialog from which you can choose a bitmap file.
</param>
<returns>
Object
<b>LOADPICTURE() function</b> returns a <b>Picture type COM object reference</b> that can be assigned to ActiveX controls and VFP’s Image object’s <b>PictureVal property</b>.
However, the real primary interface <b>iPicture</b> only can be retrieved using code like this:br
&amp;nbsp;
<code language="X#">oIPicture = GETINTERFACE(LOADPICTURE(GETPICT()), "iPicture")</code>

</returns>
<remarks>
Picture objects provide a language-neutral abstraction for bitmaps, icons, and metafiles.
As with the standard font object, the system provides a standard implementation of the picture object.
Its primary interfaces are <b>iPicture</b> and <b>iPictureDisp</b>.
A picture object is created with <b>OleCreatePictureIndirect</b> and supports both the <b>iPicture</b> and the <b>iPictureDisp</b> interfaces.
The OLE-provided picture object implements the complete semantics of the <b>iPicture</b> and <b>iPictureDisp</b> interfaces.
In other words, there’s no need to use another interface than <b>iPicture</b>!
<b>LOADPICTURE( ) Function</b> internally wraps the <b>OleCreatePictureIndirect() function</b> implemented in <b>OleAut32.dll</b>.
Thus, all you can read about that function (above and online) is also true for VFP’s <b>LOADPICTURE() function</b>.
<b>LOADPICTURE( ) Function</b> was added to VFP’s vocabulary to make it easier to load images with COM interfaces that many presentation properties of ActiveX controls require for their settings.
For example, the ActiveX Outline control has a <b>PictureOpen property</b> that requires a COM object image reference for its setting.
The COM object returned by <b>LOADPICTURE( ) Function</b> hides its primary interface <b>iPicture</b>.
In contrast to the reference returnd by <b>LOADPICTURE( ) Function</b>, the OLE-image’s primary <b>iPicture</b> interface is the only fully functional one.
In other words, only <b>iPitcure</b> can be used in VFP programms without generating any OLE errors.
Because <b>iPicture</b> is a superset of Picture it may be, better, it should be used everywhere instead of the one returnd by <b>LOADPICTURE( ) Function</b>!br
Example #1 in the examples section below proves that it makes no difference which OLE image interface gets assigned to a <b>oIMAGE.PICTUREVAL property.</b>
The IID of the <b>iPicture</b> interface is defined as “{7BF80980-BF32-101A-8BBB-00AA00300CAB}”. br

The following two lines of code both create a null picture OLE image object:
<code language="X#">oIPicture1 = GETINTERFACE(LOADPICTURE(), "iPicture")
oIPicture2 = CREATEOBJECTEX("StdPicture","","{7BF80980-BF32-101A-8BBB-00AA00300CAB}")</code>

The following table summarizes the PEMs <b>iPicture</b> interface./Pbr

<b>iPicture Interface Members</b>



PEM
Name
Used for
ValueType
Read/Writable


property
The <b>Attributes property</b> is said to hold the picture’s bit attributes. Actually, there are only two, which can be set alone, or additive. The following table lists both possible values:
The following table lists all possible values of the <b>iPicture.Type property</b>:
The most interesting method of the COM image object’s <b>iPicture interface</b> is <b>render()</b> which also works flawlessly only when called on the <b>iPicture interface</b>.
The following table summarises the parameters of the <b>render() method</b>:
The method returns standard values like E_FAIL, E_INVALIDARG and E_OUTOFMEMORY, as well as S_OK, E_POINTER and CTL_E_INVALIDPROPERTYVALUE. These values are described on MSDN.
The render function has plenty of parameters. Some of them passing in pixel values, others HiMetric values.br
<b>Example #3</b> has some useful conversions as well as other supporting functions and definitions.br
To figure out how <b>render()</b> works try the VFP code below; type it in line by line into VFP’s command window:br
/P

Direct input into VFP’s command window

<code language="X#">
* locate an image with round about 100 x 100 pixels
goPic = LOADPICTURE(GETPICT())
gIP = GETINTERFACE(m.goPic, "iPicture")
goForm = CREATEOBJECT("Form")
goForm.Show()
* declare access to the _client_area_ of a window
DECLARE Integer GetDC IN USER32 integer HWnd
* hDC should be  0 (otherwise that's an error)!
hDC = GetDC(goForm.HWnd)
* render your image directly onto form's client area
gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
* declare release function
DECLARE Integer ReleaseDC IN USER32 integer HWnd, integer hDC
* next line should print 1 on the form's background >> "Okay"
? ReleaseDC(m.goForm.HWnd, m.hDC)
* declare access to the _whole_ window
DECLARE Integer GetWindowDC IN USER32 integer HWnd
* hDC now references form's caption an border areas as well!
hDC = GetWindowDC(goForm.HWnd)
* render out partially overwriting form's border and caption
gIP.Render(m.hDC,0,0,100,100,0,gIP.Height,gIP.Width,- gIP.Height,NULL)
* never forget to free an allocated device context
? ReleaseDC(m.goForm.HWnd, m.hDC)
</code>

<b>iPicture.Render()</b> qualifies for painting on otherwise unreachable form regions, like the TitleBar or WindowBorders.
Another interesting application for direct rendering stems from the fact that no VFP object reference is necessary for painting.
The <b>render() method</b> solely uses a common windows handle. Thus, one can render on any known device context.br
If one encounters the so-called hourglass problem, working with a COM-based image can be the preferred workaround.
The hourglass mouse cursor gets displayed by the operation system during lengthy disk accesses.
Sometimes VFP does not reset the hourglass mouse cursor correctly.
Thus, the user still sees the “busy working” icon although VFP already is idle, as long she doesn’t touch the mouse.
Most often these disk accesses stem from refreshing pictures loaded into native Image-Objects using the <b>Image.Picture property</b>.
Storing a COM memory-based object to the Image-Object’s <b>.PictureVal property</b> instead, never causes any disk access.
Thus, no more hourglass mouse cursor will appear after a refresh!

<b>iPicture.Render()</b> does its work outside of - and unnoticed by – the VFP engine itself.
That’s why VFP has no idea of what was painted “between the lines”.
Each time VFP refreshes the form’s area (we’ve just rendered our picture onto), will clear out our image.
To make rendered output persistent measures have to be taken against VFP wiping it out! 
There is another BUG one has to be aware of, when employing the hourglass workaround described above!br
To see what happens, try the following code:

<code language="X#">
LOCAL lnLoop, oComPic1, oComPic2
oComPic1 = LOADPICTURE(GETFILE())
oComPic2 = LOADPICTURE(GETFILE())
TRY
_Screen.Addobject("oImage","IMAGE")
CATCH
FINALLY
_Screen.oImage.Visible = .T.
ENDTRY
FOR lnLoop = 1 to 100
_Screen.oImage.PictureVal = m.oComPic1
_Screen.oImage.PictureVal = m.oComPic2
NEXT
*//
*\\ whereas the next loop will break somewhere down the road:
FOR lnLoop = 1 to 100
_Screen.oImage.PictureVal = m.oComPic1
_Screen.oImage.PictureVal = m.oComPic1
_Screen.oImage.PictureVal = m.oComPic1
_Screen.oImage.PictureVal = m.oComPic2
NEXT
</code>
One can see, that the first loop executes flawlessly, the second one breaks after only a few loops with a “Property value is invalid” error message!
This bug is hard to track and occurs only in cases when someone tries to assign the same COM-reference more than once in a row!
The workaround for this is to keep track which COM-reference is actually assigned to the Image’s PictureVal property.
Never ever then reassign the same reference a second time (overwriting the first one with a copy of itself)!
BTW: It doesn’t matter what interface you are using.
The error seems to stem from VFP’s Image class instance.
</remarks>
<example>
The following example shows that both interfaces (<b>Picture</b> and <b>IPicture</b>) of a COM image instance can be assigned to VFP’s <b>Image.PictureVal property</b>:

<code language="X#">PUBLIC goPic AS Object, goIPic AS Object
goPic = LOADPICTURE(GETPICT())
goIPic = GETINTERFACE(m.goPic, "iPicture")
_SCREEN.AddObject("oPic1","IMAGE")
_SCREEN.AddObject("oPic2","IMAGE")
WITH _SCREEN.oPic1
.VISIBLE = .T.
.PICTUREVAL = m.goPic &amp;&amp; "Picture"-Interface
ENDWITH
WITH _SCREEN.oPic2
.LEFT = 110
.VISIBLE = .T.
.PICTUREVAL = m.goIPic &amp;&amp; "IPicture"-Interface
ENDWITH
HIDE WINDOWS ALL
WAIT WINDOW "Press any key..."
_SCREEN.RemoveObject("oPic1")
_SCREEN.RemoveObject("oPic2")
STORE NULL TO goPic, goIPic
CLEAR
SHOW WINDOWS ALL</code>
The following example shows how to query the <b>iPicture interface</b> of a COM image instance.
Intentionally, there are no Try…Catch…Endtry sections in this demo code, so that OLE errors may occur.
You have to run the code snippet multiple times with different image types to see them.

<code language="X#">goPic = LOADPICTURE(GETPICT())
IF VARTYPE(m.goPic) == "O"
goIPic = GETINTERFACE(m.goPic, "iPicture")
IF VARTYPE(m.goIPic) == "O"
CLEAR &amp;&amp; just some informal output:
WITH m.goIPic
?
? "Properties of 'IPicture'-Interface:"
? "Attributes"		,.Attributes
*\\ next line will fail if an ICOn loaded
? "CurDC"	,.CurDC
? "Handle"	,.Handle
? "Height"	,.Height
*\\ next line will fail if an ICOn loaded
? "hPal"	,.hPal
? "KeepOriginalFormat",.KeepOriginalFormat
? "Type"	,.Type
? "Width"	,.Width
?
ENDWITH
ENDIF
ENDIF
</code>
The following code is a collection of supporting functions and declarations that come in handy while programming OLE image objects.

<code language="X#">
* Supporting Functions &amp; DEFINEs
#DEFINE INCH2MILLIMETER 25.4 &amp;&amp; 1 Inch = 25.4 millimeters
#DEFINE INCH2HIMETRICS (INCH2MILLIMETER * 100) &amp;&amp; 1 HIMETRIC = 0.01
FUNCTION PXL2HIME(tnPixel AS Integer) AS Integer
* Pixel to HiMetric conversion
LOCAL lnPixelsOnOneHiMetricUnit AS Integer
lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
RETURN ROUND(lnPixelsOnOneHiMetricUnit * m.tnPixel, 0)
ENDFUNC
FUNCTION HIME2PXL(tnHimetric AS Integer) AS Integer
* HiMetric to Pixel conversion
LOCAL lnPixelsOnOneHiMetricUnit AS Integer
lnPixelsOnOneHiMetricUnit = INCH2HIMETRICS / GetDPI()
RETURN ROUND(m.tnHimetric / m.lnPixelsOnOneHiMetricUnit, 0)
ENDFUNC
FUNCTION GetDPI(tnHDC AS Integer) AS Integer
* retrieve dots per inch resolution
* for VFP's _SCREEN device context
DECLARE Integer GetDeviceCaps IN GDI32 integer hdc, integer nIndex
DECLARE Integer GetWindowDC IN USER32 integer HWnd
DECLARE Integer ReleaseDC IN USER32 integer HWnd, integer hDC
* For simplicity, we assume X- and Y- dimensions
* using the same DPI resolution.
#DEFINE LOGPIXELSX 88 &amp;&amp; Logical pixels/inch in X
#DEFINE LOGPIXELSY 90 &amp;&amp; Logical pixels/inch in Y
* Get VFP's _Screen-hDC to calculate resolution:
LOCAL lhDC AS Integer, lnDPI AS Integer
STORE 0 TO lhDC, lnDPI
lhDC = GetWindowDC(_Screen.HWnd)
IF NOT m.lhDC = 0
lnDPI = GetDeviceCaps(m.lhDC, LOGPIXELSX)
ELSE
lnDPI = 96 &amp;&amp; default to 96 DPI
ENDIF
* Free device context
= ReleaseDC(_Screen.HWnd, m.lhDC)
RETURN m.lnDPI
ENDFUNC
FUNCTION GetCanvas(tnHWND AS Integer, tlChild AS Boolean) AS Integer
* Retrieve hDC (handle DeviceContext) of window handle
* tlChild = TRUE  := Use GetDC()
* tlChild = FALSE := Use GetWindowDC()
DECLARE Integer GetDC IN USER32 integer HWnd
DECLARE Integer GetWindowDC IN USER32 integer HWnd
LOCAL lnHDC AS Integer
IF m.tlChild
lnHDC = GetDC(m.tnHWND)
ELSE
lnHDC = GetWindowDC(m.tnHWND)
ENDIF
RETURN m.lnHDC
ENDFUNC
FUNCTION ReleaseCanvas(tnHWND AS Integer, tnHDC AS Integer) AS Integer
* Releases a borrowed hDC
DECLARE Integer ReleaseDC IN USER32 integer HWnd, integer hDC
RETURN ReleaseDC(m.tnHWND, m.tnHDC)
ENDFUNC
* The following function is not bullert-proof, as it fails on forms with scrollbars (oForm.Scrollbars > 0)
FUNCTION GetChildAreaCanvas(tnhWnd AS Integer) AS Integer
* VFP ‘TopLevelForms’ (oForm.ShowWindow = 2) have
* a secondary window inside the outer one.
* This is also true for forms showing scrollbars!
LOCAL lnVfpHANDLE AS Integer, lnClienthWnd AS Integer, lnHDC AS Integer
* Convert the given Windows hWnd to an internal VFP WHANDLE
lnVfpHANDLE = SYS(2326, m.tnhWnd)
* Retrieve the Windows hWnd for a client window
* (WCLIENTWINDOW) of a specified X# parent window
lnClienthWnd = SYS(2325, m.lnVfpHANDLE)
* Check if there is a WCLIENTWINDOW
IF lnClienthWnd = lnVfpHANDLE
* No such WCLIENTWINDOW, return child’s client area
lnHDC = GetCanvas(m.tnhWnd, .T.)
ELSE
* There IS a WCLIENTWINDOW!
* Get the device context handle for the
* whole client area of that window:
lnHDC = GetCanvas(lnClienthWnd)
ENDIF
RETURN m.lnHDC
ENDFUNC
</code>
</example>
</loadpicture>
<locfile>
<summary>
Locates a file on disk and returns the file name with its path.
</summary>
<param name="cFileName">

Specifies the name of the file to locate. If cFileName includes only a file name, LOCFILE( ) searches the X# default directory or folder first. If the file is not found in the default directory or folder, the X# path is then searched. Use SET PATH to specify the X# path.
If cFileName includes a path and a file name, the specified location is searched. If the file cannot be found in the specified location, LOCFILE( ) searches the X# default directory or folder and then the X# path.   
If the file is located, LOCFILE( ) returns the file name and path. 

</param>
<param name="cFileExtensions">

Specifies file extensions for the file to locate. If the file name you specify with cFileName does not include an extension, X# applies the file extensions listed in cFileExtensions to the file name and searches for the file again.
cFileExtensions also specifies the file name extensions of the files displayed in the Open dialog box when the file you specified cannot be located.   
cFileExtensions can take a variety of forms:   
If cFileExtensions contains a single extension (for example, PRG), only files with that extension are displayed.
cFileExtensions can also contain wildcards (* and ?). All files with extensions that meet the wildcard criteria are displayed. For example, if cFileExtensions is ?X?, all files with the extension .fxp, .exe, or .txt are displayed.
In X# for Windows, cFileExtensions can contain a file description followed by a file extension or a list of file extensions separated with commas. The file description appears in the Files of Type list box. Separate the file description from the file extension or list of file extensions with a colon (:). Separate multiple file descriptions and their file extensions with a semicolon (;). 
For example, if cFileExtensions is "Text:TXT" the file description "Text" appears in the Files of Type list box and all files with a .txt extension are displayed.  
If cFileExtensions is "Tables:DBF; Files:TXT,BAK" the file descriptions "Tables" and "Files" appear in the Files of Type list box. When "Tables" is chosen from the Files of Type list box, all files with a .dbf extension are displayed. When "Files" is chosen from the Files of Type list box, all files with .txt and .bak extensions are displayed. 

</param>
<param name="cFileNameCaption">

Specifies the text you want to use to prompt the user. The text appears to the left of the textbox in which you enter the file name. If omitted, "File name:" is displayed.
For a list of X# file extensions and corresponding creator types, see the File Extensions and File Types online topic.
</param>
<returns>
Character
</returns>
<remarks>
The Open dialog box is displayed if the file cannot be located in the default directory or folder, the X# path, or a specified location. The Open dialog box can be used to locate the file. When a file is chosen from the Open dialog box, the file name is returned with the file's path.
If you exit the Open dialog box by choosing Cancel, pressing ESC, or choosing Close from the Control menu, X# generates an error message and LOCFILE( ) does not return a value.
</remarks>
</locfile>
<lock>
<summary>
Attempts to lock one or more records in a table.
</summary>
<param name="cRecordNumberList">

Specifies a list of one or more record numbers which you must include to attempt to lock multiple records. SET MULTILOCKS must be ON and you must include the work area or alias of the table for which you are attempting to place multiple record locks.
LOCK( ) attempts to lock all of the records you specify. The record numbers specified with cRecordNumberList are separated by commas. For example, to attempt record locks on the first four records in a table, cRecordNumberList must contain 1,2,3,4.   
You can also lock multiple records by moving the record pointer to the record you would like to lock, issuing LOCK( ) or RLOCK( ) and then repeating these steps for each additional record.   
In X#, you can specify 0 as a record number. Specifying 0 makes it possible for you to attempt to lock the table header.   
Keep the table header locked for as short a time as possible because other users cannot add records to the table when the table header is locked.
Release the table header lock with UNLOCK RECORD 0, UNLOCK or UNLOCK ALL.   
If all the records specified in cRecordNumbers are successfully locked, LOCK( ) returns true (.T.). If even one of the records specified with cRecordNumbers cannot be locked, LOCK( ) returns false (.F.) and none of the records are locked. However, any existing record locks remain in place. Multiple record locking is an additive process. Placing additional record locks does not release locks on other records.   
The maximum number of records that can be locked in each work area is approximately 8,000. It is always faster to lock the entire table rather than even a small number of records.
</param>
<returns>
Logical
</returns>
<remarks>
LOCK( ) is identical to RLOCK( ).
Changes to explicitly locked records aren't saved until the record is unlocked or the record pointer is moved.
If the lock or locks are successfully placed, LOCK( ) returns true (.T.). Locked records are available for both read and write access to the user who placed the locks; they are available for read-only access to all other users on the network.
Executing LOCK( ) does not guarantee that the record lock or locks will be successfully placed. A record lock cannot be placed on a record already locked by another user or in a table locked by another user. If the record lock or locks cannot be placed for any reason, LOCK( ) returns false (.F.).
By default, LOCK( ) makes one attempt to lock a record. Use SET REPROCESS to automatically retry a record lock when the first attempt fails. SET REPROCESS determines the number of lock attempts or the length of time during which lock attempts are made when the initial lock attempt is unsuccessful. For more information, see SET REPROCESS.
SET MULTILOCKS determines whether you can lock multiple records in a table. If SET MULTILOCKS is OFF (the default), you can lock only a single record in a table. When SET MULTILOCKS is ON, you can lock multiple records in a table. For more information, see SET MULTILOCKS.

<b>Unlocking Records</b>   A table record can be unlocked only by the user who placed the lock. You can release record locks by issuing UNLOCK, closing the table, or exiting X#.
UNLOCK can be used to release record locks in the current work area, a specific work area, or in all work areas. For more information, see UNLOCK.
Switching SET MULTILOCKS from ON to OFF or from OFF to ON implicitly performs UNLOCK ALL — all record locks in all work areas are released.
Tables can be closed with USE, CLEAR ALL, or CLOSE DATABASES.
For more information about record and file locking and sharing tables on a network, see Programming for Shared Access.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
SET REPROCESS TO 3 AUTOMATIC
STORE '1,2,3,4' TO gcRecList
gcOldExc = SET('EXCLUSIVE')
SET EXCLUSIVE OFF
SELECT 0
USE employee  &amp;&amp; Open Employee table
SELECT 0
USE customer  &amp;&amp; Open Customer table
? LOCK('1,2,3,4', 'customer')  &amp;&amp; Lock 1st 4 records in customer
? RLOCK(gcRecList, 'employee')  &amp;&amp; Lock 1st 4 records in employee
UNLOCK IN customer
UNLOCK IN employee
SET EXCLUSIVE &amp;gcOldExc</code>
</example>
</lock>
<log>
<summary>
Returns the natural logarithm (base e) of the specified numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression for which LOG( ) returns the value of x in the equation e^x = nExpression. nExpression must be greater than 0.
</param>
<returns>
Numeric
</returns>
<remarks>
The base for the natural logarithm is the constant e. The number of decimal places returned in the result is specified with SET DECIMALS.
</remarks>
<example>
 <code language="X#">CLEAR
? LOG(1)  &amp;&amp; Displays 0.00
STORE EXP(2) TO gneSquare
? LOG(gneSquare)  &amp;&amp; Displays 2.00</code>
</example>
</log>
<log10>
<summary>
Returns the common logarithm (base 10) of the specified numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression for which LOG10( ) returns the value of x in the equation 10^x = nExpression. nExpression must be greater than 0.
</param>
<returns>
Numeric
</returns>
<remarks>
The base for the common logarithm is 10. The number of decimal places returned in the result is specified with SET DECIMALS.
</remarks>
<example>
 <code language="X#">CLEAR
? LOG10(10)  &amp;&amp; Displays 1.00
STORE 100 TO gnBaseTen
? LOG10(gnBaseTen)  &amp;&amp; Displays 2.00
? LOG10(gnBaseTen^2)  &amp;&amp; Displays 4.00</code>
</example>
</log10>
<lookup>
<summary>
Searches a table for the first record with a field matching the specified expression.
</summary>
<returns>
Character, Numeric, Currency, Float, Integer, Double, Date, DateTime, or Logical.
</returns>
<remarks>
If the search is successful, LOOKUP( ) moves the record pointer to the matching record and returns the contents of a specified field in the record.
If LOOKUP( ) does not find the search expression, it returns a blank value the same length and data type as ReturnField. The record pointer is positioned at the end of the file.
If you use LOOKUP( ) to search a parent table, record pointers in all related child tables are moved to the related records.
This function cannot be optimized with Rushmore Query Optimization.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer ORDER company  &amp;&amp; Open Customer table
CLEAR
@ 2,2 SAY LOOKUP(contact, 'Ernst Handel', company, 'company')</code>
</example>
</lookup>
<lower>
<summary>
Returns a specified character expression in lowercase letters.
</summary>
<param name="cExpression">

Specifies the character expression LOWER( ) converts.
</param>
<returns>
Character
</returns>
<remarks>
LOWER( ) converts all uppercase letters (A – Z) in the character expression to lowercase (a – z). All other characters in the character expression remain unchanged.
</remarks>
<example>
 <code language="X#">STORE 'FOX' TO gcName
CLEAR
? LOWER(gcName)  &amp;&amp; Displays fox</code>
</example>
</lower>
<ltrim>
<summary>
Removes all leading spaces or parsing characters from the specified character expression, or all leading zero (0) bytes from the specified binary expression.
</summary>
<param name="Expression">

Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove leading spaces or 0 bytes from, respectively. 

</param>
<param name="nFlags">

Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

cParseChar [, cParseChar2 [, ...]]
Specifies one or more character strings that are trimmed from the beginning of cExpression. If cParseChar isn't included, then leading spaces or 0 bytes are removed from Expression.
<b>Note</b>   The maximum number of strings permitted in cParseChar is 23. 
</param>
<returns>
Character or Varbinary. <b>LTRIM( ) </b>returns the specified expression without leading spaces or parsing characters, or 0 bytes.
</returns>
<remarks>

<b>LTRIM( ) </b>is particularly useful for removing the leading spaces that are inserted when you use the <b>STR( )</b> function to convert a <b>Numeric</b> value to a <b>Character</b> string.
</remarks>
<example>
 <code language="X#">STORE 'Redmond' TO gcCity
STORE '   Washington' TO gcState
CLEAR
? gcCity, gcState  &amp;&amp; Displays Redmond   Washington
? gcCity, LTRIM(gcState)  &amp;&amp; Displays Redmond Washington</code>
</example>
</ltrim>
<lupdate>
<summary>
Returns the date on which a table was last updated.
</summary>
<returns>
Date
</returns>
<remarks>
This function is useful in update procedures.
LUPDATE( ) queries Windows to determine the date a table was last updated. However, the last two digits of the year the table was last updated are stored the table header.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer  &amp;&amp; Open Customer table
CLEAR
? LUPDATE( )  &amp;&amp; Displays date of last update</code>
</example>
</lupdate>
<maketransactable>
<summary>
Allows a free table or free cursor to support transactions.
</summary>
<param name="nWorkArea">

Specifies the work area of the table or cursor for which transactions will be supported.

</param>
<param name="cAlias">

Specifies the alias of the table or cursor for which transactions will be supported.
</param>
<returns>
Logical. Returns a logical true (.T.) if MAKETRANSACTABLE( ) was able to make the free table or cursor support transactions, otherwise a logical false (.F.) is returned.
</returns>
<remarks>
A free table is a table that has not been added to a database with the ADD TABLE Command. A free cursor is a cursor that is created from a free table or with the CREATE CURSOR - SQL Command.
When MAKETRANSACTABLE( ) is used to make a free table or free cursor support transactions, you can use the BEGIN TRANSACTION, END TRANSACTION, and ROLLBACK commands for the free table or free cursor. Use the ISTRANSACTABLE( ) function to determine if a free table or free cursor supports transactions.
When MAKETRANSACTABLE( ) is used to make a free table or free cursor support transactions, the free table or free cursor supports transactions in all work areas and data sessions in which it is opened. MAKETRANSACTABLE( ) makes all open instances of a free table or free cursor support transactions, including those in other data sessions within a single instance of VFP.
If a free table that does not support transactions is open in more than one data session, the free table cannot be made to support transactions. However, you can open a free table that already supports transactions in additional data sessions.
If row buffering is enabled, then a table update is performed if the free table or free cursor has pending changes before the free table or free cursor is made to support transactions. You cannot use MAKETRANSACTABLE( ) to enable transactions for a free table that has table buffering enabled.
To disable transactions for a free table, you must close the free table in all data sessions.
</remarks>
</maketransactable>
<max>
<summary>
Evaluates a set of expressions and returns the expression with the maximum value.
</summary>
<returns>
Character, Numeric, Currency, Double, Float, Date, or DateTime
</returns>
<example>
 <code language="X#">CLOSE DATABASES
CREATE TABLE Random (cValue N(3))
FOR nItem = 1 TO 10  &amp;&amp; Append 10 records,
APPEND BLANK
REPLACE cValue WITH 1 + 100 * RAND( )  &amp;&amp; Insert random values
ENDFOR
CLEAR
LIST  &amp;&amp; Display the values
gnMaximum = 1  &amp;&amp; Initialize minimum value
gnMinimum = 100  &amp;&amp; Initialize maximum value
SCAN
gnMinimum = MIN(gnMinimum, cValue)
gnMaximum = MAX(gnMaximum, cValue)
ENDSCAN
? 'The minimum value is: ', gnMinimum  &amp;&amp; Display minimum value
? 'The maximum value is: ', gnMaximum  &amp;&amp; Display maximum value</code>
</example>
</max>
<mcol>
<summary>
Returns the column position of the mouse pointer in the main X# window or a user-defined window or form.
</summary>
<param name="cWindowName">

Specifies the name of the window or form whose mouse-pointer column position <b>MCOL( )</b> returns.

</param>
<param name="0">

Specifies that the column position of the mouse pointer is returned for the currently active window or form. 

</param>
<param name="nScaleMode">

Specifies the unit of measurement for the value <b>MCOL( )</b> returns. The following table lists the settings for nScaleMode.
0
Foxels. A foxel is equivalent to the average height and width of a character based on the current font of the form in which an object is contained. (Default)
3
Pixels. A pixel is the smallest element that can be displayed on a screen or printer. Pixels are screen-dependent.
</param>
<returns>
Numeric. <b>MCOL( )</b> returns the column position of the mouse pointer in the main X# window, user-defined window, or form.
If you omit cWindowName, and there is no active user-defined window or form, <b>MCOL( )</b> returns the mouse pointer's column position in the main X# window. If you omit cWindowName, and there is an active user-defined window or form, <b>MCOL( )</b> returns the mouse pointer's column position in the active user-defined window or form. <b>MCOL(</b> <b>)</b> returns –1 if the mouse pointer is positioned outside the user-defined window or form, if no mouse driver is loaded, or there is no output window.
</returns>
<remarks>
Using the <b>MCOL( )</b> function without the optional argument 0 may affect the behavior of code on forms when the <b>Form</b> <b>AllowOutput</b> property IS set to false (.F.). For example, the placement of a shortcut menu that is defined in the <b>RightClick</b> event may not display in the proper location if you use the <b>MCOL( )</b> and <b>MROW( )</b> functions to determine where the menu is displayed. In this case, be sure to include 0 in the <b>MCOL( )</b> and <b>MROW( )</b> functions.
</remarks>
</mcol>
<mdown>
<summary>
Included for backward compatibility. Use the Click, MouseDown, MouseUp, and RightClick events instead.
 
Determines whether or not the mouse button is pressed.
</summary>
<returns>
Return value - Logical
</returns>
<remarks>
<br />
MDOWN() returns a true (.T.) or false (.F.) value depending on whether or not the mouse button is pressed. <br />
<br />
In FoxPro for MS-DOS and FoxPro for Windows, MDOWN() returns values for just the left mouse button.<br />
<br />
If the mouse button is depressed when MDOWN() is executed, true (.T.) is returned. If the mouse button isn't depressed when MDOWN() is executed, false (.F.) is returned.<br />
<br />

</remarks>
</mdown>
<mdx>
<summary>
Returns the name of the open .cdx compound index file that has the specified index position number.
</summary>
<param name="nIndexNumber">

Specifies which compound index file name to return. If the table has a structural compound index file and nIndexNumber is 1, the name of the structural compound index file (which is always the same as the name of the table) is returned. If nIndexNumber is 2, the name of the first compound index file specified with USE or SET INDEX is returned. If nIndexNumber is 3, the second compound index file name is returned, and so on. If nIndexNumber is greater than the number of open compound index files, an empty string is returned.
If the table doesn't have a structural compound index file and nIndexNumber is 1, the name of the first compound index file specified with USE or SET INDEX is returned. If nIndexNumber is 2, the second compound index file name is returned, and so on. If nIndexNumber is greater than the number of open compound index files, an empty string is returned. 

</param>
<param name="nWorkArea">

Specifies the work area number for compound index files open in work areas other than the current one. If you omit this optional argument, names of compound index files are returned for the current work area.

</param>
<param name="cTableAlias">

Specifies the table alias for compound index files open in work areas other than the current one. If you omit this optional argument, names of compound index files are returned for the current work area.
</param>
<returns>
Character
</returns>
<remarks>
MDX( ) is identical to CDX( ).
Index files can be opened for a table with the INDEX clause of the USE command or with SET INDEX. A structural compound index file is automatically opened with its table. MDX( ) ignores any .idx index files specified with USE or with SET INDEX.
Use TAG( ) to return tag names from a compound index file; use NDX( ) to return the name of an open .idx index file.
In X# for Windows, when SET FULLPATH is ON, MDX( ) returns the path to the .cdx file with the .cdx file name. When SET FULLPATH is OFF, MDX( ) returns the drive the .cdx file resides on with the .cdx file name.
</remarks>
</mdx>
<mdy>
<summary>
Returns the specified date or datetime expression in month-day-year format with the name of the month spelled out.
</summary>
<param name="dExpression">

Specifies the date expression to return in month-day-year format.

</param>
<param name="tExpression">

Specifies the datetime expression to return in month-day-year format.
</param>
<returns>
Character
</returns>
<remarks>
If SET CENTURY is OFF, the character expression is returned in a month dd, yy format. If SET CENTURY is ON, the format is month dd, yyyy.
</remarks>
<example>
 <code language="X#">SET CENTURY OFF
CLEAR
? Longdate({^1998-02-16})  &amp;&amp; Displays Monday, February 16, 98
SET CENTURY ON
? Longdate({^1998-02-16})  &amp;&amp; Displays Monday, February 16, 1998
*** LongDate ***
FUNCTION longdate
PARAMETERS gdDate
RETURN CDOW(gdDate) + ', ' + MDY(gdDate)</code>
</example>
</mdy>
<memlines>
<summary>
Returns the number of lines in a memo field.
</summary>
<param name="MemoFieldName">

Specifies the name of the memo field. If the memo field is in a table that isn't open in the current work area, preface the memo field name with the table alias and a period.
</param>
<returns>
Numeric
</returns>
<remarks>
The number of lines in a memo field is determined by the current value of SET MEMOWIDTH.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
SET TALK OFF
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE employee  &amp;&amp; Open Employee table
SET MEMOWIDTH TO 65
gnLine = 1
GOTO 2
SCAN NEXT 3
gnMemoSize = MEMLINES(notes)
IF gnMemoSize = 0
STORE .T. TO glNoMemo
STORE 1 TO gnMemoSize
ELSE
STORE .F. TO glNoMemo
ENDIF
IF gnLine + gnMemoSize &gt; 65
EJECT
gnLine = 1
ENDIF
@ gnLine,2 SAY 'Last Name: '+ last_name
gnLine = gnLine +1
@ gnLine ,2 SAY 'Notes: '
?? IIF(glNoMemo, 'No notes ',notes)
gnLine = gnLine + gnMemoSize + 2
IF gnLine &gt; 24
gnLine = 1
CLEAR
ENDIF
ENDSCAN</code>
</example>
</memlines>
<memory>
<summary>
Returns the amount of memory available to run an external program.
</summary>
<returns>
MEMORY( )Return Value
Numeric
</returns>
<remarks>
In X#, MEMORY( ) always returns 640.
MEMORY( ) is similar to SYS(12), with two exceptions:

MEMORY( ) returns the amount of available memory in kilobytes; SYS(12) returns the amount of memory in bytes.
MEMORY( ) returns a numeric expression. SYS(12) returns its value as a character string.
</remarks>
</memory>
<menu>
<summary>
Returns the name of the active menu bar as an uppercase character string.
</summary>
<returns>
MENU( )Return Value
Character
</returns>
<remarks>
MENU( ) returns an empty string if no menu is active. Use the Menu Designer to create a menu and activate it.
</remarks>
<example>
 <code language="X#">*** Save this program as MENUEXAM.PRG in the default VFP directory.***
CLEAR
SET SYSMENU SAVE
SET SYSMENU TO
DEFINE PAD padSys OF _MSYSMENU PROMPT '\&lt;System' COLOR SCHEME 3 ;
KEY ALT+S, ''
DEFINE PAD padEdit OF _MSYSMENU PROMPT '\&lt;Edit' COLOR SCHEME 3 ;
KEY ALT+E, ''
DEFINE PAD padRecord OF _MSYSMENU PROMPT '\&lt;Record' COLOR SCHEME 3 ;
KEY ALT+R, ''
DEFINE PAD padWindow OF _MSYSMENU PROMPT '\&lt;Window' COLOR SCHEME 3 ;
KEY ALT+W, ''
DEFINE PAD padReport OF _MSYSMENU PROMPT 'Re\&lt;ports' COLOR SCHEME 3 KEY ALT+P, ''
DEFINE PAD padExit OF _MSYSMENU PROMPT 'E\&lt;xit' COLOR SCHEME 3 ;
KEY ALT+X, ''
ON SELECTION MENU _MSYSMENU ;
DO choice IN menuexam WITH PAD(), MENU()
PROCEDURE choice
PARAMETER gcPad, gcMenu
WAIT WINDOW 'You chose ' + gcPad + ;
' from menu ' + gcMenu NOWAIT
IF gcPad = 'PADEXIT'
SET SYSMENU TO DEFAULT
ENDIF</code>
</example>
</menu>
<message>
<summary>
Returns the current error message or the program line that caused the error.
</summary>
<returns>
Character. <b>MESSAGE( )</b> returns the current error message as a character string or the contents of the program line causing the error.
</returns>
<remarks>
Unlike <b>ERROR( )</b>, <b>MESSAGE( )</b> is not reset by <b>RETURN</b> or <b>RETRY</b>.
</remarks>
<example>
 <code language="X#">ON ERROR DO Errhand
*** The next line should generate an error ***
USE Nodatabase
ON ERROR     &amp;&amp; Restore system error handler.
PROCEDURE Errhand
? 'Line of code with error: ' + MESSAGE(1)
? 'Error number: ' + STR(ERROR( ))
? 'Error message: ' + MESSAGE( )</code>
</example>
</message>
<messagebox>
<summary>
Displays a user-defined dialog box.
</summary>
<param name="eMessageText">

Specifies the text that appears in the dialog box. You can also specify any valid X# function, object, or data type instead of eMessageText. The maximum amount of text you can specify is 1024 characters.
X# converts object references to the string, "(Object)". If you specify a function that evaluates to a noncharacter value, X# automatically uses the <b>TRANSFORM( )</b> function to provide the character equivalent. In the following example, a character type date is returned and passed to <b>MESSAGEBOX( )</b>:
 <code language="X#">MESSAGEBOX(DATE())</code>
To move a portion of the message to the next line in the dialog box, use a carriage return, CHR(13), in eMessageText. The height and width of the dialog box increases as needed to contain eMessageText.

</param>
<param name="nDialogBoxType">

Specifies the buttons and icons that appear in the dialog box, the default button when the dialog box is displayed, and the behavior of the dialog box.
In the following tables, the dialog box button values 0 to 5 specify the buttons that appear in the dialog box. The icon values 16, 32, 48, and 64 specify the icon that appears in the dialog box. The default values 0, 256, and 512 specify which button in the dialog box is the default button. The default button is selected when the dialog box is displayed. Omitting nDialogBoxType is identical to specifying a value of 0 for nDialogBoxType.   
OK button only
OK and Cancel buttons
Abort, Retry, and Ignore buttons
Yes, No, and Cancel buttons
Yes and No buttons
Retry and Cancel buttons
Stop sign
Question mark
Exclamation point
Information (i) icon
First button
Second button
Third button
nDialogBoxType can be the sum of up to three values, one value from each of the preceding tables. For example, if nDialogBoxType is 290 (2+32+256), the specified dialog box has the following characteristics:   
Abort, Retry, and Ignore buttons.
The message box displays the question mark icon.
The second button, Retry, is the default.
Additional information about the constants is available in the FoxPro.h file, located in the X# home directory. Using defined constants such as MB_ABORTRETRYIGNORE + MB_ICONQUESTION + MB_DEFBUTTON2 can be more readable than 2 + 32 + 256.   
The question mark icon is no longer recommended, because it does not clearly represent a specific type of message and because the phrasing of a message as a question could apply to any message type. In addition, users could confuse the message symbol question mark with Help Information. Therefore, it is not recommended to use the question mark symbol in your message boxes. The system continues to support inclusion only for backwards compatibility.

</param>
<param name="cTitleBarText">

Specifies the text that appears in the title bar of the dialog box. If you omit cTitleBarText, the title "X#" appears in the title bar.

</param>
<param name="nTimeout">

Specifies the number of milliseconds X# displays eMessageText without input from the keyboard or the mouse before clearing eMessageText. You can specify any valid timeout value. A value of less than 1 never times out until user enters input and behaves the same as omitting the nTimeout parameter.
</param>
<returns>
Numeric data type. <b>MESSAGEBOX( )</b> returns a value that indicates which button was chosen in the dialog box. The following table lists the values <b>MESSAGEBOX( )</b> returns for each button.
1
OK
2
Cancel
3
Abort
4
Retry
5
Ignore
6
Yes
7
No
In dialog boxes with a Cancel button, pressing ESC to exit the dialog box returns the same value (2) as choosing Cancel.

<b>MESSAGEBOX( )</b> returns a value of -1 when a timeout occurs.
</returns>
<remarks>
The shortest abbreviation for <b>MESSAGEBOX( )</b> is <b>MESSAGEB( )</b>.
The <b>MESSAGEBOX( )</b> function uses smart parameters in that the parameter type determines which parameter is used. The first parameter is required and is always eMessageText. However, the optional second parameter can be nDialogBoxType if the type is <b>Numeric</b> or cTitleBarText if type is <b>Character</b>. The nTimeout parameter is always assumed for the second optional numeric parameter passed. Valid examples include:
 <code language="X#">MESSAGEBOX("HELLO","MyTitle",68,6000)
MESSAGEBOX("HELLO",68,"MyTitle",6000)
MESSAGEBOX("HELLO",68,6000)
MESSAGEBOX("HELLO",68,6000,"MyTitle")</code>
</remarks>
<example>
 <code language="X#">eMessageTitle = 'My Application'
eMessageText = 'Record not found. Would you like to search again?'
nDialogType = 4 + 16 + 256
*  4 = Yes and No buttons
*  16 = Stop sign icon
*  256 = Second button is default
nAnswer = MESSAGEBOX(eMessageText, nDialogType, eMessageTitle)
DO CASE
CASE nAnswer = 6
WAIT WINDOW 'You chose Yes'
CASE nAnswer = 7
WAIT WINDOW 'You chose No'
ENDCASE</code>
</example>
</messagebox>
<min>
<summary>
Evaluates a set of expressions and returns the expression with the minimum value.
</summary>
<returns>
Character, Numeric, Currency, Double, Float, Date, or DateTime
</returns>
<example>
 <code language="X#">CLOSE DATABASES
CREATE TABLE Random (cValue N(3))
FOR nItem = 1 TO 10  &amp;&amp; Append 10 records,
APPEND BLANK
REPLACE cValue WITH 1 + 100 * RAND( )  &amp;&amp; Insert random values
ENDFOR
CLEAR
LIST  &amp;&amp; Display the values
gnMaximum = 1  &amp;&amp; Initialize minimum value
gnMinimum = 100  &amp;&amp; Initialize maximum value
SCAN
gnMinimum = MIN(gnMinimum, cValue)
gnMaximum = MAX(gnMaximum, cValue)
ENDSCAN
? 'The minimum value is: ', gnMinimum  &amp;&amp; Display minimum value
? 'The maximum value is: ', gnMaximum  &amp;&amp; Display maximum value</code>
</example>
</min>
<mline>
<summary>
Returns a specific line from a <b>Memo</b> field as a character string.
<b>MLINE( )</b> is primarily a text processing function; therefore, the results from processing binary values might not be as expected. For example, <b>MLINE( )</b> might return different results depending on the <b>SET MEMOWIDTH</b> setting. <b>MLINE( )</b> might interpret binary values as line breaks or truncate binary values unexpectedly. It is recommended that you use the <b>ALINES( )</b> function instead to manipulate binary values.
</summary>
<param name="MemoFieldName">

Specifies the name of the memo field from which <b>MLINE( )</b> returns a line. If the memo field is in a table open in a non-current work area, preface the memo field name with a period and the table alias.

</param>
<param name="nLineNumber">

Specifies the number of the line to return from the memo field. If nLineNumber is negative, 0, or greater than the number of lines in the memo field, <b>MLINE( )</b> returns an empty string.
<b>MLINE( )</b> trims any trailing spaces from the line specified with nLineNumber. 

</param>
<param name="nNumberOfCharacters">

Specifies the number of characters from the beginning of the memo field after which <b>MLINE( )</b> returns the specified line. 
The <b>_MLINE </b>system variable is typically used for nNumberOfCharacters. <b>_MLINE</b> is automatically adjusted each time <b>MLINE( )</b> is called. In recursive procedures that return lines from large memo fields, you can obtain the best performance by including <b>_MLINE</b> as nNumberOfCharacters. For more information, see _MLINE System Variable.
</param>
<returns>

<b>Character</b> or <b>Varbinary</b>. <b>MLINE( )</b> returns a character string from a specific line in a <b>Memo</b> field. When using <b>MLINE( )</b> with binary values, such as <b>Varbinary</b> and <b>Blob</b>, the return value has type <b>Varbinary</b>.
</returns>
<remarks>
The length and number of the lines in a memo field are determined by the current value of <b>SET MEMOWIDTH</b> (the default line length is 50 characters). If a carriage return is encountered, no additional characters are returned. The current _WRAP setting determines how the memo field line is displayed.
When searching a memo field for a character string, you can use <b>ATLINE( )</b> or <b>ATCLINE( )</b> to return the line number of the line in which the character string is found. Use this line number in <b>MLINE( )</b> to return the contents of the line from the memo field.
</remarks>
<example>
 <code language="X#">CLEAR
SET TALK OFF
SET MEMOWIDTH TO 50
CLOSE DATABASES
CREATE TABLE tmemo (name c(10), notes m)
APPEND BLANK                  &amp;&amp; Add a record
WAIT WINDOW 'Filling memo field - takes several seconds' NOWAIT
*** Fill the memo field  ***
FOR gnOuterLoop = 1 TO 5         &amp;&amp; loop 5 times
FOR gnAlphabet = 65 TO 75   &amp;&amp; letters A to H
REPLACE notes WITH REPLICATE(CHR(gnAlphabet), 10) ;
+ CHR(13) ADDITIVE
NEXT
NEXT
*** Display all lines from the memo field ***
STORE MEMLINES(notes) TO gnNumLines   &amp;&amp; Number of lines in memo field
STORE SECONDS( ) TO gnBegin      &amp;&amp; Beginning time
FOR gnCount = 1 TO gnNumLines   &amp;&amp; Loop for # of lines in memo field
? <b>MLINE(</b>notes, gnCount<b>)</b>      &amp;&amp; Display each line
NEXT
? STR(SECONDS( ) - gnBegin, 4, 2) + ' seconds'   &amp;&amp; Total time
*** Preferable method using _MLINE in MLINE( ) ***
*** Display all lines from the memo field ***
WAIT 'Press a key to see the preferred method' WINDOW
CLEAR
STORE 0 TO _MLINE             &amp;&amp; Reset _MLINE to zero
STORE SECONDS( ) TO gnBegin      &amp;&amp; Beginning time
FOR count = 1 TO gnNumLines      &amp;&amp; Loop for # of lines in memo field
? <b>MLINE(</b>notes, 1, _MLINE<b>)</b>      &amp;&amp; Display each line
NEXT
? STR(SECONDS( ) - gnBegin, 4, 2) + ' seconds'   &amp;&amp; Total time
SET TALK ON
CLOSE DATABASES
ERASE tmemo.dbf
ERASE tmemo.fpt</code>
</example>
</mline>
<mod>
<summary>
Divides one numeric expression by another numeric expression and returns the remainder.
</summary>
<param name="nDividend">

Specifies the dividend. The number of decimal places in nDividend determines the number of decimal places in the return value.

</param>
<param name="nDivisor">

Specifies the divisor. A positive number is returned if nDivisor is positive, and a negative number is returned if nDivisor is negative.
</param>
<returns>
Numeric
</returns>
<remarks>
The modulus function MOD( ) and the % operator return identical results.
</remarks>
<example>
 <code language="X#">CLEAR
? MOD(36,10)  &amp;&amp; Displays 6
? MOD((4*9), (90/9))  &amp;&amp; Displays 6
? MOD(25.250,5.0)  &amp;&amp; Displays 0.250
? IIF(MOD(YEAR(DATE( )), 4) = 0, 'Summer Olympics this year';
, 'No Summer Olympics this year')</code>
</example>
</mod>
<month>
<summary>
Returns the number of the month for a given Date or DateTime expression.
</summary>
<param name="dExpression">

Specifies the Date expression for which you want MONTH( ) to return the month number.

</param>
<param name="tExpression">

Specifies the DateTime expression for which you want MONTH( ) to return the month number.
</param>
<returns>
Numeric
</returns>
<remarks>
MONTH( ) returns a number from 1 through 12. January is month 1, and December is month 12.
</remarks>
<example>
 <code language="X#">CLEAR
? DATE( )  &amp;&amp; Displays today's date
? MONTH(DATE( ))  &amp;&amp; Displays the month number
STORE {^1998-05-03} TO gdBuy
STORE MONTH(gdBuy + 31) TO gdMonth
? gdMonth  &amp;&amp; Displays 6</code>
</example>
</month>
<mrkbar>
<summary>
Determines whether a menu item on a user-defined or X# system menu is marked.
</summary>
<param name="cMenuName">

Specifies the name of the menu containing the menu item. The menu can be a X# system menu (such as _MFILE, MEDIT, or _MDATA).

</param>
<param name="nMenuItemNumber">

Specifies the number of a menu item in a user-defined menu. A menu item's number is specified when the menu item is created with DEFINE BAR.

</param>
<param name="cSystemMenuItemName">

Specifies the name of a X# system menu item. For example, the following command displays a logical value specifying if the New menu item on the File menu is marked.  
 <code language="X#">? MRKBAR('_MFILE', _MFI_NEW)</code>
</param>
<returns>
Logical
</returns>
<remarks>
Use SET MARK OF to mark or unmark a menu item.
If the specified menu item is marked, MRKBAR( ) returns true (.T.); otherwise, MRKBAR( ) returns false (.F.).
For an example of using MRKBAR( ), see CNTBAR( ).
</remarks>
</mrkbar>
<mrkpad>
<summary>
Determines whether a menu title on a user-defined menu bar or on the X# system menu bar is marked.
</summary>
<param name="cMenuBarName">

Specifies the name of the menu bar containing the menu title.

</param>
<param name="cMenuTitleName">

Specifies the name of the menu title.
</param>
<returns>
Logical
</returns>
<remarks>
Use SET MARK OF to mark or unmark a menu title.
If the specified menu title is marked, MRKPAD( ) returns true (.T.); otherwise, MRKPAD( ) returns false (.F.).
</remarks>
<example>
 <code language="X#">*** Name this program MARKPAD.PRG ***
CLEAR
SET SYSMENU SAVE
SET SYSMENU TO
SET MARK OF MENU _MSYSMENU TO CHR(4)
PUBLIC glMarkPad
glMarkPad = .T.
DEFINE PAD padSys OF _MSYSMENU PROMPT '\&lt;System'  COLOR SCHEME 3 ;
KEY ALT+S, ''
DEFINE PAD padEdit OF _MSYSMENU PROMPT '\&lt;Edit'  COLOR SCHEME 3 ;
KEY ALT+E, ''
DEFINE PAD padRecord OF _MSYSMENU PROMPT '\&lt;Record'  COLOR SCHEME 3 ;
KEY ALT+R, ''
DEFINE PAD padWindow OF _MSYSMENU PROMPT '\&lt;Window'  COLOR SCHEME 3 KEY ALT+W, ''
DEFINE PAD padReport OF _MSYSMENU PROMPT 'Re\&lt;ports' COLOR SCHEME 3 ;
KEY ALT+P, ''
DEFINE PAD padExit OF _MSYSMENU PROMPT 'E\&lt;xit'  COLOR SCHEME 3 ;
KEY ALT+X, ''
ON SELECTION MENU _MSYSMENU ;
DO choice IN markpad WITH PAD( ), MENU( )
PROCEDURE choice
PARAMETER gcPad, gcMenu
WAIT WINDOW 'You chose ' + gcPad + ;
' from menu ' + gcMenu NOWAIT
SET MARK OF PAD (gcPad) OF _MSYSMENU TO ;
! MRKPAD('_MSYSMENU', gcPad)
glMarkPad= ! glMarkPad
IF gcPad = 'PADEXIT'
SET SYSMENU TO DEFAULT
ENDIF</code>
</example>
</mrkpad>
<mrow>
<summary>
Returns the row position of the mouse pointer in the main X# window or in a user-defined window or form.
</summary>
<param name="cWindowName">

Specifies the name of a window whose mouse-pointer row position <b>MROW( )</b><b> </b>returns.

</param>
<param name="0">

Specifies that the row position of the mouse pointer is returned for the currently active window or form.

</param>
<param name="nScaleMode">

Specifies the unit of measurement for the value <b>MROW( )</b> returns. The settings for nScaleMode are:
0
Foxels. (Default)
A foxel is equivalent to the average height and width of a character based on the current font of the form in which an object is contained. 
3
Pixels. 
A pixel is the smallest element that can be displayed on a screen or printer. Pixels are screen-dependent.
</param>
<returns>
Numeric. <b>MROW( )</b> returns the following under specific conditions:
If there is no active user-defined window, and you omit the optional argument, <b>MROW( )</b> returns the main X# window row position of the mouse pointer.
If there is an active user-defined window, and you omit the optional argument, <b>MROW( )</b> returns the mouse-pointer row coordinate relative to the active user-defined window.
If the mouse pointer is positioned outside the user-defined window or if no mouse driver is loaded and there is no output window, <b>MROW( )</b> returns a value of -1.
</returns>
<remarks>
Using the <b>MROW( )</b> function without the optional argument 0 may affect the behavior of code on forms when the <b>Form</b> <b>AllowOutput</b> property IS set to false (.F.). For example, the placement of a shortcut menu that is defined in the <b>RightClick</b> event may not display in the proper location if you use the <b>MROW( )</b> and <b>MCOL( )</b> functions to determine where the menu is displayed. In this case, be sure to include 0 in the <b>MROW( )</b> and <b>MCOL( )</b> functions.
</remarks>
</mrow>
<mwindow>
<summary>
Returns the name of the window over which the mouse pointer is positioned.
</summary>
<param name="cWindowName">

Specifies a window name. If the mouse pointer is positioned over the specified window, MWINDOW( ) returns true (.T.); otherwise, MWINDOW( ) returns false (.F.).
</param>
<returns>
Character, Logical
</returns>
<remarks>
If you omit the optional window name, MWINDOW( ) returns the name of the window over which the mouse pointer is positioned, or an empty string if the mouse pointer is positioned over the main X# window or over any other window that is not part of X#.
</remarks>
</mwindow>
<ndx>
<summary>
Returns the name of an open index (.IDX) file for the current or specified table.
</summary>
<param name="nIndexNumber">

Specifies which .idx file name to return. USE and SET INDEX both support an index file list that makes it possible for you to open .idx files for a table. The order of the file names in this index file list determines which .idx file name NDX( ) returns. For example, if nIndexNumber is 1, NDX( ) returns the name of the first .idx file in the index file list; if nIndexNumber is 2, NDX( ) returns the second .idx file name, and so on. NDX( ) ignores names of compound index (.cdx) files in the index file list.
NDX( ) returns an empty string if nIndexNumber is greater than the number of .idx files in the index file list. 

</param>
<param name="nWorkArea">

Specifies the work area number for .IDX files open in a work area other than the current one. NDX( ) returns an empty string if no table is open in the work area you specify. If you omit nWorkArea, NDX( ) returns the names of .idx files open with the table in the current work area.

</param>
<param name="cTableAlias">

Specifies the table alias for .idx files open in a work area other than the current one. If no table has the alias you include, X# generates an error message. If you omit cTableAlias, NDX( ) returns the names of .idx files open with the table in the current work area.
</param>
<returns>
Character
</returns>
<remarks>
The CDX( ) and MDX( ) functions can be used to return the names of open compound (.cdx) index files.
In X# for Windows, when SET FULLPATH is ON, NDX( ) returns the path to the .idx file with the .idx file name. When SET FULLPATH is OFF, NDX( ) returns the drive the .idx file resides on with the .idx file name.
</remarks>
</ndx>
<newobject>
<summary>
Creates a new class or object directly from a visual class library (.vcx) file or program (.prg) file without opening the file. 
</summary>
<param name="cClassName">

Specifies the class or object from which the new class or object is created.

</param>
<param name="cModule">

Specifies a .vcx file or X# program (.prg, .fxp, .mpr, .app, .exe, and so on) containing the class or object specified with cClassName. The default is a .vcx file. If you specify a program file, you must include an extension. 
A class library can have an alias. To specify a class or object from a class library with an alias, include the class library alias followed by a period and the object name.
When possible, specify the compiled program name (.fxp) when a class is stored in a program file (.prg). This ensures that the class is loaded from the proper class definition file.
If cModule is omitted, or is the empty string or the null value, X# searches for the class or object in the following order:   
X# base classes.
Classes in the current program.
Class libraries opened with SET CLASSLIB.
Classes in procedure files opened with SET PROCEDURE.
Classes in the X# program execution chain.
The OLE registry if SET OLEOBJECT is ON.

</param>
<param name="cInApplication">

Specifies the X# application (.exe or .app) containing the .vcx file you specify with cModule. You must include an extension for the application. CInApplication is ignored if cModule is omitted, or if cInApplication is the empty string or the null value.
If you want to use the cInApplication parameter, you must specify the name of .vcx file for cModule. You cannot pass the name of a .prg file or compiled program (.fxp). 

</param>
<param name="0">

Specifies that the class or object is instantiated without executing any of the event or method code in the class or object. This feature is not supported in runtime applications.
All child classes or objects of the parent class are also instantiated. The event or method code in the child class or object isn't executed.
This option is provides the ability to view the structure of a class or object (with the AMEMBERS( ) Function, for example) without opening the class or object in the Class or Form Designer.
Note that code in the class or object should never be executed - code execution is not supported and can make X# unstable. You should never explicitly call an event or method, or set properties. Setting properties can call Access and Assign methods.

eParameter1, eParameter2, ... 
Specifies optional parameters that are passed to the Init event procedure for the class or object.
</param>
<returns>
Object
</returns>
<remarks>
To assign the object reference returned by NEWOBJECT( ) to a variable or array element, use the equal sign (=) or STORE command. If an object assigned to a variable or array element is released, the variable or array element contains the null value. To remove the variable or array element from memory, use the RELEASE command.
For NEWOBJECT( ), X# performs an internal SET CLASSLIB or SET PROCEDURE for the second or third parameters using the ADDITIVE clause where the parameters are first used to determine the search order. If these parameters already exist in the SET CLASSLIB or SET PROCEDURE list, X# rearranges the order in the list so they come first. X# then locates all the classes, creates the object, and calls the Init events. Finally, X# restores the original SET CLASSLIB or SET PROCEDURE list if the installation did not change list.
OLE objects are created with the following syntax for cClassName:
 <code language="X#">ApplicationName.Class</code>
For example, to create a Microsoft Excel worksheet, which supports Automation, use the following syntax:
 <code language="X#">oExcelSheet = NEWOBJECT('Excel.Sheet')</code>
</remarks>
</newobject>
<normalize>
<summary>
Converts an expression, supplied by a user, into the same form of the expression used internally by X#. You can use the normalized form of an expression to make more accurate comparisons with the expressions returned from X# commands or functions.
</summary>
<param name="cExpression">

Specifies the character expression to normalize.
</param>
<returns>
Character
</returns>
<remarks>

<b>NORMALIZE( )</b> returns a character string from the character expression cExpression with the following changes. <b>NORMALIZE( )</b>:  
Converts the character expression to uppercase. However, it does not change embedded strings. An example of an embedded string is "Hello" in the character expression "LEFT('Hello',1)".
Expands any abbreviated X# keywords in the character expression to their full length.
Converts to periods any -&gt; operators that separate aliases from field names.
Surrounds by periods the logical operators AND, OR and NOT: .AND. .OR. .NOT.
In filter expressions, removes any blank spaces between terms.
Checks the syntax of any X# commands or functions within the character expression, However, it does not evaluate the expression. If the syntax is incorrect, X# generates a syntax error. <b>NORMALIZE( )</b> does not look for any fields, tables, memory variables, user-defined functions, or other references in the character expression.
For example, a user may enter an index expression such as the following in the Expression Builder:
 <code language="X#">UPPE(cust-&gt;lname) + UPPE(cust-&gt;fname)</code>
While this is a valid X# index key expression, it is difficult to compare this to the return values from a X# function like <b>KEY( )</b>. <b>NORMALIZE( )</b> returns the following character string for the expression above:
 <code language="X#">UPPER(CUST.LNAME) + UPPER(CUST.FNAME)</code>
You can easily compare this to the value returned by a function like <b>KEY( )</b>. This enables you to verify the existence of an index or index tag with the user-supplied index expression.
Also, you can use NORMALIZE to compare the results of <b>SET("Filter")</b> or <b>FILTER( )</b>. For example, you could create the following filter expression:
 <code language="X#">STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
MyFilter
USE Addresses
LINK Word.Document.8 "C:\\Documents and Settings\\v-rodhil\\My Documents\\DocStudio\\Projects\\dv_foxhelp91\\cc1ce3c4-1dc6-4d8f-9406-c8bab4d6a40a.xml" "OLE_LINK1" \a \r  \* MERGEFORMAT STORE '"VIRGINIA" $ UPPER(state) AND NOT "MAINE" $ UPPER(state)' TO
MyFilter
SET FILTER TO &amp;MyFilter</code>
However, the value returned by <b>SET("Filter")</b> or <b>FILTER( ) </b>will not exactly match the original filter.
 <code language="X#">? SET("FILTER") == MyFilter  &amp;&amp; .F.</code>

<b>SET("FILTER")</b> or <b>FILTER( )</b> return the following:
 <code language="X#">"VIRGINIA"$UPPER(STATE).AND..NOT."MAINE"$UPPER(STATE)</code>
To ensure a correct comparison, use:
 <code language="X#">? NORMALIZE(MyFilter) == SET("FILTER")  &amp;&amp; .T."</code>
</remarks>
</normalize>
<numlock>
<summary>
Returns the current mode of the NUM LOCK key or sets the mode of the NUM LOCK key on or off.
</summary>
<param name="lExpression">

Turns the NUM LOCK key on or off. If lExpression is true (.T.), the NUM LOCK key is turned on; if lExpression is false (.F.), the NUM LOCK key is turned off. NUMLOCK( ) returns a logical value corresponding to the NUM LOCK key setting before NUMLOCK(.T.) or NUMLOCK(.F.) is issued.
</param>
<returns>
Logical
</returns>
<remarks>
NUMLOCK( ) returns true (.T.) if the NUM LOCK key is on (pressing a key on the numeric keypad returns a number), or false (.F.) if NUM LOCK is off (pressing a key on the numeric keypad moves the cursor).
</remarks>
<example>
 <code language="X#">gcOldLock = NUMLOCK( )  &amp;&amp; Save original setting
WAIT WINDOW 'Press a key to turn Num Lock on'
= NUMLOCK(.T.)  &amp;&amp; Turn Num Lock on
WAIT WINDOW 'Press a key to turn Num Lock off'
= NUMLOCK(!NUMLOCK( ))  &amp;&amp; Toggle Num Lock to the opposite value
WAIT WINDOW 'Press a key to restore original Num Lock setting'
= NUMLOCK(gcOldLock)     &amp;&amp; Return to original setting</code>
</example>
</numlock>
<nvl>
<summary>
Returns a non-null value from two expressions.
</summary>
<returns>
Character, Date, DateTime, Numeric, Currency, Logical, or the null value
</returns>
<remarks>
Use NVL( ) to remove null values from calculations or operations where null values are not supported or are not relevant.
</remarks>
<example>
 <code language="X#">STORE .NULL. TO glMyNull  &amp;&amp; A memory variable containing the null value
CLEAR
? NVL(.T., glMyNull)  &amp;&amp; Displays .T.
? NVL(glMyNull, glMyNull)  &amp;&amp; Displays .NULL.</code>
</example>
</nvl>
<objnum>
<summary>
Included for backward compatibility. Use the TabIndex Property for controls instead.
Returns the object number of an @ ... GET control.
</summary>
<returns>
Return value - Numeric
</returns>
<remarks>
<br />
You can use @ ... GET and @ ...EDIT to create controls, sometimes called objects. These controls are fields, check boxes, lists, popups; invisible, push, and radio buttons; spinners and text-editing regions. OBJNUM() returns a number that corresponds to a control's creation order in a set of controls.<br />
<br />

</remarks>
<example>
The following example creates a window and places radio buttons in the window so you can move the record pointer through an open table. If a table isn't open, the Open dialog is displayed so you can select a table to open.<br />
<br />




 






<code language="X#">SET TALK OFF
DEFINE WINDOW gotodialog FROM 9, 17 TO 19,61 ;
FLOAT NOCLOSE SHADOW DOUBLE COLOR SCHEME 5
PRIVATE file,lastobj,enter,tab,shifttab,up,down,left,right
*** Assign lastkey values ***
enter		= 13
tab			= 9
shifttab	= 15
up			= 5
down		= 24
right		= 4
left		= 19
lastobj	= 1
*** Open a table ***
IF EMPTY(DBF())
file = GETFILE('DBF','Pick a table')
IF EMPTY(FILE)
WAIT WINDOW 'Cancelled' NOWAIT
RETURN
ENDIF
USE (file)
ENDIF
*** Draw the fields ***
ACTIVATE WINDOW gotodialog
@ 0,1 TO 8,25
@ 1,3 GET radio PICTURE '@*RVN \Top;\Bottom;\Record;\Skip' ;
SIZE 1,10,1 DEFAULT 1 WHEN radwhen() VALID radvalid()
@ 5,15 GET recordnum SIZE 1,8 DEFAULT 0 ;
FUNCTION 'Z' WHEN recwhen() VALID recvalid() DISABLE
@ 7,15 GET skipnum SIZE 1,8 DEFAULT 0 ;
FUNCTION 'Z' WHEN skipwhen() DISABLE
@ 3,29 GET okcancel PICTURE '@*VT \!\Goto;\?\Cancel' ;
SIZE 1,10,2 DEFAULT 0 WHEN okwhen() VALID okvalid()
READ CYCLE
RELEASE WINDOW gotodialog
*** Place cursor in recordnum field if it is enabled ***
*** and the last object selected was the radio button ***
*** record. Do this only if Enter, Tab, Down Arrow or ***
*** Right Arrow is pressed to exit the record radio button. ***
FUNCTION radwhen
IF _CUROBJ = OBJNUM(radio)+3 AND radio = OBJNUM(radio)+2 ;
AND lastobj = OBJNUM(radio)+2 ;
AND (LASTKEY() = enter OR LASTKEY() = tab ;
OR LASTKEY() = down OR LASTKEY() = right)
_CUROBJ = OBJNUM(recordnum)
lastobj = OBJNUM(recordnum)
RETURN
ENDIF
*** Place cursor in recordnum field if it is enabled ***
*** and the last object selected was the radio button ***
*** skip. Do this only if Shift+Tab, Up Arrow or ***
*** Left Arrow is pressed to exit the skip radio button. ***
IF _CUROBJ = OBJNUM(radio)+2 AND radio = OBJNUM(radio)+2 ;
AND lastobj = OBJNUM(radio)+3 AND (LASTKEY() = shifttab ;
OR LASTKEY() = left OR LASTKEY() = up)
lastobj = _CUROBJ
_CUROBJ = OBJNUM(recordnum)
RETURN
ENDIF
lastobj = _CUROBJ
*** Enable and disable appropriate get fields when ***
*** a radio button is selected. ***
FUNCTION radvalid
DO CASE
CASE radio = 1 or radio = 2
STORE 0 TO recordnum,skipnum
SHOW GET recordnum DISABLED
SHOW GET skipnum DISABLED
CASE radio = 3
STORE 0 TO skipnum
SHOW GET recordnum ENABLED
SHOW GET skipnum DISABLED
_CUROBJ = OBJNUM(recordnum)
CASE radio = 4
STORE 0 TO recordnum
SHOW GET recordnum DISABLED
SHOW GET skipnum ENABLED
_CUROBJ = OBJNUM(skipnum)
ENDCASE
*** Routine to bypass the recno field and move to the goto button. ***
*** Put cursor on goto push button if the last object selected ***
*** was the radio button skip. Do this only if Tab, Down Arrow ***
*** or Right Arrow is pressed to exit the skip radio button. ***
FUNCTION recwhen
IF lastobj = OBJNUM(radio)+3 AND (LASTKEY() = tab ;
OR LASTKEY() = down OR LASTKEY() = right)
_CUROBJ = OBJNUM(okcancel)
RETURN
ENDIF
*** Routine to bypass the recno field and move to the skip button. ***
*** Place cursor on skip radio button if the last object selected ***
*** was the goto push button. Do this only if Shift+Tab, Up Arrow ***
*** or Left Arrow is pressed to exit the goto push button. ***
IF lastobj = OBJNUM(okcancel) AND (LASTKEY() = shifttab ;
OR LASTKEY() = up OR LASTKEY() = left)
_CUROBJ = OBJNUM(radio)+3
RETURN
ENDIF
lastobj = _CUROBJ
FUNCTION recvalid
IF !MDOWN() AND (LASTKEY() = enter OR LASTKEY() = tab ;
OR LASTKEY() = down OR LASTKEY() = right)
_CUROBJ = OBJNUM(radio)+3
RETURN
ENDIF
IF !MDOWN() AND (LASTKEY()= shifttab ;
OR LASTKEY() = up OR LASTKEY() = left)
_CUROBJ = OBJNUM(radio)+2
ENDIF
FUNCTION skipwhen
lastobj = _CUROBJ
FUNCTION okwhen
lastobj = _CUROBJ
*** Routine to process the button choice ***
FUNCTION okvalid
IF okcancel = 1
DO CASE
CASE radio = 1
GO TOP
CASE radio = 2
GO BOTTOM
CASE radio = 3
IF recordnum > RECCOUNT()
WAIT WINDOW 'Record out of range' NOWAIT
ELSE
GO recordnum
ENDIF
CASE radio = 4
IF skipnum+RECNO()  RECCOUNT() OR skipnum + RECNO()  0
WAIT WINDOW 'Record out of range' NOWAIT
ELSE
SKIP skipnum
ENDIF
ENDCASE
ENDIF
</code>					




</example>
</objnum>
<objtoclient>
<summary>
Returns a position or dimension of a control or object relative to its form.
</summary>
<param name="ObjectName">

Specifies the name of the control or object for which the form position is returned.

</param>
<param name="nPosition">

Specifies which form position or dimension of the control or object is returned. The following table lists the values for nPosition and the corresponding position or dimension returned.
1
Top
2
Left
3
Width
4
Height
</param>
<returns>
Numeric
</returns>
<remarks>

<b>OBJTOCLIENT( )</b> returns the position or dimension of a control or object relative to the client area of the form on which it resides. For example, a control or object can be placed on a page in a page frame, and the page frame is placed on a form. The <b>Top</b>, <b>Left</b>, <b>Width</b>, and <b>Height</b> properties return the position or dimension of a control or object relative to the page on which it is placed. However, you can use <b>OBJTOCLIENT( )</b> to determine the position or dimension of a control or object relative to the form on which the page is placed.
The value returned by <b>OBJTOCLIENT( )</b> is in pixels.
</remarks>
<example>
 <code language="X#">CLEAR
STORE _DBLCLICK TO gnDblClick  &amp;&amp; Save double-click value
STORE 0.05 TO _DBLCLICK  &amp;&amp; Make double-click unlikely
frmMyForm = CREATEOBJECT('Form')  &amp;&amp; Create a form
frmMyForm.Closable = .f.  &amp;&amp; Disable the window pop-up menu

frmMyForm.Move(150,10)  &amp;&amp; Move the form
frmMyForm.AddObject('cmbCommand1','cmdMyCmdBtn')  &amp;&amp; Add Command button
frmMyForm.AddObject('pgfPageFrame1','pgfMyPageFrame')  &amp;&amp; Add PageFrame
frmMyForm.pgfPageFrame1.Page1.AddObject('chkCheckBox1','chkMyCheckBox1')
frmMyForm.pgfPageFrame1.Page2.AddObject('chkCheckBox2','chkMyCheckBox2')
frmMyForm.cmbCommand1.Visible =.T.  &amp;&amp; "Quit" Command button visible
frmMyForm.pgfPageFrame1.Visible =.T.  &amp;&amp; PageFrame visible
frmMyForm.pgfPageFrame1.Page1.chkCheckBox1.Visible =.T.
frmMyForm.pgfPageFrame1.Page2.chkCheckBox2.Visible =.T.
frmMyForm.SHOW  &amp;&amp; Display the form
READ EVENTS  &amp;&amp; Start event processing
DEFINE CLASS cmdMyCmdBtn AS CommandButton  &amp;&amp; Create Command button
Caption = '\&lt;Quit'  &amp;&amp; Caption on the Command button
Cancel = .T.  &amp;&amp; Default Cancel Command button (Esc)
Left = 125  &amp;&amp; Command button column
Top = 210  &amp;&amp; Command button row
Height = 25  &amp;&amp; Command button height
PROCEDURE Click
CLEAR EVENTS  &amp;&amp; Stop event processing, close Form
CLEAR  &amp;&amp; Clear main X# window
STORE gnDblClick TO _DBLCLICK  &amp;&amp; Restore double-click value
ENDDEFINE
DEFINE CLASS pgfMyPageFrame AS PageFrame  &amp;&amp; Create PageFrame
Left = 10  &amp;&amp; PageFrame  column
Top = 10  &amp;&amp; PageFrame  row
Height = 175  &amp;&amp; PageFrame  height
Width = 350  &amp;&amp; PageFrame  height
PageCount = 2  &amp;&amp; 2 Pages on the PageFrame
Tabs = .T.  &amp;&amp; Tabs visible
ENDDEFINE
DEFINE CLASS chkMyCheckBox1 AS CheckBox  &amp;&amp; Create first Check Box
Top = 0
Width = 200
Caption = 'Display Position'
PROCEDURE Click
DO CASE
CASE ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Value = 0
ACTIVATE SCREEN
CLEAR
CASE ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Value = 1
ACTIVATE SCREEN
CLEAR
? 'Positions relative'
? 'to PageFrame:'
?
? 'Top: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Top))
? 'Left: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Left))
? 'Width: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Width))
? 'Height: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1.Height))
?
? 'Positions relative'
? 'to Form:'
?
? 'Top: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1,1)))
? 'Left: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1,2)))
? 'Width: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page1.chkCheckBox1,3)))
? 'Height: '
?? ALLTRIM(STR(OBJTOCLIENT(ThisForm.pgfPageFrame1.Page1.chkCheckBox1,4)))
ENDCASE
ENDDEFINE
DEFINE CLASS chkMyCheckBox2 AS CheckBox  &amp;&amp; Create second Check Box
Top = 30
Left = 175
Width = 200
Caption = 'Display Position'
PROCEDURE CLICK
DO CASE
CASE ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Value = 0
ACTIVATE SCREEN
CLEAR
CASE ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Value = 1
ACTIVATE SCREEN
CLEAR
? 'Positions relative'
? 'to PageFrame:'
?
? 'Top: '
?? ALLTRIM(STR(ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Top))
? 'Left: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Left))
? 'Width: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Width))
? 'Height: '
?? ALLTRIM(STR;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2.Height))

?
? 'Positions relative'
? 'to Form:'
?
? 'Top: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2,1)))
? 'Left: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2,2)))
? 'Width: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2,3)))
? 'Height: '
?? ALLTRIM(STR(OBJTOCLIENT;
(ThisForm.pgfPageFrame1.Page2.chkCheckBox2,4)))
ENDCASE
ENDDEFINE</code>
</example>
</objtoclient>
<objvar>
<summary>
Included for backward compatibility. Use the Name Property (X#) for controls instead.
 
Returns the name of the memory variable, array element or field associated with an object.
</summary>
<returns>
Returns - Character
</returns>
<remarks>
<br />
You can use @ ... GET and @ ... EDIT to create controls which are also called objects. Controls that are considered objects are fields, check boxes, lists, popups, invisible, push, and radio buttons, spinners and text editing regions. OBJVAR() returns the name of the memory variable, array element or field in which one of these stores a value. <br />
<br />
Memory variable and array element names returned by OBJVAR() are prefaced with M and a period (M.). Field names returned by OBJVAR() are prefaced by the table alias and a period.<br />
<br />
<br />

</remarks>
</objvar>
<occurs>
<summary>
Returns the number of times a character expression occurs within another character expression.
</summary>
<param name="cSearchExpression">

Specifies a character expression that <b>OCCURS( )</b> searches for within cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression <b>OCCURS( )</b> searches for cSearchExpression.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>OCCURS( )</b> returns 0 (zero) if cSearchExpression isn't found within cExpressionSearched.
</remarks>
<example>
 <code language="X#">STORE 'abracadabra' TO gcstring
CLEAR
? OCCURS('a', gcstring)  &amp;&amp; Displays 5
? OCCURS('b', gcstring)  &amp;&amp; Displays 2
? OCCURS('c', gcstring)  &amp;&amp; Displays 1
? OCCURS('e', gcstring)  &amp;&amp; Displays 0</code>
</example>
</occurs>
<oemtoansi>
<summary>
Included for backward compatibility. Use the CPCONVERT( ) Function instead.
 
Converts each character in a character expression to the corresponding character in the ANSI character set.
</summary>
<returns>
Return value - Character
</returns>
<remarks>
<br />
OEMTOANSI() is supported in FoxPro for Windows and FoxPro for Macintosh.<br />
<br />
Use OEMTOANSI() to move data from FoxPro for MS-DOS to FoxPro for Windows and FoxPro for Macintosh. <br />
<br />

</remarks>
</oemtoansi>
<oldval>
<summary>
Returns original field values for fields that have been modified but not updated.
</summary>
<param name="cExpression">

Specifies an expression whose original value <b>OLDVAL( )</b> returns from a table or a remote data source. cExpression is typically a field or an expression consisting of a set of fields from the table or remote data source.

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor from which the original field values are returned.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor from which the original field values are returned.
</param>
<returns>
Character, Currency, Date, DateTime, Double, Float, Integer, Logical, Numeric, or Memo
</returns>
<remarks>

<b>OLDVAL( )</b> returns original field values for records in a X# table or cursor that has row or table buffering enabled with <b>CURSORSETPROP( )</b>.
If a table in a database or a cursor has validation rules, <b>OLDVAL( )</b> does not require that row or table buffering be enabled in order to return original field values.
If the record pointer is moved to a different record when row buffering is enabled, or if <b>TABLEUPDATE( )</b> is issued to commit changes to the record, or there is some other action that causes an update, such as ending a transaction, the fields are updated and the original field values are no longer available.
The data type of the value <b>OLDVAL( )</b> returns is determined by the expression you specify with cExpression.
<b>OLDVAL( )</b> can return .NULL., even for a field declared as NOT NULL and with SET NULL OFF.
The original field values are returned for the table or cursor open in the currently selected work area if <b>OLDVAL( )</b> is issued without the optional cTableAlias or nWorkArea arguments.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CLEAR
* Create new table and add blank record
CREATE TABLE employee (cLastName C(10))
APPEND BLANK
* Insert initial value
INSERT INTO employee (cLastName) VALUES ("Smith")
* Enable and set table buffering
SET MULTILOCKS ON  &amp;&amp; Allow table buffering
=CURSORSETPROP("Buffering", 5, "employee" )  &amp;&amp; Enable table buffering
* Display initial value
=MESSAGEBOX("Original cLastName value: "+ cLastName, 0, "Results")
* Change record value and display results
REPLACE cLastName WITH "Jones"
=MESSAGEBOX("Modified cLastName value: "+ cLastName, 0, "Results")
* Store the old value of the field to cTemp variable and display results
cTemp=OLDVAL("cLastName", "employee")
=MESSAGEBOX("Original cLastName value: "+ cTemp, 0, "Results")
* Update table and display final value
=TABLEUPDATE(.T.)
=MESSAGEBOX("Final cLastName value: "+ cLastName, 0, "Results")
* Close and delete example table file
USE
DELETE FILE employee.dbf</code>
</example>
</oldval>
<on>
<summary>
Returns the command assigned to each of these event-handling commands: <b>ON ERROR</b>, <b>ON ESCAPE</b>, <b>ON KEY LABEL</b>, or <b>ON PAGE</b>.
</summary>
<param name="cONCommand">

Specifies one of the event-handling commands. Here are the commands and corresponding character expressions to use with <b>ON( )</b>:
cONCommand
ON ERROR
ON ESCAPE
ON KEY LABEL
ON PAGE
For example, to return the command currently assigned to ON ERROR, use the following:   
 <code language="X#">? ON('ERROR')</code>

</param>
<param name="KeyLabelName">

Used in <b>ON KEY LABEL</b> to specify a key or key combination to which the command is assigned. Specify KEY in cONCommand and the key label name of the key or key combination in KeyLabelName. For a complete list of key label names, see ON KEY LABEL.
For example, to return the command currently assigned to the F7 function key with <b>ON KEY LABEL</b>, use the following:   
 <code language="X#">? ON('KEY', 'F7')</code>
</param>
<returns>
Character
</returns>
<remarks>
When an event occurs that is trapped by one of the event-handling commands, the command assigned by the event-handling command executes. <b>ON( )</b> returns the command you assigned to an event-handling command. <b>ON( )</b> returns an empty string if a command isn't currently assigned to the event-handling command you specify.
</remarks>
<example>
 <code language="X#">ON ERROR DO errorhand
ON KEY LABEL CTRL+F2 WAIT WINDOW 'You pressed ^F2'
ON KEY LABEL ALT+Z DISPLAY MEMORY
CLEAR
? ON('ERROR')  &amp;&amp; Displays DO errorhand
? ON('KEY', 'CTRL+F2')  &amp;&amp; Displays WAIT WINDOW 'You pressed ^F2'
? ON('KEY', 'ALT+Z')  &amp;&amp; Displays DISPLAY MEMORY
ON ERROR
ON KEY LABEL CTRL+F2
ON KEY LABEL ALT+Z</code>
</example>
</on>
<order>
<summary>
Returns the name of the controlling index file or tag for the current or specified table.
</summary>
<param name="nWorkArea">

Specifies the work area of a table whose controlling index file name or controlling tag name ORDER( ) returns.

</param>
<param name="cTableAlias">

Specifies a table alias whose controlling index file name or controlling tag name ORDER( ) returns.

</param>
<param name="nPath">

Specifies that the drive and directory are returned along with the single-entry or compound index file name. The numeric expression nPath can have any value.
</param>
<returns>
Character
</returns>
<remarks>
A table can have several index files open simultaneously. However, only one single-entry index file (the controlling index file) or tag from a compound index file (the controlling tag) controls the order in which the table is displayed or accessed. Certain commands, such as SEEK, use the controlling index file or controlling tag to search for records. This function returns the name of the controlling index file or controlling tag.
USE and SET INDEX both support opening more than one index with an index file list. A controlling index file or controlling tag can be designated in this index file list. SET ORDER can also be used to designate a controlling index or controlling tag.
By default, ORDER( ) returns the controlling index file name or controlling tag name for the current work area. ORDER( ) returns the empty string if an order has not been set (SET ORDER TO is issued or there is no controlling index file or tag).
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer ORDER cust_id &amp;&amp; Opens Customer table
? ORDER( )  &amp;&amp; Displays CUST_ID
? ORDER('customer', 1)  &amp;&amp; Displays CUSTOMER.CDX</code>
</example>
</order>
<os>
<summary>
Returns the name and version number of the operating system under which X# is running.
</summary>
<param name="nValue">

Specifies the item to return, according to the following table.
<b>nValues</b>

1
Specifies that the name and version number of the operating system is returned.
2
DBCS Support. If DBCS (double-byte character sets) are supported, "DBCS" is returned. Otherwise, an empty string is returned
3
Identifies the major version number of the operating system. For example, for Windows 2000, the major version number is 5.
4
Identifies the minor version number of the operating system. For example, for Windows 2000, the minor version number is 0.
Identifies the build number of the operating system.
6
Identifies the operating system platform. 
7
Contains a string, such as "Service Pack 3", that indicates the latest Service Pack installed on the system. If no Service Pack has been installed, the string is empty.
8
Identifies the major version number of the latest Service Pack installed on the system. For example, for Service Pack 3, the major version number is 3. If no Service Pack has been installed, the value is zero.
9
Identifies the minor version number of the latest Service Pack installed on the system. For example, for Service Pack 3, the minor version number is 0.
10
A set of bit flags that identify the product suites available on the system. See Product Suite bit flag table below for values.
11
Indicates additional information about the system. See Product Type settings table below for values.
Microsoft Small Business Server is installed. 
Windows 2000 Advanced Server or Windows Server 2003, Enterprise Edition, is installed. 
Microsoft BackOffice components are installed. 
16
Terminal Services are installed.
32
Microsoft Small Business Server is installed with the restrictive client license in force. 
64
Windows Embedded NT is installed
128
Windows 2000 or Windows Server 2003, Datacenter Edition, is installed.
256
Terminal Services is installed, but only one interactive session is supported.
512
Windows XP Home Edition is installed.
1024
Windows Server 2003, Web Edition, is installed. 
The system is running Windows NT 4.0 Workstation, Windows 2000 Professional, Windows XP Home Edition, or Windows XP Professional. 
The system is a domain controller. 
The system is a server.
</param>
<returns>
Character
</returns>
<remarks>
If you omit the optional argument, this function returns the underlying operating system name and its version number.
Some nValues are not applicable to some operating systems. In such cases, the OS( ) function returns "0" or "", an empty string.
</remarks>
<example>
 <code language="X#">? OS( )
? OS(1)
? OS(2)</code>
</example>
</os>
<pad>
<summary>
Returns as an uppercase character string the menu title most recently chosen from a menu bar, or returns a logical value indicating if a menu title is defined for an active menu bar.
</summary>
<param name="cMenuTitle">

Specifies the name of a menu title in a menu bar. Include this argument to test if the menu title is defined for an active menu bar. A logical true (.T.) is returned if the menu title is defined; otherwise a logical false (.F.) is returned.

</param>
<param name="cMenuBarName">

Specifies the name of the menu bar containing the menu title cMenuTitle. If cMenuBarName is omitted, the menu title is assumed to be in the currently active menu bar.
</param>
<returns>
Character or Logical
</returns>
<remarks>
A menu bar must be defined and active for PAD( ) to return a menu title. Menu bars are created and activated with DEFINE MENU and ACTIVATE MENU.
You can also use <b>PAD( )</b> with the X# system menu bar.
PAD( ) (issued without any of its optional arguments) returns an empty string if a menu bar isn't defined and active or you issue <b>PAD( )</b> from the Command window.
</remarks>
<example>
 <code language="X#">*** Name this program PADEXAM.PRG ***
CLEAR
SET SYSMENU SAVE
SET SYSMENU TO
DEFINE PAD padSys OF _MSYSMENU PROMPT '\&lt;System' COLOR SCHEME 3 ;
KEY ALT+S, ''
DEFINE PAD padEdit OF _MSYSMENU PROMPT '\&lt;Edit' COLOR SCHEME 3 ;
KEY ALT+E, ''
DEFINE PAD padRecord OF _MSYSMENU PROMPT '\&lt;Record' COLOR SCHEME 3 ;
KEY ALT+R, ''
DEFINE PAD padWindow OF _MSYSMENU PROMPT '\&lt;Window' COLOR SCHEME 3 ;
KEY ALT+W, ''
DEFINE PAD padReport OF _MSYSMENU PROMPT 'Re\&lt;ports' COLOR SCHEME 3 KEY ALT+P, ''
DEFINE PAD padExit OF _MSYSMENU PROMPT 'E\&lt;xit' COLOR SCHEME 3 ;
KEY ALT+X, ''
ON SELECTION MENU _MSYSMENU ;
DO choice IN padexam WITH PAD( ), MENU( )
PROCEDURE choice
PARAMETERS gcPad, gcMenu
WAIT WINDOW 'You chose ' + gcPad + ;
' from menu ' + gcMenu NOWAIT
IF gcPad = 'PADEXIT'
SET SYSMENU TO DEFAULT
ENDIF</code>
</example>
</pad>
<padprompt>
<summary>
Returns the text of a menu title.
</summary>
<returns>
Character.
</returns>
<remarks>

Specifies the menu title (pad) name or internal system menu title name.

Specifies the name of the menu bar containing the menu title or internal system menu bar name.
When cMenuBarName is omitted the currenctly active menu bar is used as the second parameter.
When no menu bar is active and cMenuBarName is omitted an error is generated.
Menu bars are created with DEFINE MENU, which creates the menu bar, and DEFINE PAD, which creates the menu titles in the menu bar.
PADPROMPT( ) also works with the X# menu system. A menu bar doesn't have to be active for PADPROMPT( ) to return the text for a menu title.
br
If a menu title was created using the backslash and less-than characters (\&lt;) to create an access key, or a backslash (\) to disable the menu title,
PADPROMPT( ) returns only the text of the menu title; it doesn't include the special characters.
</remarks>
<example>

<code language="X#">
? "System menu titles: "
FOR lnI = 1 TO CNTPAD("_msysmenu")
?? PADPROMPT( GETPAD( "_msysmenu", lnI), "_msysmenu") + " "
NEXT
</code>
</example>
</padprompt>
<parameters>
<summary>
Returns the number of parameters passed to the most recently called program, procedure, or user-defined function.
</summary>
<returns>
PARAMETERS( )Return Value
Numeric
</returns>
<remarks>
PARAMETERS( ) is useful for determining how many parameters are passed to a program, procedure, or user-defined function.
The value returned by PARAMETERS() is reset every time a program, procedure, or user-defined function is called or when ON KEY LABEL is executed. Unlike PARAMETERS(), the PCOUNT() function does not get reset, so PCOUNT() may be preferable in most programming situations.
Example 1 calls a procedure and displays in a wait window the number of parameters passed.
Example 2 uses a procedure to display the average of 4 values.
 <code language="X#">* Example 1
DO testpar WITH 1,2,3
PROCEDURE testpar
PARAMETERS gn1,gn2,gn3
gcMessage = 'PARAMETERS( ) ='+ALLTRIM(STR(PARAMETERS( )))
WAIT WINDOW (gcMessage)
RETURN
* Example 2
SET TALK OFF
gnVal1 = 10
gnVal2 = 20
gnVal3 = 30
gnVal4 = 15
gnMin = getavg(gnVal1, gnVal2, gnVal3, gnVal4)
? 'Average value is '
?? gnMin
* This user-defined function permits up to 9 parameters to be passed.
* It uses the PARAMETERS( ) function to determine how many
* were passed and returns the average value.
FUNCTION getavg
PARAMETERS gnPara1,gnPara2,gnPara3,gnPara4,gnPara5, ;
gnPara6,gnPara7,gnPara8,gnPara9
IF PARAMETERS( ) = 0
RETURN 0
ENDIF
gnResult = 0
FOR gnCount = 1 to PARAMETERS( )
gcCompare = 'gnPara' +(STR(gnCount,1))
gnResult = gnResult + EVAL(gcCompare)
ENDFOR
gnResult = gnResult / (gnCount - 1)
RETURN gnResult</code>
</remarks>
</parameters>
<payment>
<summary>
Returns the amount of each periodic payment on a fixed-interest loan.
</summary>
<param name="nPrincipal">

Specifies the beginning principal of the loan. 

</param>
<param name="nInterestRate">

Specifies the fixed interest rate per period. If monthly payments are made on the loan but the interest rate is annual, divide the annual interest rate by 12.

</param>
<param name="nPayments">

Specifies the total number of payments to be made on the loan.
</param>
<returns>
Numeric
</returns>
<remarks>
PAYMENT( ) assumes a constant periodic interest rate and assumes that payments are made at the end of each period.
</remarks>
<example>
 <code language="X#">STORE 100000 to gnPrincipal     &amp;&amp; $100,000 beginning principal
STORE .105/12 TO gnInterest  &amp;&amp; 10.5% annual interest rate
STORE (20*12) TO gnPayments     &amp;&amp; 20 years of monthly payments
CLEAR
? PAYMENT(gnPrincipal, gnInterest, gnPayments)  &amp;&amp; Displays 998.38</code>
</example>
</payment>
<pcol>
<summary>
Returns the current column position of the printer's print head.
</summary>
<returns>
PCOL( )Return Value
Numeric
</returns>
<remarks>
The value <b>PCOL( )</b> returns is relative to the current setting of the left printer margin. You can set the left margin with SET MARGIN or by storing a value to the system memory variable _PLOFFSET.

<b>PCOL( )</b> is especially useful for relative addressing of printed text.
You can use the $ operator in place of <b>PCOL( )</b>.
</remarks>
<example>
 <code language="X#">CLEAR
@ PROW( ), PCOL( )+12 SAY 'Contact person'
@ PROW( ), $+12 SAY 'Contact person'</code>
</example>
</pcol>
<pcount>
<summary>
Returns the number of parameters passed to the current program, procedure, or user-defined function.
</summary>
<returns>
PCOUNT( )Return Value
Numeric
</returns>
<remarks>

<b>PCOUNT( )</b> is useful for determining how many parameters are passed to the current program, procedure, or user-defined function.
Example 1 calls a procedure and displays in a wait window the number of parameters passed.
Example 2 uses a procedure to display the average of 4 values.
 <code language="X#">DO testpar WITH 1,2,3
PROCEDURE testpar
PARAMETERS gn1,gn2,gn3
gcMessage = 'PCOUNT( ) ='+ALLTRIM(STR(PCOUNT( )))
WAIT WINDOW (gcMessage)
RETURN</code>
 <code language="X#">SET TALK OFF
gnVal1 = 10
gnVal2 = 20
gnVal3 = 30
gnVal4 = 15
gnMin = getavg(gnVal1, gnVal2, gnVal3, gnVal4)
? 'Average value is '
?? gnMin
* This user-defined function permits up to 9 parameters to be passed.
* It uses the PCOUNT( ) function to determine how many
* were passed and returns the average value.
FUNCTION getavg
PARAMETERS gnPara1,gnPara2,gnPara3,gnPara4,gnPara5, ;
gnPara6,gnPara7,gnPara8,gnPara9
IF PCOUNT( ) = 0
RETURN 0
ENDIF
gnResult = 0
FOR gnCount = 1 to PARAMETERS( )
gcCompare = 'gnPara' +(STR(gnCount,1))
gnResult = gnResult + EVAL(gcCompare)
ENDFOR
gnResult = gnResult / (gnCount - 1)
RETURN gnResult</code>
</remarks>
</pcount>
<pemstatus>
<summary>
Retrieves an attribute for a property, event, method, or object.
</summary>
<param name="oObjectName">

Specifies the object for which the property, event, method, or object attribute to return. oObjectName can be any expression that evaluates to an object, such as an object reference, an object memory variable, or an object array element. 
If oObjectName is a container object such as a form, you can determine attributes for objects in the container object. 

</param>
<param name="cClassName">

Specifies the class for which the property, event, or method attribute to return.

</param>
<param name="cProperty">

Specifies the property for which the attribute to return.

</param>
<param name="cEvent">

Specifies the event for which the attribute to return.

</param>
<param name="cMethod">

Specifies the method for which the attribute to return.

</param>
<param name="cObject">

Specifies the object for which the attribute to return. 
For example, you can use the <b>AddObject</b> method to add an object to a container object, and then use <b>PEMSTATUS( )</b> to return information about the object added to the container object. 

</param>
<param name="nAttribute">

Specifies a numeric value that determines the property, event, or method attribute to return.
The following table lists the values for nAttribute and the corresponding property, event, or method attribute returned.   
0
Changed. 
If the property value, method, or event has changed, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns logical False (.F.).
1
Read-only (properties only). 
If the property is read-only, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
2
Protected. 
If the property, event, or method is protected, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
3
Type. 
<b>PEMSTATUS( )</b> returns a character string, for example, Property, Event, Method, or Object, indicating whether cProperty, cEvent, cMethod or cObject is a property, event, method or object.
4
User-defined. 
If the property, event, or method is a user-defined property, event, or method, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
5
Defined property, event, method, or object. 
If the property, event, method, or object exists for oObjectName or cClassName, <b>PEMSTATUS( )</b> returns a logical True (.T.). Otherwise, or for hidden native properties, <b>PEMSTATUS( )</b> returns a logical False (.F.).
6
Inherited property, event, method, or object. 
If the property, event, method, or object for oObjectName or cClassName was inherited from another object or class, <b>PEMSTATUS( )</b> returns logical True (.T.). Otherwise, <b>PEMSTATUS( )</b> returns a logical False (.F.).
</param>
<returns>
Character or Logical. <b>PEMSTATUS( )</b> returns a character string or logical value for the attribute specified.
</returns>
<remarks>

<b>PEMSTATUS( )</b> does not detect for changes in specific array elements if the array is passed.
</remarks>
</pemstatus>
<pi>
<summary>
Returns the numeric constant pi.
</summary>
<returns>
PI( )Return Value
Numeric
</returns>
<remarks>
The numeric constant pi (3.141592) is the ratio of the circumference of a circle to its diameter.
The number of decimal places displayed in the value returned by <b>PI( )</b> is determined by SET DECIMALS.
</remarks>
<example>
 <code language="X#">CLEAR
? PI( ) &amp;&amp; Displays 3.14
STORE 2.30 TO gnRadius
STORE PI( ) * gnRadius^2 TO gnArea
? gnArea  &amp;&amp; Displays 16.6190</code>
</example>
</pi>
<popup>
<summary>
Returns as a string the name of the active menu, or a logical value indicating if a menu has been defined.
</summary>
<param name="cMenuName">

Returns a logical value indicating if cMenuName has been defined. POPUP( ) returns true (.T.) if the menu you specify has been defined; otherwise POPUP( ) returns false (.F.).
</param>
<returns>
Character or Logical
</returns>
<remarks>
POPUP( ) returns the name of the active menu as a character string if you omit the optional cMenuName argument. A menu must be defined and active for POPUP( ) to return its name. Menus are created and activated with DEFINE POPUP and ACTIVATE POPUP. The menu can also be a X# system menu. POPUP( ) returns an empty string if a menu isn't defined and active or you issue POPUP( ) from the Command window.
</remarks>
</popup>
<primary>
<summary>
Returns true (.T.) if an index tag is a primary index tag; otherwise, returns false (.F.).
</summary>
<param name="nIndexNumber">

Specifies the number of the index tag for which PRIMARY( ) returns the primary status. PRIMARY( ) returns the primary status in the following order as nIndexNumber increases from 1 to the total number of structural compound and independent compound index tags.
Primary status for each tag in the structural compound index (if one is present) are returned first. The primary status is returned for the tags in the order the tags are created in the structural index.
Primary status for each tag in any open, independent compound indexes are returned next. The primary status is returned for the tags in the order in which the tags are created in the independent compound indexes. 
If you omit nIndexNumber, PRIMARY( ) checks the master controlling index tag to see if it's a primary index tag. If there is no master controlling index tag, PRIMARY( ) returns false (.F.). 

</param>
<param name="nWorkArea">

Specifies the work area of the index tag specified with nIndexNumber.

</param>
<param name="cTableAlias">

Specifies the work area of the index tag specified with nIndexNumber.
If you omit nWorkArea and cTableAlias, PRIMARY( ) checks the index tag in the currently selected work area to see if it's a primary index tag.
</param>
<returns>
Logical
</returns>
<example>
 <code language="X#">CLOSE DATABASES
SET PATH TO (HOME(2) + 'Data\')   &amp;&amp; Sets path to database
OPEN DATABASE testdata  &amp;&amp; Open testdata database
USE Customer     &amp;&amp; Open customer table
FOR nCount = 1 TO TAGCOUNT( )
IF !EMPTY(TAG(nCount))  &amp;&amp; Checks for tags in the index
? TAG(nCount)  &amp;&amp; Display tag name
? PRIMARY(nCount)     &amp;&amp; Display primary status
ELSE
EXIT  &amp;&amp; Exit the loop when no more tags are found
ENDIF
ENDFOR</code>
</example>
</primary>
<printstatus>
<summary>
Returns the status of the printer. Included for backward compatibility.
</summary>
<returns>
PRINTSTATUS( )Return Value
Logical value. For versions of X# running on Windows, PRINTSTATUS( ) always returns True (.T.) if the printer is connected through the Windows Control Panel.
In prior versions, if the printer or print device is online, PRINTSTATUS( ) returns True (.T.); otherwise, it returns False (.F.).
</returns>
<remarks>
PRINTSTATUS( ) functions similarly to SYS(13). For more information, see SYS(13) - Printer Status.
</remarks>
<example>
 <code language="X#">? PRINTSTATUS( )
*** Program Example ***
STORE PRINTSTATUS( ) TO glReady
IF NOT glReady
WAIT 'Make sure printer is attached and turned on!' WINDOW
ELSE
WAIT 'Printer is ready!' WINDOW
ENDIF</code>
</example>
</printstatus>
<prmbar>
<summary>
Returns the text of a menu item.
</summary>
<param name="cMenuName">

Specifies the menu name.

</param>
<param name="nMenuItemNumber">

Specifies the number of the menu item whose text PRMBAR( ) returns. For example, if nMenuItemNumber is 1, the text of the first menu item is returned; if nMenuItemNumber is 2, the text of the second menu item is returned, and so on. The expression must be at least 1 and no greater than the number of menu items in the menu.
</param>
<returns>
Character
</returns>
<remarks>
Menus are created with DEFINE POPUP, which creates the menu, and DEFINE BAR, which creates the menu items in the menu. PRMBAR( ) also works with a X# system menu. PRMBAR( ) returns the text that appears on the menu item. The menu doesn't have to be active.
If a menu item was created using the backslash and less-than characters (\&lt;) to create an access key, or a backslash (\) to disable the menu item, PRMBAR( ) returns only the menu item text; it doesn't include these special characters. PRMBAR( ) returns an empty string when a menu item is a separator created with the backslash and dash (\-) characters.
</remarks>
</prmbar>
<prmpad>
<summary>
Returns the text of a menu title.
</summary>
<param name="MenuBarName">

Specifies the name of the menu bar containing the menu title.

</param>
<param name="MenuTitleName">

Specifies the menu title.
</param>
<returns>
Character
</returns>
<remarks>
Menu bars are created with DEFINE MENU, which creates the menu bar, and DEFINE PAD, which creates the menu titles in the menu bar. PRMPAD( ) also works with the X# menu system. A menu bar doesn't have to be active for PRMPAD( ) to return the text for a menu title.
If a menu title was created using the backslash and less-than characters (\&lt;) to create an access key, or a backslash (\) to disable the menu title, PRMPAD( ) returns only the text of the menu title; it doesn't include the special characters.
</remarks>
<example>
 <code language="X#">CLEAR
SET TALK OFF
STORE 'mnuExample' TO gcPopName
DEFINE MENU mnuExample BAR AT LINE 1
DEFINE PAD titleOne OF mnuExample PROMPT 'This will be returned'
DEFINE PAD titleTwo OF mnuExample PROMPT '\&lt;As will this'
DEFINE PAD titleThree OF mnuExample PROMPT '\And this, too'
=messagebox( PRMPAD('mnuExample', 'titleOne') )
=messagebox( PRMPAD('mnuExample', 'titleTwo') )
=messagebox( PRMPAD(gcPopName, 'titleThree') )
ACTIVATE MENU mnuExample
DEACTIVATE MENU mnuExample
RELEASE MENU mnuExample</code>
</example>
</prmpad>
<program>
<summary>
Returns the name of the program at a specified program level, the name of the currently executing program, the current program level, or the name of the program executing when an error occurred.
</summary>
<param name="nLevel">

Specifies the number of program levels to search for the program name. The nLevel parameter can range from 0 to the program nesting depth. For more information about program nesting levels, see maximum number of DO calls in X# System Capacities. 
When nLevel is omitted, <b>PROGRAM( )</b> returns the name of the currently executing program. If you specify 0 or 1 for nLevel, <b>PROGRAM( )</b> returns the name of the master program, or the highest-level program.    
If you specify –1 for nLevel, <b>PROGRAM( )</b> returns the current program level as a numeric value. However, using codePROGRAM(–1)/code in the Command window always returns zero (0).   
If nLevel exceeds the program nesting depth, <b>PROGRAM( )</b> returns an empty string ("").
</param>
<returns>
Character or Numeric. <b>PROGRAM( )</b> returns a program name, the number of the current program level, or an empty string.
</returns>
<remarks>
You can use <b>PROGRAM( )</b> to help your program recover from errors. The <b>PROGRAM( )</b> function is similar to SYS(16) - Executing Program File Name.
</remarks>
<example>
 <code language="X#">ON ERROR DO errhand WITH PROGRAM( )
*** The next line should generate an error ***
USE nodatabase
ON ERROR     &amp;&amp; Returns to system default error-handling routine
PROCEDURE errhand
PARAMETERS gcProgram
WAIT 'An error occurred in the program ' + gcProgram WINDOW</code>
</example>
</program>
<prompt>
<summary>
Returns the text for a menu title chosen from a menu bar or for a menu item chosen from a menu.
</summary>
<returns>
PROMPT( )Return Value
Character
</returns>
<remarks>

<b>PROMPT( )</b> returns the text of the menu title last chosen from a menu bar or the menu item last chosen from a menu. The menu bar or menu can be user-defined or a X# system menu bar or menu. If a menu bar or menu isn't active or you press ESC to exit a menu bar or menu, <b>PROMPT( )</b> returns an empty string.
A menu bar is created with <b>DEFINE MENU</b>, and each menu title in the menu bar is created with <b>DEFINE PAD</b>. A menu is created with <b>DEFINE POPUP</b>, and the menu items in the menu are created with <b>DEFINE BAR</b>.

<b>MENU( )</b> and <b>POPUP( )</b> can be used to return the name of the menu bar or menu from which the menu title or menu item is chosen.
</remarks>
</prompt>
<proper>
<summary>
Returns from a character expression a string capitalized as appropriate for proper names.
</summary>
<param name="cExpression">

Specifies the character expression from which <b>PROPER( )</b> returns a capitalized character string.
</param>
<returns>
Character
</returns>
<example>
 <code language="X#">STORE 'X#' TO gcExpr1
CLEAR
? PROPER(gcExpr1)  &amp;&amp; Displays "X#"
STORE 'X#' TO gcExpr2
? PROPER(gcExpr2)  &amp;&amp; Displays "X#"</code>
</example>
</proper>
<prow>
<summary>
Returns the current row number of the printer's print head.
</summary>
<returns>
PROW( )Return Value
Numeric
</returns>
<remarks>
If you issue <b>EJECT</b>, X# resets <b>PROW( )</b> to 0.

<b>PROW( )</b> is especially useful for relative addressing of printed text.
</remarks>
<example>
 <code language="X#">@ PROW( ), PCOL( ) + 12 SAY 'Contact person'
@ PROW( ), $+12 SAY 'Contact person'</code>
</example>
</prow>
<prtinfo>
<summary>
Returns the current specified printer setting.
</summary>
<param name="nPrinterSetting">

Specifies which X# printer setting to return. The following table lists descriptions of the type of printer settings returned.
nPrinterSetting
1
PRT_ORIENTATION
Paper orientation
2
PRT_PAPERSIZE
Paper size
3
PRT_PAPERLENGTH
Paper length in .1 millimeter increments
4
PRT_PAPERWIDTH
Paper width in .1 millimeter increments
5
PRT_SCALE
Factor by which printer output is scaled
6
PRT_COPIES
Number of copies to print
7
PRT_DEFASOURCE
Default paper source
8
PRT_PRINTQUAL
A positive value that indicates the horizontal resolution in dots per inch (DPI) or a negative value that indicates the print quality.
9
PRT_COLOR
A value that indicates if a color printer rends color or monochrome output
10
PRT_DUPLEX
Duplex mode
11
PRT_YRESOLUTION
The vertical resolution in dots per inch (DPI). If not available, a value of -1 is returned.
12
PRT_TTOPTION
A value that indicates how TrueType® fonts are printed
13
PRT_COLLATE
A value that indicates if output is collated

</param>
<param name="cPrinterName">

Specifies the name of the printer for which information is returned. If cPrinterName is omitted, information is returned for the default printer.
</param>
<returns>
Numeric data type. The following tables list values returned when specifying particular values for nPrinterSetting.
If nPrinterSetting is 1, <b>PRTINFO( )</b> returns the paper orientation as the following:
–1
Information not available
0
Portrait
1
Landscape
If nPrinterSetting is 2, <b>PRTINFO( )</b> returns the paper size as the following:
–1 or value other than listed
Information not available. Use nPrinterSetting = 3 and nPrinterSetting = 4 to return the paper size.
1
Letter, 8 1/2 x 11 in
2
Letter Small, 8 1/2 x 11 in
3
Tabloid, 11 x 17 in
4
Ledger, 17 x 11 in
5
Legal, 8 1/2 x 14 in
6
Statement, 5 1/2 x 8 1/2 in
7
Executive, 7 1/4 x 10 1/2 in
8
A3, 297 x 420 mm
9
A4, 210 x 297 mm
10
A4, Small 210 x 297 mm
11
A5, 148 x 210 mm
12
B4, 250 x 354 mm
13
B5, 182 x 257 mm
14
Folio, 8 1/2 x 13 in
15
Quarto, 215 x 275 mm
16
10 x 14 in
17
11 x 17 in
18
Note, 8 1/2 x 11 in
19
Envelope #9, 3 7/8 x 8 7/8 in
20
Envelope #10, 4 1/8 x 9 1/2 in
21
Envelope #11, 4 1/2 x 10 3/8 in
22
Envelope #12, 4 1/2 x 11 in
23
Envelope #14, 5 x 11 1/2 in
24
C size sheet
25
D size sheet
26
E size sheet
27
Envelope DL, 110 x 220 mm
28
Envelope C5, 162 x 229 mm
29
Envelope C3, 324 x 458 mm
30
Envelope C4, 229 x 324 mm
31
Envelope C6, 114 x 162 mm
32
Envelope C65, 114 x 229 mm
33
Envelope B4, 250 x 353 mm
34
Envelope B5, 176 x 250 mm
35
Envelope B6, 176 x 125 mm
36
Envelope, 110 x 230 mm
37
Envelope Monarch, 3 7/8 x 7.5 in
38
6 3/4 Envelope, 3 5/8 x 6 1/2 in
39
US Std Fanfold, 14 7/8 x 11 in
40
German Std Fanfold, 8 1/2 x 12 in
41
German Legal Fanfold, 8 1/2 x 13 in 
If nPrinterSetting is 7, <b>PRTINFO( )</b> returns the default paper source as the following:
1
Upper bin
2
Lower bin
3
Middle bin
4
Manual feed
5
Envelope bin
6
Manual feed envelope
7
Automatic feed 
8
Tractor feed
9
Small format
10
Large format
11
Large capacity
14
Cassette
15
Default input bin (automatically select)
If nPrinterSetting is 8 and <b>PRTINFO( )</b> returns a negative value, the return value indicates the print quality as the following:
–1
Draft
–2
Low
–3
Medium
–4
High
If nPrinterSetting is 9, <b>PRTINFO( )</b> returns a value indicating if a color printer renders color or monochrome output as the following:
1
Monochrome 
2
Color
If nPrinterSetting is 10, <b>PRTINFO( )</b> returns the duplex mode as the following:
1
Simplex printing
2
Vertical duplex
3
Horizontal duplex
If nPrinterSetting is 12, <b>PRTINFO( )</b> returns a value that indicates how TrueType® fonts are printed as the following:
1
Print as bitmapped graphics
2
Download as soft fonts
3
Substitute device fonts
If nPrinterSetting is 13, <b>PRTINFO( )</b> returns a value that indicates if output is collated as the following:
0
No collation
1
Collated
</returns>
<remarks>
You can set X# printer settings in the printer Page Setup dialog box. For more information, see Page Setup Dialog Box.
</remarks>
</prtinfo>
<putfile>
<summary>
Invokes the Save As dialog box and returns the file name you specify.
</summary>
<param name="cCustomText">

Specifies custom text to appear in the Save As dialog box.

</param>
<param name="cFileName">

Specifies the default file name displayed in the text box.

</param>
<param name="cFileExtensions">

Specifies file name extensions. Only file names with the specified extension are displayed in the scrollable list of the Save As dialog box when the All Files check box is cleared. The first extension in cFileExtensions is automatically appended to the file name entered if an extension isn't included with the file name. The cFileExtensions parameter cannot exceed 254 characters in length. For a list of X# file extensions and corresponding creator types, see the File Extensions and File Types online topic.
The character expression cFileExtensions can take one of the following forms:   
cFileExtensions can contain a single extension, such as PRG, and only file names with that extension are displayed.
cFileExtensions can contain a list of file name extensions separated by semicolons. For example, if you include PRG;FXP, X# displays all file names with the extensions .prg and .fxp.
If file names have the same root name but different extensions (for example, Customer.prg and Customer.fxp), X# displays only the file name with the extension that appears first in cFileExtensions.
cFileExtensions can contain a list of file name extensions separated by vertical bars, such as PRG|FXP. In such a case, X# displays all file names with listed extensions, even if the files have the same root name.
If cFileExtensions contains only a semicolon (;), X# displays all file names that don't have an extension.
If cFileExtensions is an empty string, X# displays the names of all files in the current directory or folder.
If cFileExtensions contains MS-DOS wildcards, such as the question mark (?) and asterisk (*), X# displays all file names with extensions that meet the wildcard criteria. For example, if cFileExtensions is ?X?, all file names with the extensions .fxp, .exe, .txt, and so on, are displayed.
</param>
<returns>
Character
</returns>
<remarks>
Use <b>PUTFILE( ) </b>to choose an existing file name or specify a new file name. <b>PUTFILE( )</b> returns the file name with its path. If you don't enter a file name, <b>PUTFILE( )</b> returns the default file name (specified with cFileName) and extension (specified by cFileExtensions). If you choose Cancel or press ESC, <b>PUTFILE( )</b> returns an empty string. You can use the file name that <b>PUTFILE( )</b> returns to name a file and save it to disk.
</remarks>
<example>
 <code language="X#">gcTableName = GETFILE('DBF', 'Open Table:')
USE (gcTableName)
gcDelimName = ALIAS( ) + '.DLM'
gcDelimFile = PUTFILE('Delimited file:', gcDelimName, 'DLM')
IF EMPTY(gcDelimFile)  &amp;&amp; Esc pressed
CANCEL
ENDIF
COPY TO (gcDelimFile) DELIMITED   &amp;&amp; Create delimited file
MODIFY FILE (gcDelimFile) NOEDIT</code>
</example>
</putfile>
<pv>
<summary>
Returns the present value of an investment.
</summary>
<param name="nPayment">

Specifies the periodic payment amount. nPayment can evaluate to a positive or negative number. <b>PV( )</b> assumes that the payments are made at the end of each period.

</param>
<param name="nInterestRate">

Specifies the periodic interest rate. If the interest rate of an investment is annual and the payments are made monthly, divide the annual interest rate by 12.

</param>
<param name="nTotalPayments">

Specifies the total number of payments.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>PV( )</b> computes the present value of an investment based on a series of equal periodic payments at a constant periodic interest rate.
</remarks>
<example>
 <code language="X#">STORE 500 to gnPayment  &amp;&amp; Periodic payments made monthly
STORE .075/12 TO gnInterest     &amp;&amp; 7.5% annual interest rate
STORE 48 TO gnPeriods  &amp;&amp; Four years (48 months)
CLEAR
? PV(gnPayment, gnInterest, gnPeriods)  &amp;&amp; Displays 20679.19</code>
</example>
</pv>
<quarter>
<summary>
Returns the quarter of the year in which a date or datetime expression occurs.
</summary>
<param name="dExpression">

Specifies the <b>Date</b> expression for which you want <b>QUARTER( )</b> to return a value.

</param>
<param name="tExpression">

Specifies the <b>DateTime</b> expression for which you want <b>QUARTER( )</b> to return a value.

</param>
<param name="nMonth">

Specifies an optional starting month to the examined quarter. You can use this to specify quarters based on a fiscal rather than a calendar year.
</param>
<returns>
Numeric data type. <b>QUARTER( )</b> returns the quarter of the year in which a date occurs, and the values can be 0, 1, 2, 3, or 4.
<b>QUARTER( )</b> returns 0 if passed an empty <b>Date</b> or <b>DateTime</b> value, for example, codeQUARTER({//})/code.
</returns>
</quarter>
<raiseevent>
<summary>
You can use <b>RAISEEVENT( )</b> to raise, or trigger, an event from a custom method. Though <b>RAISEEVENT( )</b> applies primarily to custom methods, you can use it for raising native events and methods.
</summary>
<param name="oEventSource">

Specifies the event source, which must be a valid X# object.

</param>
<param name="cEvent">

Specifies the name of the event, method, or property you want to raise.

</param>
<param name="eParm1...">

Specifies one or more parameters to pass if the method has parameters.
</param>
<returns>
Logical data type. <b>RAISEEVENT( )</b> always returns True (.T.).
</returns>
<remarks>
X# automatically raises events for custom methods that are bound to objects using <b>BINDEVENT( )</b> if the methods are called directly. For example, the following code does not raise an event:
 <code language="X#">oForm.GetMyData(cData)</code>
Instead, to raise an event for a custom method, you need to make the following call:
 <code language="X#">RAISEEVENT( oForm, "GetMyData", cData )</code>
You can also change this behavior by using <b>BINDEVENT( )</b> with nFlags set to 2 or 3.
The event you wish to raise must be marked <b>Public</b>, not <b>Hidden</b> or <b>Protected</b>.
If you use <b>RAISEEVENT( )</b> on a property, X# sets the property to itself. The following example sets the <b>Caption</b> property for <b>_SCREEN</b> to the current value for <b>Caption</b>:
 <code language="X#">RAISEEVENT( _SCREEN, "Caption" )</code>
Raising an event fails if you bind to an event, for example, using <b>BINDEVENT( )</b>, that has parameters that are passed by reference.
X# disregards recursive <b>RAISEEVENT( )</b><b> </b>calls to an event from within the same raised event.
</remarks>
<example>
 <code language="X#">RAISEEVENT( Form1, "Activate" )</code>
</example>
</raiseevent>
<rand>
<summary>
Returns a random number between 0 and 1.
</summary>
<param name="nSeedValue">

Specifies the seed value that determines the sequence of values RAND( ) returns.
RAND( ) returns the same sequence of random numbers if you use the same seed value for nSeedValue the first time you issue RAND( ) followed by subsequent RAND( ) function calls without nSeedValue.   
If nSeedValue is negative the first time you issued RAND( ), a seed value from the system clock is used. To achieve the most random sequence of numbers, issue RAND( ) initially with a negative argument and then issue RAND( ) without an argument.   
If you omit nSeedValue, RAND( ) uses a default seed value of 100,001.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">CLOSE DATABASES
CREATE TABLE Random (cValue N(3))
FOR nItem = 1 TO 10  &amp;&amp; Append 10 records,
APPEND BLANK
REPLACE cValue WITH 1 + 100 * RAND( )  &amp;&amp; Insert random values
ENDFOR
CLEAR
LIST  &amp;&amp; Display the values
gnMaximum = 1  &amp;&amp; Initialize minimum value
gnMinimum = 100  &amp;&amp; Initialize maximum value
SCAN
gnMinimum = MIN(gnMinimum, cValue)
gnMaximum = MAX(gnMaximum, cValue)
ENDSCAN
? 'The minimum value is: ', gnMinimum  &amp;&amp; Display minimum value
? 'The maximum value is: ', gnMaximum  &amp;&amp; Display maximum value
CLEAR
gnLower = 1
gnUpper = 10
? INT((gnUpper - gnLower + 1) * RAND( ) + gnLower)</code>
</example>
</rand>
<rat>
<summary>
Returns the numeric position of the last (rightmost) occurrence of a character string within another character string.
</summary>
<param name="cSearchExpression">

Specifies the character expression that RAT( ) looks for in cExpressionSearched. The character expression can refer to a memo field of any size.

</param>
<param name="cExpressionSearched">

Specifies the character expression that RAT( ) searches. The character expression can refer to a memo field of any size.

</param>
<param name="nOccurrence">

Specifies which occurrence, starting from the right and moving left, of cSearchExpression RAT( ) searches for in cExpressionSearched. By default, RAT( ) searches for the last occurrence of cSearchExpression (nOccurrence = 1). If nOccurrence is 2, RAT( ) searches for the next to last occurrence, and so on.
</param>
<returns>
Numeric
</returns>
<remarks>
RAT( ), the reverse of the AT( ) function, searches the character expression in cExpressionSearched starting from the right and moving left, looking for the last occurrence of the string specified in cSearchExpression.
RAT( ) returns an integer indicating the position of the first character in cSearchExpression in cExpressionSearched. RAT( ) returns 0 if cSearchExpression isn't found in cExpressionSearched, or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched.
The search performed by RAT( ) is case-sensitive.
</remarks>
<example>
 <code language="X#">STORE 'abracadabra' TO string
STORE 'a' TO find_str
CLEAR
? RAT(find_str,string)  &amp;&amp; Displays 11
? RAT(find_str,string,3)  &amp;&amp; Displays 6</code>
</example>
</rat>
<ratc>
<summary>
Returns the numeric position of the last occurrence of a character expression or memo field within another character expression or memo field.
</summary>
<param name="cSearchExpression">

Specifies the character expression that RATC( ) looks for in cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression that RATC( ) searches. The character expressions cSearchExpression and cExpressionSearched can be memo fields of any size.

</param>
<param name="nOccurrence">

Specifies which occurrence, starting from the right and moving left, of cSearchExpression RATC( ) searches for in cExpressionSearched. By default, RATC( ) searches for the last occurrence of cSearchExpression (nOccurrence equals 1). If nOccurrence is 2, RATC( ) searches for the next to last occurrence, and so on.
</param>
<returns>
Numeric
</returns>
<remarks>
RATC( ) is designed for expressions containing double-byte characters. If the expression contains only single-byte characters, RATC( ) is equivalent to RAT( ).
RATC( ) returns the numeric position of the last occurrence of a character expression or memo field within another character expression or memo field. The character expressions or memo fields can contain any combination of single-byte and double-byte characters.
RATC( ) is the reverse of the AT_C( ) function: it searches from right to left.
RATC( ) returns an integer indicating the position of the first character in cSearchExpression in cExpressionSearched. RATC( ) returns 0 if cSearchExpression isn't found in cExpressionSearched, or if nOccurrence is greater than the number of times cSearchExpression occurs in cExpressionSearched.
The search performed by RATC( ) is case-sensitive.
This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
</remarks>
</ratc>
<ratline>
<summary>
Returns the line number of the last occurrence of a character expression within another character expression or memo field, counting from the last line.
</summary>
<param name="cSearchExpression">

Specifies the character expression that RATLINE( ) looks for in cExpressionSearched.

</param>
<param name="cExpressionSearched">

Specifies the character expression that RATLINE( ) searches. The character expressions cSearchExpression and cExpressionSearched can be memo fields of any size.
Use MLINE( ) to return the line containing cSearchExpression.   
RATLINE() offers a convenient way to search memo fields.
</param>
<returns>
Numeric
</returns>
<remarks>
RATLINE( ), the reverse of the ATLINE( ) function, searches a character expression cExpressionSearched, starting with the last character in cExpressionSearched, for the occurrence of cSearchExpression.
If the search is successful, RATLINE( ) returns the number of the line where the match occurs. If the search is unsuccessful, RATLINE( ) returns 0.
The search performed by RATLINE( ) is case-sensitive.
The line number that RATLINE() returns is determined by the value of SET MEMOWIDTH, even if cExpressionSearched isn't a memo field. For more information, see SET MEMOWIDTH.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE employee  &amp;&amp; Opens Employee table
STORE 'graduated' TO gcString
STORE MLINE(notes, RATLINE(gcString, notes)) TO gnFileLine
? gnFileLine</code>
</example>
</ratline>
<rdlevel>
<summary>
Included for backward compatibility. Use the Form Designer instead of READ.
 
Returns the current READ level.
</summary>
<returns>
Return value - Numeric
</returns>
<remarks>
<br />
Nested READs are created by issuing @ ... GETS and a READ in a routine that's executed during an active READ. READs can be nested to five levels. <br />
<br />
Use RDLEVEL() to return the level of the current READ command. RDLEVEL() returns a value of 0, 1, 2, 3, 4 or 5, depending on how deep the current READ is nested. RDLEVEL() returns 0 if no READ is executing.<br />
<br />

</remarks>
<example>
In the following example, pressing CTRL+Z at any time displays the current READ level using RDLEVEL(). You can advance to the next READ level by pressing Enter or you can move back a READ level by pressing Esc. Note the use of the VALID clause with @ ... GET and a UDF to create nested READs.<br />
<br />




 






<code language="X#">ON KEY LABEL CTRL+Z DO saylevel
CLEAR
DO saylevel
@ 4,2 GET level1 VALID(proc1()) DEFAULT 1
READ				&amp;&amp; READ Level 1
ON KEY LABEL CTRL+Z
RETURN
PROCEDURE proc1
@ 6,2 GET level2 VALID(proc2()) DEFAULT 2
READ				&amp;&amp; READ Level 2
RETURN ''
PROCEDURE proc2
@ 8,2 GET level3 VALID(proc3()) DEFAULT 3
READ				&amp;&amp; READ Level 3
RETURN ''
PROCEDURE proc3
@ 10,2 GET level4 DEFAULT 4
READ				&amp;&amp; READ Level 4
RETURN ''
PROCEDURE saylevel
@ 2,2 SAY 'Read level: ' + STR(RDLEVEL())
RETURN ''
</code>					




</example>
</rdlevel>
<readkey>
<summary>
Included for backward compatibility with READ. Use the Form Designer instead of READ.
 
Returns a value corresponding to the key pressed to exit certain editing commands, or a value indicating how the last READ was terminated.
</summary>
<returns>
Return value - Numeric
</returns>
<remarks>
<br />
If READKEY() is issued without the optional numeric expression expN, the value returned represents the key pressed to exit from these editing commands: APPEND, BROWSE, CHANGE, CREATE, EDIT, INSERT, MODIFY and READ.<br />
<br />
An integer between 0 and 36, or between 256 and 292, is returned. The value returned is between 0 and 36 if the data was not modified. The value returned is between 256 and 292 if the data was modified.<br />
<br />
Values Returned by READKEY<br />
<br />
Key(s)&amp;nbsp;No Update&amp;nbsp;Update&amp;nbsp;Meaning<br />
&amp;nbsp;&amp;nbsp;Code&amp;nbsp;&amp;nbsp;Code<br />
------&amp;nbsp;---------&amp;nbsp;------&amp;nbsp;-------<br />
<br />
Backspace<br />
Left Arrow   0      256     Back 1<br />
Ctrl+H &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;char.<br />
Ctrl+S&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<br />

</remarks>
</readkey>
<reccount>
<summary>
Returns the number of records in the current or specified table.
</summary>
<param name="nWorkArea">

Specifies the work area number for a table open in another work area.
RECCOUNT( ) returns 0 if a table isn't open in the work area you specify. 

</param>
<param name="cTableAlias">

Specifies the table alias for a table open in another work area.
</param>
<returns>
Numeric
</returns>
<remarks>
The value RECCOUNT( ) returns isn't affected by SET DELETED and SET FILTER.
RECCOUNT( ) without the optional arguments nWorkArea or cTableAlias returns the number of records in the table in the currently selected work area.
</remarks>
<example>
 <code language="X#">*** Check DISKSPACE before a SORT ***
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
*** Get size of table header ***
gnTableHead = HEADER( )
*** Calculate size of table ***
gnFileSize = gnTableHead + (RECSIZE( ) * RECCOUNT( ) + 1)
IF DISKSPACE( ) &gt; (gnFileSize * 3)
WAIT WINDOW 'Sufficient diskspace to sort.'
ELSE
WAIT WINDOW 'Insufficient diskspace. Sort cannot be done.'
ENDIF</code>
</example>
</reccount>
<recno>
<summary>
Returns the current record number in the current or specified table.
</summary>
<param name="nWorkArea">

Specifies the work area number for a table open in another work area. RECNO( ) returns 0 if a table isn't open in the work area you specify.

</param>
<param name="cTableAlias">

Specifies the table alias for a table open in another work area.
</param>
<returns>
Numeric
</returns>
<remarks>
The current record is the record on which the record pointer is positioned.
RECNO( ) returns negative numbers for records appended in a table buffer.
RECNO( ) returns a value that is one greater than the number of records in the table if the record pointer is positioned beyond the last record in the table. RECNO( ) returns 1 if the record pointer is positioned before the first record in the table or the table has no records. If a table has no records, EOF( ) always returns true (.T.).
RECNO( ) issued without the optional arguments nWorkArea or cTableAlias returns the current record number for the table in the currently selected work area.
If you have issued SEEK unsuccessfully in an indexed table, you can specify 0 for nWorkArea to use "soft seek" logic to return the record number of the closest matching record. RECNO(0) returns 0 if a close match cannot be found. X# generates an error message if you issue GO RECNO(0) when a close match isn't found.
Avoid using RECNO( ) in the index expression for a table buffered cursor. Because RECNO( ) changes for new records when they are committed by TABLEUPDATE( ), index corruption could occur.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'data\testdata')
USE customer  &amp;&amp; Opens Customer table
SET ORDER TO company
SEEK 'Ernst'
IF FOUND( )
DISPLAY company, contact
ELSE
GOTO RECNO(0)
CLEAR
? 'Closest matching company is ' + company
? 'Record number: ' + ALLTRIM(STR(RECNO( )))
ENDIF</code>
</example>
</recno>
<recsize>
<summary>
Returns the size (width) of a table record.
</summary>
<param name="nWorkArea">

Specifies the work area number for a table open in another work area. <b>RECSIZE( )</b> returns 0 if a table isn't open in the work area you specify.

</param>
<param name="cTableAlias">

Specifies the table alias for a table open in another work area.
</param>
<returns>
Numeric
</returns>
<remarks>

<b>RECSIZE( )</b> issued without the optional arguments nWorkArea or cTableAlias returns the record size for the table in the currently selected work area.
</remarks>
<example>
 <code language="X#">*** Check DISKSPACE before a SORT ***
CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
*** Get size of table header ***
gnTableHead = HEADER( )
*** Calculate size of table ***
gnFileSize = gnTableHead + (RECSIZE( ) * RECCOUNT( ) + 1)
IF DISKSPACE( ) &gt; (gnFileSize * 3)
WAIT WINDOW 'Sufficient diskspace to sort.'
ELSE
WAIT WINDOW 'Insufficient diskspace. Sort cannot be done.'
ENDIF</code>
</example>
</recsize>
<refresh>
<summary>
Refreshes data in an updatable SQL remote or local view, or <b>CursorAdapter</b> cursor.
</summary>
<param name="nRecords">

Specifies the number of records to refresh. If nRecords is 1 or you omit nRecords, only the current record is refreshed. If nRecords is 0, no records are refreshed.

</param>
<param name="nRecordOffset">

Specifies the number of records before the current record where the refresh begins. For example, if the current record is record 10 and nRecordOffset is 4, record refresh begins with record 6. If nRecordOffset is 0 or you omit nRecordOffset, the refresh begins with the current record.

</param>
<param name="cTableAlias">

Specifies the alias of the cursor associated with a SQL remote or local view, or a <b>CursorAdapter</b> cursor where records are refreshed.

</param>
<param name="nWorkArea">

Specifies the work area of cursor where records are refreshed. If you omit nWorkArea and cTableAlias, records are refreshed in the currently selected work area.
</param>
<returns>
Numeric. <b>REFRESH( )</b> returns the number of records refreshed.
</returns>
<remarks>
The records are refreshed with data from the tables that define the SQL view or <b>CursorAdapter</b>. Unless specified, records are refreshed in the SQL view or <b>CursorAdapter</b> cursor open in the currently selected work area.
<b>REFRESH( )</b> does not refresh content for buffered records; however, field values that are accessible for the record through the <b>CURVAL( )</b> function are refreshed. For more information, see CURVAL( ) Function.
Records must have unique primary keys. If a key for a record cannot be located in the base table, the corresponding record in the SQL view or <b>CursorAdapter</b> is marked for deletion.
Calling the <b>REFRESH( )</b> function can result in a significant impact on performance because the function re-executes the query on which the view is based. Therefore, do not call this function more than necessary.
</remarks>
</refresh>
<relation>
<summary>
Returns a specified relational expression for a table that is open in a specific work area.
</summary>
<param name="nRelationNumber">

Specifies which relation is returned. For example, if nRelationNumber is 3, <b>RELATION( )</b> returns the relational expression for the third relation created.

</param>
<param name="nWorkArea">

Specifies the work area for a table open in another work area. If a table is not open in the specified work area, <b>RELATION( )</b> returns an empty string.

</param>
<param name="cTableAlias">

Specifies the table alias for a table open in another work area.
</param>
<returns>
Character
</returns>
<remarks>
By default, RELATION( ) returns relational expressions for a specified table. If you do not specify a work area or alias, RELATION( ) returns relational expressions for the table in the currently selected work area. If no relations exist, it returns an empty string. For additional information about creating relations between tables, see SET RELATION.
DISPLAY STATUS and LIST STATUS display relational expressions. Issue MODIFY DATABASE to display the Database Designer. This enables you to view and modify relations between tables in the current open database. Issue SET to display the Data Session window. This enables you to view and modify relations between free tables.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer IN 0 ORDER cust_id  &amp;&amp; Opens Customer table
USE employee IN 0 ORDER emp_id  &amp;&amp; Opens Customer table
USE orders IN  0 ORDER order_id  &amp;&amp; Opens Customer table
SELECT orders
SET RELATION TO emp_id INTO employee
SET RELATION TO cust_id INTO customer ADDITIVE
? RELATION(1)  &amp;&amp; Displays CUST_ID
? RELATION(2)  &amp;&amp; Displays EMP_ID
? RELATION(3)  &amp;&amp; Displays empty string</code>
</example>
</relation>
<removeproperty>
<summary>
Removes a property from an object at run time. 
</summary>
<param name="oObjectName">

Specifies the name of the object from which to remove the property.

</param>
<param name="cPropertyName">

Specifies the name of the existing property to remove from the object. You can specify only a property name, not an event or method name.
</param>
<returns>
Logical data type. <b>REMOVEPROPERTY( )</b> returns True (.T.) if it successfully removes the property; otherwise, it returns False (.F.).
</returns>
<remarks>
You can use <b>REMOVEPROPERTY( )</b> to remove properties, but not methods or events. You can use <b>REMOVEPROPERTY( )</b> with object instances created from X# classes, COM classes, <b>SCATTER...NAME</b> command, <b>_VFP</b>, and <b>_SCREEN</b>.
Properties must be visibly <b>Public</b>, not <b>Hidden</b> or <b>Protected</b> and have been added to an instance of an object, typically using the <b>ADDPROPERTY( )</b> function, the <b>AddProperty</b> method, or <b>SCATTER...NAME</b> command, so that they can be removed using <b>REMOVEPROPERTY( )</b>.
You cannot remove a property if it is a member of the class definition used to create the instance of the object.

<b>REMOVEPROPERTY( )</b> function does not remove properties that are specific array elements. To remove an array, provide only the array name.

<b>Example 1</b>

The following example adds a new property to an object created with the <b>SCATTER</b> command and then removes it.
 <code language="X#">USE customers
SCATTER NAME oCust
ADDPROPERTY(oCust,"MyProperty")
REMOVEPROPERTY(oCust,"MyProperty")</code>

<b>Example 2</b>

The following example creates a property array for the object, codeoMyForm/code, displays its contents, code1/code and code"Two"/code, and then removes it.
 <code language="X#">oMyForm = CREATEOBJECT('Form')
ADDPROPERTY(oMyForm, 'MyArray(2)', 1)
oMyForm.MyArray(2) = "Two"
CLEAR
? oMyForm.MyArray(1)
? oMyForm.MyArray(2)
REMOVEPROPERTY(oMyForm, 'MyArray')
RELEASE oMyForm
CLEAR</code>
</remarks>
</removeproperty>
<replicate>
<summary>
Returns a character string that contains a specified character expression repeated a specified number of times.
</summary>
<param name="cExpression">

Specifies the character expression that is replicated.

</param>
<param name="nTimes">

Specifies the number of times the character expression is replicated.
</param>
<returns>
Character
</returns>
<remarks>
In X#, the maximum length of the resulting character string is restricted by the amount of available memory.
</remarks>
<example>
 <code language="X#">CLEAR
? REPLICATE('HELLO ',4) &amp;&amp; Displays HELLO HELLO HELLO HELLO</code>
</example>
</replicate>
<requery>
<summary>
Retrieves data again for a SQL view.
</summary>
<param name="nWorkArea">

Specifies the work area in which the SQL view is open.

</param>
<param name="cTableAlias">

Specifies the alias of the SQL view. If you omit nWorkArea and cTableAlias, the data for the SQL view open in the currently selected work area is retrieved.
</param>
<returns>
Numeric. <b>REQUERY( )</b> returns 1 if the data is successfully retrieved; otherwise, it returns 0.
</returns>
<remarks>

<b>REQUERY( )</b> is typically used to refresh a SQL view when data has changed on the data source.
</remarks>
</requery>
<rgb>
<summary>
Returns a single color value from a set of red, green, and blue color components.
</summary>
<param name="nRedValue">

Specifies the intensity of the red color component. nRedValue can range from 0 to 255. Zero is the minimum color intensity; 255 is the maximum color intensity.

</param>
<param name="nGreenValue">

Specifies the intensity of the green color component. nGreenValue can range from 0 to 255.

</param>
<param name="nBlueValue">

Specifies the intensity of the blue color component. nBlueValue can range from 0 to 255.
</param>
<remarks>
The value returned by RGB( ) can be used to set color properties such as BackColor and ForeColor.
</remarks>
<example>
 <code language="X#">goMyForm = CREATEOBJECT('FORM')  &amp;&amp; Create a form
goMyForm.Show  &amp;&amp; Display the form
WAIT WINDOW 'Press a key to change the form color'
goMyForm.BackColor=RGB(0,0,255)  &amp;&amp; Change the form background color
WAIT WINDOW 'Press a key to release the form'
RELEASE goMyForm  &amp;&amp; Release the form from memory</code>
</example>
</rgb>
<rgbscheme>
<summary>
Returns an RGB color pair or an RGB color pair list from a specified color scheme.
</summary>
<param name="nColorSchemeNumber">

Specifies the number of the color scheme for which you want a complete RGB color listing. RGBSCHEME( ) returns 10 RGB color pairs.

</param>
<param name="nColorPairPosition">

Returns a single RGB color pair from a color scheme. nColorPairPosition specifies the position of the RGB color pair in the color scheme. For example, if nColorPairPosition is 4, the fourth RGB color pair is returned.
</param>
<returns>
Character
</returns>
<remarks>
Use SCHEME( ) to return a traditional color pair or a color pair list from a color scheme. RGB color pairs use numeric values to specify colors. Traditional color pairs use letters to specify colors.
</remarks>
<example>
 <code language="X#">CLEAR
? RGBSCHEME(4,3)</code>
</example>
</rgbscheme>
<right>
<summary>
Returns the specified number of rightmost characters from a character string.
</summary>
<param name="cExpression">

Specifies the character expression whose rightmost characters are returned.

</param>
<param name="nCharacters">

Specifies the number of characters returned from the character expression. RIGHT( ) returns the entire character expression if nCharacters is greater than the length of cExpression. RIGHT( ) returns an empty string if nCharacters is negative or 0.
</param>
<returns>
Character
</returns>
<remarks>
Characters are returned beginning with the last character on the right and continuing for a specified number of characters.
</remarks>
<example>
 <code language="X#">CLEAR
? RIGHT('Redmond, WA', 2)  &amp;&amp; Displays WA</code>
</example>
</right>
<rlock>
<summary>
Attempts to lock a table record or records.
</summary>
<param name="cRecordNumberList">

Specifies that RLOCK( ) attempts to lock multiple records. The character expression cRecordNumberList specifies one or more record numbers, separated by commas, that RLOCK( ) attempts to lock. For example, to attempt record locks on the first four records in a table, cRecordNumberList should contain 1, 2, 3, 4. 
To lock multiple records, you must have SET MULTILOCKS on and you must include the work area number (nWorkArea) or alias (cTableAlias) of the table in which you attempt to lock multiple records.   
You can also lock multiple records by moving the record pointer to the record you would like to lock, issuing RLOCK( ) or LOCK( ) and then repeating this process for additional records.   
In X#, you can specify 0 as a record number. Specifying 0 lets you attempt to lock the table header.   
Keep the table header locked for as short a time as possible because other users cannot add records to the table when the table header is locked.
Release the table header lock with UNLOCK RECORD 0, UNLOCK, or UNLOCK ALL.   
If all the records specified in cRecordNumberList are successfully locked, RLOCK( ) returns true (.T.). If one or more of the records specified in cRecordNumberList cannot be locked, RLOCK( ) returns false (.F.) and locks none of the records. In either case, existing record locks remain in place. Multiple record locking is an additive process — placing additional record locks doesn't release existing record locks.   
From a performance perspective, it is always faster to lock the entire table than to lock even a small number of records.
</param>
<returns>
Logical
</returns>
<remarks>
RLOCK( ) is identical to LOCK( ).
Changes to explicitly locked records aren't saved until the record is unlocked or the record pointer is moved.
If the lock or locks are successfully placed, RLOCK( ) returns true (.T.). Locked records are available for both read and write access by the user who placed the locks and for read-only access to all other users on the network.
Executing RLOCK( ) doesn't guarantee that the attempted record lock or locks are successfully placed. A record lock cannot be placed on a record already locked by another user or in a table locked by another user. If the record lock or locks cannot be placed for any reason, RLOCK( ) returns false (.F.).
By default, RLOCK( ) makes one attempt to lock a record. Use SET REPROCESS to automatically retry a record lock when the first attempt fails. SET REPROCESS controls the number of lock attempts or the length of time lock attempts are made when the initial lock attempt is unsuccessful. For more information about SET REPROCESS and table locking, see SET REPROCESS.
SET MULTILOCKS determines whether you can lock multiple records in a table. If SET MULTILOCKS is off (the default), you can lock only a single record in a table. If SET MULTILOCKS is on, you can lock multiple records in a table. For more information, see SET MULTILOCKS.
A table record can be unlocked only by the user who placed the lock. Record locks can be released by issuing UNLOCK, closing the table, or exiting X#.
UNLOCK can be used to release record locks in the current work area, a specific work area or in all work areas. For more information, see UNLOCK.
Switching SET MULTILOCKS from ON to OFF or from OFF to ON implicitly performs UNLOCK ALL. All record locks in all work areas are released.
To close tables, use USE, CLEAR ALL, or CLOSE DATABASES.
For more information about record and file locking and sharing tables on a network, see Programming for Shared Access.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
SET REPROCESS TO 3 AUTOMATIC
STORE '1,2,3,4' TO gcRecList
gcOldExc = SET('EXCLUSIVE')
SET EXCLUSIVE OFF
SELECT 0
USE employee  &amp;&amp; Open Employee table
SELECT 0
USE customer  &amp;&amp; Open Customer table
? LOCK('1,2,3,4', 'customer')  &amp;&amp; Lock 1st 4 records in customer
? RLOCK(gcRecList, 'employee')  &amp;&amp; Lock 1st 4 records in employee
UNLOCK IN customer
UNLOCK IN employee
SET EXCLUSIVE &amp;gcOldExc</code>
</example>
</rlock>
<round>
<summary>
Returns a numeric expression rounded to a specified number of decimal places.
</summary>
<param name="nExpression">

Specifies the numeric expression whose value is to be rounded.

</param>
<param name="nDecimalPlaces">

Specifies the number of decimal places nExpression is rounded to.
If nDecimalPlaces is negative, <b>ROUND( )</b> returns a whole number containing zeros equal in number to nDecimalPlaces to the left of the decimal point. For example, if nDecimalPlaces is –2, the first and second digits to the left of the decimal point in the value are 0.
</param>
<returns>
Numeric data type. <b>ROUND( )</b> returns a value rounded to the nearest decimal position as specified by nDecimalPlaces.
</returns>
<remarks>

<b>ROUND( )</b> disregards the number of decimal places specified by the <b>SET DECIMALS</b> command. To display a larger number of decimal places than specified by nDecimalPlaces in <b>ROUND( )</b>, use <b>SET FIXED ON</b> with <b>SET DECIMALS</b>.
</remarks>
<example>
 <code language="X#">SET DECIMALS TO 4
SET FIXED ON
CLEAR
? ROUND(1234.1962, 3) &amp;&amp; Displays 1234.1960
? ROUND(1234.1962, 2) &amp;&amp; Displays 1234.2000
? ROUND(1234.1962, 0) &amp;&amp; Displays 1234.0000
? ROUND(1234.1962, -1)  &amp;&amp; Displays 1230.0000
? ROUND(1234.1962, -2)  &amp;&amp; Displays 1200.0000
? ROUND(1234.1962, -3)  &amp;&amp; Displays 1000.0000
SET FIXED OFF
SET DECIMALS TO 2</code>
</example>
</round>
<row>
<summary>
Included for backward compatibility. Use the CurrentX, CurrentY Properties.
 
Returns the current row position of the cursor.
</summary>
<returns>
Return value - Numeric
</returns>
<remarks>
<br />
ROW() is especially useful for directing screen output to a position relative to the current row position of the cursor.<br />
<br />
The special operator $ can be used in place of the ROW() function.<br />
<br />

</remarks>
<example>




 






<code language="X#">@ 5,5 SAY ' '
@ ROW() + 6, COL() SAY 'Contact person'
@ $ + 6, COL() SAY 'Contact person'
</code>					




</example>
</row>
<rtod>
<summary>
Converts radians to its equivalent in degrees.
You can use RTOD( ) when working with the X# trigonometric functions COS( ), SIN( ), and TAN( ). 
</summary>
<param name="nExpression">

Specifies a numeric expression representing a radian value.
</param>
<returns>
Numeric data type. RTOD( ) returns the number of degrees converted from the number of radians.
</returns>
<remarks>
To convert degrees to radians, use the DTOR( ) function.
</remarks>
<example>
 <code language="X#">CLEAR
? RTOD(ACOS(0))  &amp;&amp; Displays 90.00
STORE -1 to gnArcAngle
? RTOD(ACOS(gnArcAngle))  &amp;&amp; Displays 180.00
? RTOD(ACOS(SQRT(2)/2)) &amp;&amp; Displays 45.00</code>
</example>
</rtod>
<rtrim>
<summary>
Removes all trailing spaces or parsing characters from the specified character expression, or all trailing zero (0) bytes from the specified binary expression.
</summary>
<param name="cExpression">

Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove all trailing spaces or 0 bytes from, respectively.

</param>
<param name="nFlags">

Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

cParseChar [, cParseChar2 [, ...]]
Specifies one or more character strings that are trimmed from the end of cExpression. If cParseChar isn't included, then trailing spaces or 0 bytes are removed from Expression.
<b>Note</b>   The maximum number of strings permitted in cParseChar is 23. 
</param>
<returns>
Character or Varbinary. <b>RTRIM( )</b> returns the specified expression without trailing spaces or parsing characters, or 0 bytes.
</returns>
<remarks>
You can use <b>RTRIM( )</b> to ensure that trailing spaces or leading and trailing zero (0) bytes are removed from data entered by a user. <b>RTRIM( )</b> is identical to <b>TRIM( )</b>.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
CLEAR
? 'The contact for '+ RTRIM(company) + ' is ' + contact</code>
</example>
</rtrim>
<savepicture>
<summary>
Creates a bitmap (.bmp) file from a picture object reference.
</summary>
<param name="oObjectReference">

Specifies a picture object reference from which SAVEPICTURE( ) creates a bitmap file.

</param>
<param name="cFileName">

Specifies the name of the bitmap file that SAVEPICTURE( ) creates. If cFileName includes a path, the file is created in the directory specified in the path. If a file with the same name already exists, it is overwritten without warning, even if SET SAFETY is ON.
</param>
<returns>
Logical
</returns>
<remarks>
Picture object references are typically created with LOADPICTURE( ). However, certain properties (such as the PictureOpen property for the OLE Outline control) use a default picture object reference, which can be used to create a bitmap file.
</remarks>
</savepicture>
<scheme>
<summary>
Returns a color pair list or a single color pair from a specified color scheme.
</summary>
<param name="nSchemeNumber">

Specifies the number of the color scheme for which you want a complete color-pair list. SCHEME( ) returns ten color pairs.

</param>
<param name="nColorPairNumber">

Specifies the position of one color pair in the color scheme, and SCHEME( ) returns only this color pair. For example, if nColorPairNumber is 4, SCHEME( ) returns the fourth color pair from the color scheme.
</param>
<returns>
Character
</returns>
<example>
 <code language="X#">? SCHEME(4,3)</code>
</example>
</scheme>
<scols>
<summary>
Returns the number of columns available in the main X# window.
</summary>
<returns>
SCOLS( )Return Value
Numeric
</returns>
<remarks>
The value returned by SCOLS( ) depends on the current display mode. Display modes can be changed with SET DISPLAY.
</remarks>
</scols>
<seconds>
<summary>
Returns the number of seconds that have elapsed since midnight.
</summary>
<returns>
SECONDS( )Return Value
Numeric. <b>SECONDS( )</b> returns a numeric value in decimal format with a resolution of 1 millisecond. For versions of X# running on Windows NT 4.0 or later, <b>SECONDS( )</b> returns a resolution of 10 milliseconds.
</returns>
<example>
 <code language="X#">CLEAR
? SECONDS( )
? SECONDS( )/(60 * 60)</code>
</example>
</seconds>
<seek>
<summary>
Searches an indexed table for the first occurrence of a record whose index key matches a specified expression. Issuing SEEK( ) is equivalent to issuing SEEK and FOUND( ) in succession.
X# does not support seek operations for binary indexes.
</summary>
<param name="eExpression">

Specifies the index key expression for which you want SEEK( ) to search.

</param>
<param name="nWorkArea">

Specifies the work area number of the table that is searched for the index key.

</param>
<param name="cTableAlias">

Specifies the alias of the table that is searched.
If you omit nWorkArea and cTableAlias, the table in the currently selected work area is searched. 

</param>
<param name="nIndexNumber">

Specifies the number of the index file or tag that is used to search for the index key. nIndexNumber refers to the index files as they are listed in USE or SET INDEX. Open .idx files are numbered first in the order in which they appear in USE or SET INDEX. Tags in the structural .cdx file (if one exists) are then numbered in the order in which they were created. Finally, tags in any open independent .cdx files are numbered in the order in which they were created. For more information about index numbering, see SET ORDER Command.

</param>
<param name="cIDXIndexFileName">

Specifies an .idx file that is used to search for the index key.

</param>
<param name="cTagName">

Specifies a tag of a .cdx file that is used to search for the index key. The tag name can be from a structural .cdx file or any open independent .cdx file.
The .idx file takes precedence if duplicate .idx file and tag names exist.
</param>
<returns>
Logical. SEEK( ) returns True (.T.) if a match is found and the record pointer moves to the matching record. Otherwise, SEEK( ) returns False (.F.) if a match is not found, and the record pointer moves to the end of the file if SET NEAR is OFF or to the closest matching record if SET NEAR is ON. 
</returns>
<remarks>
You can use SEEK( ) on a table with an index order set, or if an index order is not set on the table, set the controlling index with the 3rd parameter, nIndexNumber, cIDXIndexFileName, or cTagName. The match must be exact unless SET EXACT is set to OFF.
If you omit the nIndexNumber, IDXIndexFileName, and cTagName arguments, SEEK( ) uses the master controlling index or index tag to search for the index key.
The SET KEY setting is ignored if SEEK( ) uses a non-active index.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer ORDER cust_id  &amp;&amp; Opens Customer table
? SEEK('CHOPS')  &amp;&amp; Returns .T., record found</code>
</example>
</seek>
<select>
<summary>
Returns the number of the currently selected work area or the highest-numbered unused work area.
</summary>
<param name="cTableAlias">

Specifies the alias of the table for which SELECT( ) returns the work area.
</param>
<returns>
Numeric
</returns>
<remarks>
SELECT( ) returns the number of the current work area if SET COMPATIBLE is set to OFF. If SET COMPATIBLE is set to ON, SELECT( ) returns the number of the unused work area with the highest number.
A work area can be selected (activated) with SELECT.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
SET COMPATIBLE ON
OPEN DATABASE (HOME(2) + 'data\testdata')
SELECT 0  &amp;&amp; Unused work area
USE customer  &amp;&amp; Opens Customer table
SELECT 0  &amp;&amp; Unused work area
USE orders  &amp;&amp; Opens Orders table
CLEAR
? SELECT( )  &amp;&amp; Returns 3, lowest available work area</code>
</example>
</select>
<set>
<summary>
Returns the status of various <b>SET</b> commands.
</summary>
<param name="cSETCommand">

Specifies a character expression of the <b>SET</b> command for which you want to return information. The current setting of the specified command is returned as a character or numeric string.
1 | cExpression| 2 | 3 | 4 
Specifies additional information to return about a <b>SET</b> command. The values 1 and cExpression are identical. cExpression can be any expression that evaluates to a character type value.
Including an argument does not return additional information for all <b>SET</b> commands. Only those that specify values of 1, 2, 3, or 4 in the following table return additional information.
ALTERNATE
ON or OFF
ALTERNATE, 1
</param>
<param name="FileName">

</param>
<param name="FileName">

ANSI
ON or OFF
ASSERTS
AUTOINCERROR
AUTOSAVE
BELL, 1
</param>
<param name="cWAVFileName">

</param>
<param name="cWAVFileName">

BLOCKSIZE
</param>
<param name="nBlockSize">

</param>
<param name="nBlockSize">

BROWSEIME
ON or OFF
CARRY
CENTURY
CENTURY, 1
</param>
<param name="nCentury">

</param>
<param name="nCentury">

CENTURY, 2
ROLLOVER nYear
CENTURY, 3
System Regional Calendar setting
CLASSLIB
</param>
<param name="cClassLibName">

</param>
<param name="cClassLibName">

CLOCK
ON or OFF
CLOCK, 1
</param>
<param name="nRow and nColumn">

</param>
<param name="nRow and nColumn">
COLLATE
ON or OFF
COLOR OF SCHEME
</param>
<param name="cR, cG, cB">

</param>
<param name="cR, cG, cB">

COLOR SET
</param>
<param name="cNameOfColorSet">

</param>
<param name="cNameOfColorSet">

COMPATIBLE
ON or OFF
COMPATIBLE, 1
PROMPT or NOPROMPT
CONFIRM
CONSOLE
COVERAGE
COVERAGE, 1
</param>
<param name="FileName">

</param>
<param name="FileName">

CPCOMPILE
</param>
<param name="nCodePage">

</param>
<param name="nCodePage">

CPDIALOG
ON or OFF
CURRENCY
LEFT or RIGHT
CURRENCY, 1
</param>
<param name="cCurrencySymbol">

</param>
<param name="cCurrencySymbol">

CURSOR
ON or OFF
DATABASE
</param>
<param name="cDatabase">

</param>
<param name="cDatabase">

DATASESSION
</param>
<param name="nDataSession">

</param>
<param name="nDataSession">

DATE
AMERICAN, ANSI, BRITISH/FRENCH, GERMAN, ITALIAN, JAPAN, USA, MDY, DMY, or YMD
DATE, 1
Date Ordering:0 – MDY1 – DMY2 – YMD
DEBUG
ON or OFF
DEBUGOUT
</param>
<param name="cFileName">

</param>
<param name="cFileName">

DECIMALS
</param>
<param name="nDecimals">

</param>
<param name="nDecimals">

DEFAULT
</param>
<param name="cDirectory">

</param>
<param name="cDirectory">

DELETED
ON or OFF
DELIMITERS
DELIMITERS, 1
</param>
<param name="cDelimiters">

</param>
<param name="cDelimiters">

DEVELOPMENT
ON or OFF
DEVICE
SCREEN, PRINTER, or FILE
DEVICE, 1
</param>
<param name="cFileName">

</param>
<param name="cFileName">

DIRECTORY
</param>
<param name="cDirectory">

</param>
<param name="cDirectory">

DOHISTORY
ON or OFF
ENGINEBEHAVIOR
</param>
<param name="nVersionNumber">

</param>
<param name="nVersionNumber">

ESCAPE
ON or OFF
EVENTLIST
comma delimited list of events
EVENTTRACKING
EVENTTRACKING, 1
</param>
<param name="FileName">

</param>
<param name="FileName">

EXACT
ON or OFF
EXCLUSIVE
FDOW
</param>
<param name="nDayofWeek">

</param>
<param name="nDayofWeek">

FIELDS
ON or OFF
FIELDS, 1
</param>
<param name="FieldName1, FieldName2, ...">

</param>
<param name="FieldName1, FieldName2, ...">
FIELDS, 2
LOCAL or GLOBAL
FILTER
</param>
<param name="cFilterExpression">

</param>
<param name="cFilterExpression">

FIXED
ON or OFF
FULLPATH
FWEEK
</param>
<param name="nWeekNumber">

</param>
<param name="nWeekNumber">

HEADINGS
ON or OFF
HELP
HELP, 1
</param>
<param name="cFileName">

</param>
<param name="cFileName">

HELP, 2
</param>
<param name="cCollectionURL">

</param>
<param name="cCollectionURL">

HELP, 3
</param>
<param name="SYSTEM">

</param>
<param name="SYSTEM">

HOURS
12 or 24
INDEX
</param>
<param name="cIndexExpression">

</param>
<param name="cIndexExpression">

KEY
</param>
<param name="eExpression2, eExpression3">

</param>
<param name="eExpression2, eExpression3">
KEY, 1
</param>
<param name="eExpression2">

</param>
<param name="eExpression2">

KEY, 2
</param>
<param name="eExpression3">

</param>
<param name="eExpression3">

KEYCOMP
DOS or WINDOWS
LIBRARY
</param>
<param name="cNameOfLibrary">

</param>
<param name="cNameOfLibrary">

LOCK
ON or OFF
LOGERRORS
MACKEY
</param>
<param name="cKey">

</param>
<param name="cKey">

MARGIN
</param>
<param name="nMargin">

</param>
<param name="nMargin">

MEMOWIDTH
</param>
<param name="nWidth">

</param>
<param name="nWidth">

MESSAGE
</param>
<param name="nRow">

</param>
<param name="nRow">

MESSAGE, 1
</param>
<param name="cMessageText">

</param>
<param name="cMessageText">

MOUSE
ON or OFF
MOUSE, 1
</param>
<param name="nSensitivity">

</param>
<param name="nSensitivity">

MULTILOCKS
ON or OFF
NEAR
NOCPTRANS
comma delimited list of fields
NOTIFY
NOTIFY, 1
NULL
NULLDISPLAY
</param>
<param name="cDisplayString">

</param>
<param name="cDisplayString">

ODOMETER
</param>
<param name="nNumberOfRecords">

</param>
<param name="nNumberOfRecords">

OLEOBJECT
ON or OFF
OPTIMIZE
ORDER
TAG TagName OF CDXFileName, IDXFileName, or blank
PALETTE
PATH
</param>
<param name="cPath">

</param>
<param name="cPath">

PDSETUP
</param>
<param name="cPrinterDriverName">

</param>
<param name="cPrinterDriverName">

POINT
</param>
<param name="cDecimalPtChar">

</param>
<param name="cDecimalPtChar">

PRINTER
ON or OFF
PRINTER, 1
</param>
<param name="FileName or PortName">

</param>
<param name="FileName or PortName">
PRINTER, 2
Default Windows printer name
PRINTER, 3
Default X# printer name(specified in the X# Print or Print Setup dialog boxes)
PROCEDURE
</param>
<param name="cPathAndName">

</param>
<param name="cPathAndName">

READBORDER
ON or OFF
REFRESH
</param>
<param name="nSeconds1">

</param>
<param name="nSeconds1">

REFRESH, 1
</param>
<param name="nseconds2">

</param>
<param name="nseconds2">

REPORTBEHAVIOR
</param>
<param name="nVersionNumber">

</param>
<param name="nVersionNumber">

REPROCESS
Current session setting
REPROCESS, 1
System session setting
REPROCESS, 2
Current session setting type
0 is returned if REPROCESS is set to attempts. 
1 is returned if REPROCESS is set to seconds.
REPROCESS, 3
System session setting type
RESOURCE
ON or OFF
RESOURCE, 1
</param>
<param name="FileName">

</param>
<param name="FileName">

SAFETY
ON or OFF
SECONDS
SEPARATOR
</param>
<param name="cSeparatorChar">

</param>
<param name="cSeparatorChar">

SPACE
ON or OFF
SQLBUFFERING
STATUS
STATUS BAR
STRICTDATE
SYSFORMATS
SYSMENU
ON, OFF, or AUTOMATIC
TABLEPROMPT
TABLEVALIDATE
</param>
<param name="nLevel">

</param>
<param name="nLevel">

TALK
ON or OFF
TALK, 1
WINDOW, NOWINDOW or WindowName
TEXTMERGE
TEXTMERGE, 1
</param>
<param name="cLeftDelimiter and cRightDelimiter">

</param>
<param name="cLeftDelimiter and cRightDelimiter">
TEXTMERGE, 2
</param>
<param name="cFileName">

</param>
<param name="cFileName">

TEXTMERGE, 3
SHOW/NOSHOW
TEXTMERGE, 4
Evaluate source of TEXT ... ENDTEXT call and return TEXTMERGE nesting level. 
TOPIC
</param>
<param name="cHelpTopicName | lExpression">

</param>
<param name="cHelpTopicName | lExpression">
TOPIC, 1
</param>
<param name="NContextID">

</param>
<param name="NContextID">

UDFPARMS
VALUE or REFERENCE
UNIQUE
ON or OFF
</param>
<returns>
Character or Numeric data type. <b>SET( )</b> returns the value of a <b>SET</b> command.
</returns>
<remarks>

<b>SET( )</b> recognizes the 4-character abbreviation for all X# <b>SET</b> keywords, with the exception of <b>HELPFILTER</b>, which can be abbreviated to 5 characters. For example, you can use <b>STAT</b> and <b>PRIN</b> for <b>SET STATUS </b><b>SET PRINTER</b>, respectively.
The <b>SET( )</b> function is identical to <b>SYS(2001)</b>.
</remarks>
</set>
<setfldstate>
<summary>
Assigns a field modification or deletion state value to a field or record in a table or cursor.
</summary>
<param name="nFieldState">

Specifies a value for the field modification or deletion status. The following table lists the field modification or deletion state value and the corresponding modification or deletion status:
nFieldState
1
Field has not been modified or deletion status has not changed.
2
Field has been modified or deletion status has changed.
3
Field in an appended record has not been modified or deletion status has not changed for the appended record.
4
Field in an appended record has been modified or deletion status has changed for the appended record.

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor in which the modification or deletion status is assigned.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor in which the modification or deletion status is assigned. The field modification or deletion state value is assigned for the table or cursor open in the currently selected work area if SETFLDSTATE( ) is issued without the optional cTableAlias or nWorkArea arguments.
</param>
<returns>
Logical
</returns>
<remarks>
X# uses field state values to determine which fields in tables or cursors are updated. SETFLDSTATE( ) makes it possible for you to control which fields X# attempts to update, regardless of which fields have been modified in the table or cursor.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
SET MULTILOCKS ON  &amp;&amp; Must be on for table buffering
SET PATH TO (HOME(2) + 'Data\')     &amp;&amp; Sets path to database
OPEN DATABASE testdata  &amp;&amp; Open testdata database
USE Customer     &amp;&amp; Open customer table
= CURSORSETPROP('Buffering', 5, 'customer')  &amp;&amp; Enable table buffering
CLEAR
? GETFLDSTATE('cust_id')  &amp;&amp; Displays 1, not modified
REPLACE cust_id    WITH '***'  &amp;&amp; Changes field contents
? GETFLDSTATE('cust_id')  &amp;&amp; Returns 2, field modified
= SETFLDSTATE('cust_id', 1)  &amp;&amp; Change the field status
? GETFLDSTATE('cust_id')  &amp;&amp; Displays 1, not modified
= TABLEREVERT(.T.)  &amp;&amp; Discard all table changes</code>
</example>
</setfldstate>
<setresultset>
<summary>
Marks a cursor as a result set in the current data session. 
Only one cursor per data session can be marked. When marking a new cursor, <b>SETRESULTSET( )</b> clears the marker from any previously marked cursor.
</summary>
<param name="nWorkArea">

Specifies a work area number.

</param>
<param name="cTableAlias">

Specifies the alias of the cursor you want to mark.
</param>
<returns>
Numeric. <b>SETRESULTSET( )</b> returns the number of the work area of the previously marked cursor in the current data session or zero (0) if no cursor is marked in the current data session.
</returns>
<remarks>

<b>SETRESULTSET( )</b> is supported in X# and the X# OLE DB Provider. You can use <b>SETRESULTSET( )</b> in a database container (DBC) stored procedure or send it to the X# OLE DB Provider, assuming that the cursor has been previously opened by the OLE DB Provider. For example, suppose a previous command opens a cursor named MyCursor in the OLE DB Provider. The following line of code retrieves an ADO RecordSet for the cursor, MyCursor:
 <code language="X#">oRecordSet = oConn.Execute("SETRESULTSET('MyCursor')")</code>
By using <b>SETRESULTSET( )</b> to mark a cursor or table opened by the X# OLE DB Provider, you can retrieve a rowset created from the table or cursor from a database container (DBC) stored procedure. When the OLE DB Provider completes command execution, it creates a rowset from the marked cursor, if it exists, then clears the marker flag from the cursor.
In this scenario, the OLE DB Provider disregards all other return values. For example, if a stored procedure contains a <b>RETURN</b> Value statement and a marked cursor, the OLE DB Provider does not return the value. Instead, it returns the marked cursor as a rowset to the calling application. When the rowset closes, the cursor also closes.
However, even though the OLE DB Provider disregards all return values when a marked cursor exists, you can use <b>SETRESULTSET( )</b> with the <b>RETURN</b> command. For example:
 <code language="X#">RETURN SETRESULTSET("MyCursor")</code>
This statement creates and returns a rowset from the marked cursor, not the return value from <b>SETRESULTSET( )</b>.
</remarks>
</setresultset>
<sin>
<summary>
Returns the sine of an angle.
</summary>
<param name="nExpression">

Specifies an angle whose sine SIN( ) returns. nExpression can assume any value and the value returned by SIN( ) ranges between –1 and 1.
nExpression is specified in radians. Use DTOR( ) to convert an angle from degrees to radians. The number of decimal places displayed by SIN( ) can be specified with SET DECIMALS.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">CLEAR
? SIN(0)  &amp;&amp; Displays 0.00
? SIN(PI( )/2)  &amp;&amp; Displays 1.00
? SIN(DTOR(90))  &amp;&amp; Displays 1.00</code>
</example>
</sin>
<skpbar>
<summary>
Determines if a menu item is enabled or disabled with SET SKIP OF.
</summary>
<param name="cMenuName">

Specifies the name of the menu that contains the item.

</param>
<param name="MenuItemNumber">

Specifies the number of the menu item whose status (enabled or disabled) SKPBAR( ) returns. The menu item number is assigned when the menu item is created with DEFINE BAR.
</param>
<returns>
Logical
</returns>
<remarks>
SKPBAR( ) returns true (.T.) if the menu item is disabled, and false (.F.) if the menu item is enabled.
</remarks>
</skpbar>
<skppad>
<summary>
Determines whether a menu title is enabled or disabled with SET SKIP OF.
</summary>
<param name="cMenuBarName">

Specifies the name of the menu bar that contains the menu title.

</param>
<param name="cMenuTitleName">

Specifies the name of the menu title whose status (enabled or disabled) SKPPAD( ) returns.
</param>
<returns>
Logical
</returns>
<remarks>
SKPPAD( ) returns true (.T.) if the menu title is disabled, and false (.F.) if the menu title is enabled.
</remarks>
</skppad>
<soundex>
<summary>
Returns a phonetic representation of the specified character expression.
</summary>
<param name="cExpression">

Specifies the character expression SOUNDEX( ) evaluates.
</param>
<returns>
Character
</returns>
<remarks>
SOUNDEX( ) returns a four-character string. By comparing the results SOUNDEX( ) returns for two character expressions, you can determine if the two expressions are phonetically similar, indicating that they sound alike. This can be useful when searching for duplicate records in a table.
SOUNDEX( ) isn't case sensitive and generally disregards vowels.
</remarks>
<example>
 <code language="X#">CLEAR
? SOUNDEX('Smith') = SOUNDEX('Smyth')  &amp;&amp; Displays .T.
? SOUNDEX('Computer')  &amp;&amp; Displays C513</code>
</example>
</soundex>
<space>
<summary>
Returns a character string composed of a specified number of spaces.
</summary>
<param name="nSpaces">

Specifies the number of spaces that SPACE( ) returns. The maximum value of nSpaces is limited only by memory in X#.
</param>
<returns>
Character
</returns>
</space>
<sqlcancel>
<summary>
Requests cancellation of an executing SQL statement.

<b>SQLCANCEL( )</b> cancels the execution of <b>SQLCOLUMNS( )</b>, <b>SQLEXEC( )</b>, <b>SQLMORERESULTS( )</b>, and <b>SQLTABLES( )</b> in asynchronous mode. To establish asynchronous mode, use the <b>SQLSETPROP( )</b> function.
</summary>
<param name="nStatementHandle">

Specifies the active statement handle whose SQL statement is to be canceled.
</param>
<returns>
Numeric. <b>SQLCANCEL( )</b> returns 1 if the SQL statement is successfully canceled, – 1 if there is a connection level error, and – 2 if there is an environment level error.
</returns>
<example>
 <code language="X#">= SQLSETPROP(gnHandle, 'asynchronous', .T.)   &amp;&amp; To stop SQLEXEC( )
= SQLEXEC(gnHandle, 'SELECT * FROM authors')
= SQLCANCEL(gnHandle)   &amp;&amp; Wrong select statement, cancel</code>
</example>
</sqlcancel>
<sqlcolumns>
<summary>
Stores a list of column names and information about each column for the specified data source table to a X# cursor.
</summary>
<param name="nStatementHandle">

Specifies an active statement handle.

</param>
<param name="cTableName">

Specifies the name of the table from which the column names are returned. TableName can contain the wildcard characters ? and *. The question mark (?) matches any single character and the asterisk (*) matches any number of characters.
FOXPRO | NATIVE 
Specifies the format for the column information in the result set. Be sure to enclose FOXPRO or NATIVE in quotation marks. The NATIVE format option stores column information for tables in the same format as the data source. The FOXPRO format option stores the column information in the same format as that used for the X# table or cursor that would be created if you imported the data source table into X#. If you omit FOXPRO or NATIVE, the format option defaults to FOXPRO.
The following table shows the columns in the result set for the FOXPRO format.   
Field_name
Column name
Field_type
Column data type
Field_len
Column length
Field_dec
Number of decimal places
The columns in the result set for the NATIVE format depend on the data source. If the table you specify with cTableName does not exist and the format is set to NATIVE, <b>SQLCOLUMNS( )</b> returns true (.T.) and creates an empty table or cursor. If the table you specify with cTableName does not exist and the format is set to FOXPRO, <b>SQLCOLUMNS( )</b> returns false (.F.).
</param>
<param name="cCursorName">

Specifies the name of the X# cursor for the result set. If you do not include a cursor name, X# uses the default name SQLRESULT.
</param>
<returns>
Numeric or Logical. <b>SQLCOLUMNS( )</b> returns 1 if the cursor is successfully created, 0 if <b>SQLCOLUMNS( )</b> is still executing, – 1 if a connection level error occurs, and – 2 if an environment level error occurs.
</returns>
<remarks>

<b>SQLCOLUMNS( )</b> is one of the four functions that you can execute either synchronously or asynchronously. The Asynchronous setting of <b>SQLSETPROP( )</b> determines if these functions execute synchronously or asynchronously. In asynchronous mode, you must call <b>SQLCOLUMNS( )</b> repeatedly until a value other than false (.F.) (still executing) is returned.
</remarks>
<example>
 <code language="X#">= SQLCOLUMNS(gnHandle, 'authors', 'FOXPRO', 'MyCursor')</code>
</example>
</sqlcolumns>
<sqlcommit>
<summary>
Commits a transaction. 
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by <b>SQLCONNECT( )</b>.
</param>
<returns>
Numeric. <b>SQLCOMMIT( )</b> returns 1 if the transaction is successfully committed; otherwise, it returns -1. If <b>SQLCOMMIT( )</b> returns -1, you can use <b>AERROR( )</b> to determine why the transaction could not be committed.
</returns>
<remarks>
If manual transactions are in effect (the <b>SQLSETPROP( )</b> Transactions property is set to Manual), you can send multiple updates to remote tables and commit all the updates with <b>SQLCOMMIT( )</b>.
Updates can be rolled back with <b>SQLROLLBACK( )</b>.
</remarks>
<example>
 <code language="X#">= SQLSETPROP(gnHandle, 'Transactions', 2)  &amp;&amp; Manual transactions
= SQLEXEC(gnHandle, "INSERT INTO authors (au_id, au_lname);
VALUES ('aupoe', 'Poe')")  &amp;&amp; Modify the authors table
= SQLCOMMIT(gnHandle)  &amp;&amp; Commit the changes</code>
</example>
</sqlcommit>
<sqlconnect>
<summary>
Establishes a connection to a data source. There are two versions of the syntax.
</summary>
<param name="nStatementHandle">

Specifies that a new statement handle be created for the underlying shared connection that is represented by nStatementHandle. The new statement handle uses the settings provided from nStatementHandle instead of using the default settings. 
You cannot create a new statement handle for a connection that is not shared. X# generates an error if you attempt to create a new statement handle against a nonshared connection.
You can also use <b>SQLCONNECT( )</b> to obtain a new statement handle on a shared connection that was opened using <b>SQLSTRINGCONNECT( )</b>. 

</param>
<param name="cConnectionName">

Specifies a named connection created by the <b>CREATE CONNECTION</b> command. 
When using <b>CREATE CONNECTION</b> or the Connection Designer to create a named connection, you can configure the connection by specifying a data source name, user ID, and password. When using the named connection in <b>SQLCONNECT( )</b> as cConnectionName, you can pass values different from those in the named connection for the optional cUserID and cPassword parameters. These passed values are used instead of the user ID and password in the named connection specified by cConnectionName.    
For example, suppose you create a named connection called codemyNamedConnection/code using <b>CREATE CONNECTION</b> or the Connection Designer and specify the values codemyUserID/code and codemyPassword/code for the named connection. For <b>SQLCONNECT( )</b>, you can specify codemyNamedConnection/code as cConnectionName and then specify codemyAltUserID/code and codemyAltPassword/code as an alternate user ID and password as in the following code:   
 <code language="X#">SQLCONNECT("myNamedConnection", "myAltUserID", "myAltPassword")</code>
However, if you create a named connection using a connection string with <b>CREATE CONNECTION</b> or the Connection Designer, use the named connection in <b>SQLCONNECT( )</b>, and attempt to pass optional user ID and password parameters to <b>SQLCONNECT( )</b>, X# generates the appropriate message.   
When creating a new shared connection, the cConnectionName parameter refers to a named connection in the current database container (DBC).    
When creating a new statement handle based on an existing shared connection, the cConnectionName parameter refers to a previous connection opened in shared mode.   
If you use the cConnectionName parameter without the lShared parameter or with lShared parameter as False (.F.), you will always create a new connection that is not shared.   
When using cConnectionName, if lShared is True (.T.) and the named connection is already open in shared mode, the user name and password provided should match those previously used. Otherwise, X# generates the appropriate message. 

</param>
<param name="cDataSourceName">

Specifies the name of a data source as defined in your Odbc.ini file. 
You can also choose a data source from the Select Connection or Data Source Dialog Box, which appears when you call <b>SQLCONNECT( )</b> without any additional arguments or with only the lShared parameter. 

</param>
<param name="cUserID">

Specifies the user identifier used to log on to the data source.

</param>
<param name="cPassword">

Specifies the password for gaining access to the data source.

</param>
<param name="lShared">

Specifies whether or not to create a shared connection.
lShared
False (.F.)
<b>SQLCONNECT( )</b> does not create a shared connection. (Default)
True (.T.)
<b>SQLCONNECT( )</b> creates a shared connection.
</param>
<returns>
Numeric data type. <b>SQLCONNECT( )</b> returns a positive nonzero numeric value as the statement handle if you successfully connect to the data source. <b>SQLCONNECT( )</b> returns –1 if it cannot make the connection.
You should store this statement handle in a memory variable and use the variable in subsequent function calls that require a connection handle. 
</returns>
<remarks>
The <b>SQLCONNECT( )</b> and <b>SQLSTRINGCONNECT( )</b> functions return a numeric value as the statement handle rather than a connection handle. You cannot obtain a connection handle directly. You can still set and get connection properties using the <b>SQLSETPROP( )</b> and <b>SQLGETPROP( )</b> functions by passing the statement handle for that connection and the string, "Shared", as arguments. All other SQL functions use a statement handle instead of a connection handle.
If you issue a statement such as codeSQLCONNECT(cConnectionName, .T.)/code, and a shared connection is already open with the same name, then the settings for that connection do not change to the settings stored for that connection in the database container (DBC). However, the new statement handle will use the statement settings from the DBC.
You must disable the Open Database Connectivity (ODBC) login dialog box to support SQL pass through with Microsoft Transaction Server. To disable the ODBC login dialog box, use the statement codeSQLSETPROP(nStatementHandle, 'DispLogin', 3)/code, where cStatementHandle is the statement handle returned by <b>SQLCONNECT( )</b>. You can also disable the ODBC login dialog box in the Connection Designer.
</remarks>
<example>

<b>Example 1</b>

The following example assumes that an ODBC data source called MyFoxSQLNT exists and is available. <b>SQLCONNECT( )</b> returns a numeric value, which is stored to a variable named codegnConnHandle/code.
If you successfully connect to the data source, <b>SQLCONNECT( )</b> returns a positive number, a dialog box appears, and <b>SQLDISCONNECT( )</b> is called to disconnect from the data source.
If you cannot connect to the data source, <b>SQLCONNECT( )</b> returns a negative number and displays a message.
 <code language="X#">STORE SQLCONNECT('MyFoxSQLNT', 'myUserID', 'myPassword') TO gnConnHandle
IF gnConnHandle &lt;= 0
= MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
ELSE
= MESSAGEBOX('Connection made', 48, 'SQL Connect Message')
= SQLDISCONNECT(gnHandle)
ENDIF</code>

<b>Example 2</b>

Each of the following examples create new shared connections. The Choose Data Source Dialog Box appears, and <b>SQLCONNECT( )</b> creates the resulting connection as shared.
 <code language="X#">SQLCONNECT(.T.)
SQLCONNECT( myConnectionName, .T. )
SQLCONNECT( myDataSourceName, myUserID, myPassword, .T. )</code>

<b>Example 3</b>

Each of the following examples creates a new statement handle based on an existing shared connection.
 <code language="X#">SQLCONNECT( nStatementHandleValue )
SQLCONNECT( myConnectionName, .T. )  </code>
</example>
</sqlconnect>
<sqldisconnect>
<summary>
Terminates a connection to a data source.
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by <b>SQLCONNECT( )</b>. Specify 0 for nStatementHandle to terminate all active connections.
</param>
<returns>
Numeric. <b>SQLDISCONNECT( )</b> returns 1 if the connection is successfully terminated, – 1 if there is a connection level error, and – 2 if there is an environment level error.
</returns>
<remarks>

<b>SQLDISCONNECT( )</b> terminates a connection to a data source. You must supply the statement handle that <b>SQLCONNECT( )</b> returned when you established the connection.
If you execute <b>SQLDISCONNECT( )</b> within an asynchronous function sequence or during a transaction, <b>SQLDISCONNECT( )</b> generates an error.
</remarks>
<example>
 <code language="X#">STORE SQLCONNECT('MyFoxSQLNT', '&lt;userid&gt;', '&lt;password&gt;') TO gnHandle
IF gnHandle &lt;= 0
= MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
ELSE
= MESSAGEBOX('Connection made', 48, 'SQL Connect Message)
= SQLDISCONNECT(gnHandle)
ENDIF</code>
</example>
</sqldisconnect>
<sqlexec>
<summary>
Sends a SQL statement to the data source, where the statement is processed.
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by the <b>SQLCONNECT( )</b> function. For more information, see SQLCONNECT( ) Function.

</param>
<param name="cSQLCommand">

Specifies the SQL statement passed to the data source.
The SQL statement can contain a parameterized WHERE clause, which creates a parameterized view. You must define all parameters in the WHERE clause before issuing <b>SQLEXEC( )</b>. For example, if the parameters are variables, the variables must be created and initialized before <b>SQLEXEC( )</b> is issued. For more information about parameterized views, see How to: Create Parameterized Views.   
You can include expressions in the SQL statement. X# evaluates all expressions in the SQL statement that you pass before sending them to the data source. X# can evaluate memory variable names, function calls, and expressions enclosed in parentheses as parameter values. 

</param>
<param name="cCursorName">

Specifies the name of the X# cursor to which the result set is sent. If you don't include a cursor name, X# uses the default name SQLRESULT.
For multiple result sets, new cursor names are derived by appending an incremented number to the name of the first cursor. 

</param>
<param name="">

Specifies the name of the array to populate with row count information. If the array doesn’t exist, it is created. The array has two columns: 1 – Alias, 2 –Count.
0
Character
Indicates that SQL command did not return any results. Either no records were returned or the SQL command failed before results could be returned. (final <b>SQLMORERESULTS</b> call) or execution failed before any result could be processed. Can be only on the first row. Count column for the row contains value -1.
Non-empty uppercase string
Alias of the cursor – target for the record fetch operation. The Count column for the row contains the number of fetched records or -1 if fetch failed. If Count is -1, cursor may not have been created. During asynchronous execution, the fetch process for a cursor can be split between multiple SQLMORERESULTS or SQLEXEC calls; each call returns its own fetch count for the cursor.
Empty String
Indicates that the SQL command (INSERT, UPDATE, or DELETE) did not return a result set. 
Number of affected or fetched records.
Integer
Indicates the number of affected records as returned by the ODBC SQLRowCount function. Returns -1 if the number of records is unavailable.
</param>
<returns>
Numeric data type. <b>SQLEXEC( )</b> returns the number of result sets if there is more than one. <b>SQLEXEC( )</b> returns 0 if it is still executing and returns 1 when it has finished executing. <b>SQLEXEC( )</b> returns –1 if a connection level error occurs.
</returns>
<remarks>
If the SQL statement you want to pass is quite long, check to see if it exceeds the maximum length of a string literal in X#, which is 255 characters. Longer strings will cause a "Command contains unrecognized phrase/keyword" error. However, you can pass long SQL statements if you break them up into several concatenated literals. For example:
 <code language="X#">lnRetVal = SQLEXEC(lnHandle, "SELECT &lt;long list of fields&gt; " + ;
"FROM &lt;several tables&gt; " + ;
"WHERE &lt;complex filter expression&gt;")</code>
If <b>SQLEXEC( )</b> is used to execute a SQL statement prepared with <b>SQLPREPARE( )</b>, only the connection handle argument nStatementHandle is required. The cSQLCommand and CursorName arguments should be omitted. For more information, see SQLPREPARE( ) Function.
If the SQL statement generates one result set, <b>SQLEXEC( )</b> stores the result set to the specified X# cursor. If the SQL statement generates two or more result sets, you can name each result set by setting the connection's BatchMode property to False (.F.) using the SQLSETPROP( ) function and changing the cursor name each time you call the SQLMORERESULTS( ) function. Otherwise, SQLEXEC( ) names each result set by appending sequential numbers to the name of the first one.

<b>SQLEXEC( )</b> is one of the four functions that you can execute either synchronously or asynchronously. The Asynchronous setting of <b>SQLSETPROP( )</b> determines whether these functions execute synchronously or asynchronously. In asynchronous mode, you must call <b>SQLEXEC( )</b> repeatedly until it returns a value other than 0 (still executing).
</remarks>
<example>
The following example shows various ways to use <b>SQLEXEC( )</b> to execute ad-hoc queries and to call or create stored procedures:
 <code language="X#">CLEAR
LOCAL lnConn
LOCAL lnPercent AS Int  &amp;&amp; Input parameters must be typed.
LOCAL lnOutput
lnPercent = 50
lnOutput = 0
* Make connection, assuming a local trusted connection.
lnConn = SQLCONNECT('local')
IF m.lnConn &gt; 0  &amp;&amp; Success.
* Set the active database to PUBS.
SQLEXEC(m.lnConn, 'use pubs')
* Execute SELECT statement.
SQLEXEC(m.lnConn, 'SELECT * FROM authors', 'PubAuthors')
BROWSE

* Execute INSERT statement, get value of identity field.
SQLEXEC(m.lnConn, "INSERT INTO JOBS (job_desc, min_lvl, max_lvl);
VALUES ('Developer',75,150)")
SQLEXEC(m.lnConn, "SELECT SCOPE_IDENTITY()", "job_id")
? "ID for added Job is " + LTRIM(STR(job_id.exp))
* Execute DELETE statement. Get number of records affected.
SQLEXEC(m.lnConn, "DELETE FROM JOBS WHERE job_desc ='Developer'")
SQLEXEC(m.lnConn, "SELECT @@ROWCOUNT", 'rowcount')
? rowcount.exp, "record(s) deleted"
* Call a stored procedure with no parameters.
SQLEXEC(m.lnConn, 'sp_who', 'activeusers')
BROWSE
* Execute stored procedure with an INPUT parameter.
SQLEXEC(m.lnConn, 'exec byroyalty ?lnPercent','HalfOffAuthors')

* Create temp stored procedure with OUTPUT parameter and call it.
SQLEXEC(m.lnConn, "CREATE PROCEDURE #MyProc @outparam int OUTPUT AS;
SELECT @outparam=100")
SQLEXEC(m.lnConn, "exec #myProc ?@lnOutput")
? m.lnOutput

* Create a temp stored procedure with INPUT and OUTPUT parameters
* and call it.
SQLEXEC(m.lnConn, "CREATE PROCEDURE #MyProc2 " + ;
"@inputparam INT, " + ;
"@outparam int OUTPUT " + ;
"AS SET @outparam=@inputparam*10")
SQLEXEC(m.lnConn, "exec #myProc2 ?lnPercent, ?@lnOutput")
? m.lnOutput
* Get version information.
SQLEXEC(m.lnConn, 'SELECT @@VERSION','SQLVersion1')
? STRTRAN(SQLVersion1.Exp,CHR(0))
* Disconnect.
SQLDISCONNECT(m.lnConn)
ELSE
? "Unable to connect to SQL Server"
ENDIF
RETURN</code>
</example>
</sqlexec>
<sqlgetprop>
<summary>
Retrieves the current or default settings for an active connection.
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by SQLCONNECT( ). If you specify 0 for nStatementHandle, SQLGETPROP( ) returns the environment setting.

</param>
<param name="cSetting">

Specifies the setting. For a list of the settings you can specify, see SQLSETPROP( ) Function.
</param>
<returns>
Character, Numeric, or Logical data type. SQLGETPROP( ) returns the current or default settings for an active connection. SQLGETPROP( ) returns -1 if a connection level occurs and -2 if an environment level error occurs.
</returns>
<example>
 <code language="X#">CLOSE ALL
CLEAR ALL
CLEAR
nHandle=SQLCONNECT()
IF nHandle &gt; 0
cSource= SQLGETPROP(nHandle, "datasource")
=MESSAGEBOX("Current Data Source = "+cSource,0,"Connection Results")
ELSE
=MESSAGEBOX("Connection Error = " + ;
ALLTRIM(STR(nHandle)),0,"Connection Results")
ENDIF
=SQLDISCONNECT(nHandle)</code>
</example>
</sqlgetprop>
<sqlidledisconnect>
<summary>
Allows a SQL pass-through connection or connections to be temporarily disconnected.
</summary>
<param name="nStatementHandle">

Specifies the statement handle of the connection to be temporarily disconnected.
Specify 0 for nStatementHandle to temporarily disconnect all active connections.
</param>
<returns>
Numeric. 
1 is returned if SQLIDLEDISCONNECT( ) successfully temporarily disconnects the SQL pass-through connection or connections.
-1 is returned if SQLIDLEDISCONNECT( ) was unable to temporarily disconnect the SQL pass-through connection or connections. 
</returns>
<remarks>
The function fails (returns -1) if the statement handle is busy or a connection is in manual commit mode. The AERROR( ) Function can be used to obtain information about the cause of the error.
A temporarily disconnected connection is automatically restored as soon as it is needed to perform an operation; the original connection string is used. The ODBC ODBChstmt property returns 0 if the statement handle is temporarily released and the ODBChdbc property returns 0 if the connection is temporarily disconnected. A shared connection is temporarily disconnected as soon as all its statement handles are temporarily disconnected (released).
</remarks>
</sqlidledisconnect>
<sqlmoreresults>
<summary>
Copies another result set to a X# cursor if more result sets are available.
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by SQLCONNECT( ).

</param>
<param name="cCursorName">

Specifies the name of the X# cursor to which the result set is sent. If you do not include a cursor name, X# uses the default name SQLRESULT.
For multiple result sets, new cursor names are derived by appending an incremented number to the name of the first cursor.

</param>
<param name="">

Specifies the name of the array to populate with row count information. If the array doesn’t exist, it is created. The array has two columns: 1 – Alias, 2 –Count.
0
Character
Indicates that SQL command did not return any results. Either no records were returned or the SQL command failed before results could be returned. (final <b>SQLMORERESULTS</b> call) or execution failed before any result could be processed. Can be only on the first row. Count column for the row contains value -1.
Non-empty uppercase string
Alias of the cursor – target for the record fetch operation. The Count column for the row contains the number of fetched records or -1 if fetch failed. If Count is -1, cursor may not have been created. During asynchronous execution, the fetch process for a cursor can be split between multiple SQLMORERESULTS or SQLEXEC calls; each call returns its own fetch count for the cursor.
Empty String
Indicates that the SQL command (INSERT, UPDATE, or DELETE) did not return a result set. 
Number of affected or fetched records.
Integer
Indicates the number of affected records as returned by the ODBC SQLRowCount function. 
Returns -1 if the number of records is unavailable.

</param>
<returns>
Numeric. SQLMORERESULTS( ) returns 0 if the SQL statement is still executing, returns 1 if it is finished executing, and returns 2 if no more data is found. In non-batch mode, SQLMORERESULTS( ) should be called after each successful SQLEXEC( ) call until SQLMORERESULTS( ) returns 2 (no more data found). The setting of the SQLSETPROP( ) batch mode option determines whether SQLEXEC( ) executes a SQL statement in batch or non-batch mode.
SQLMORERESULTS( ) returns – 1 if a connection level error occurs, and returns – 2 if an environment level error occurs.
</returns>
<remarks>
SQLMORERESULTS( ) determines if more result sets are available from a SQL statement executed with SQLEXEC( ) in non-batch mode. If more result sets are available, they are copied to a X# cursor, one set at a time.
SQLMORERESULTS( ) is one of the four functions that you can execute either synchronously or asynchronously. The asynchronous setting of SQLSETPROP( ) determines if these functions execute synchronously or asynchronously. In asynchronous mode, you must call SQLMORERESULTS( ) repeatedly until it returns a value other than 0 (still executing).
</remarks>
<example>
 <code language="X#">= SQLSETPROP(gnHandle, 'BatchMode', .F.)  &amp;&amp; Individual result sets
= SQLEXEC(gnHandle, 'SELECT * FROM authors;
SELECT * FROM titles')
= SQLMORERES(gnHandle)  &amp;&amp; First result set
= SQLMORERES(gnHandle)  &amp;&amp; Second result set</code>
</example>
</sqlmoreresults>
<sqlprepare>
<summary>
Prepares a SQL statement for remote execution by SQLEXEC( ).
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by SQLCONNECT( ).

</param>
<param name="cSQLCommand">

Specifies the SQL statement passed to the data source.
The SQL statement can contain a parameterized WHERE clause, which creates a parameterized view. All parameters in the WHERE clause must be defined before SQLPREPARE( ) is issued. For example, if the parameters are variables, the variables must be created and initialized before SQLPREPARE( ) is issued. For more information about parameterized views, see How to: Create Parameterized Views. 

</param>
<param name="cCursorName">

Specifies the name of the X# cursor to which the result set is sent. If you don't include a cursor name, X# uses the default name SQLRESULT.
For multiple result sets, new cursor names are derived by appending an incremented number to the name of the first cursor.
</param>
<returns>
Numeric
</returns>
<remarks>
SQLPREPARE( ) sends the SQL statement to the data source where it is compiled for faster execution. After the SQL statement is compiled, it can be executed with SQLEXEC( ). If SQLEXEC( ) is used to execute a SQL statement prepared with SQLPREPARE( ), only the statement handle is required in SQLEXEC( ).
</remarks>
<example>
 <code language="X#">gcAuthor = 'Smith'
= SQLPREPARE(gnHandle, 'SELECT * FROM authors;   WHERE au_lname = ?gcAuthor')
= SQLEXEC(gnHandle)
...
gcAuthor = 'Jones'
= SQLEXEC(gnHandle)</code>
</example>
</sqlprepare>
<sqlrollback>
<summary>
Cancels any changes made during the current transaction.
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by SQLCONNECT( ).
</param>
<returns>
Numeric. SQLROLLBACK( ) returns 1 if the transaction is successfully rolled back; otherwise, it returns -1. If SQLROLLBACK( ) returns -1, you can use AERROR( ) to determine why the transaction could not be rolled back.
</returns>
<remarks>
If manual transactions are in effect (the SQLSETPROP( ) transaction property is set to manual), you can send multiple updates to remote tables. The updates can all be rolled back with SQLROLLBACK( ).
Updates can be committed with SQLCOMMIT( ).
</remarks>
<example>
 <code language="X#">= SQLSETPROP(gnHandle, 'Transactions', 2)  &amp;&amp; manual
= SQLEXEC(gnHandle, "INSERT INTO authors (au_id, au_lname);
VALUES ('aupoe', 'Poe')")
= SQLROLLBACK(gnHandle)</code>
</example>
</sqlrollback>
<sqlsetprop>
<summary>
Specifies settings for an active connection. You can use SQLSETPROP( ) to specify settings at the connection level. To specify X# default settings at the environment level, include 0 as the statement handle. 
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by SQLCONNECT( ).

</param>
<param name="cSetting">

Specifies the setting. The following table lists the values for cSetting.
Asynchronous
Specifies whether result sets are returned synchronously (False (.F.), the default), or asynchronously (True (.T.)). Read/write.
BatchMode
Specifies whether SQLEXEC( ) returns result sets all at once (True (.T.), the default), or individually with SQLMORERESULTS( ) (False (.F.)).  Read/write.
ConnectBusy 
Contains True (.T.) if a shared connection is busy; otherwise contains False (.F.).  Read-only.
ConnectString
The login connection string.  Read-only.
ConnectTimeOut
Specifies the time to wait (in seconds) before returning a connection time-out error. If you specify 0, the wait is indefinite and a time-out error is never returned. ConnectTimeOut can be 0 to 600. The default is 15.  Read/write.
DataSource
The name of the data source as defined in the ODBC.INI file.  Read/write.
DisconnectRollback
Specifies if a pending transaction is committed or rolled back when SQLDISCONNECT( ) is called for the last connection handle.
The default is false (.F.), indicating that a pending transaction is committed when SQLDISCONNECT( ) is called for the last connection handle.
Specify true (.T.) to roll back a pending transaction when SQLDISCONNECT( ) is called for the last connection handle.
Connections with automatic transaction processing are not affected by this setting.
DispLogin
Contains a numeric value that determines when the ODBC Login dialog box is displayed. DispLogin may assume the following values:
1 or DB_PROMPTCOMPLETE (from FOXPRO.H).1 is the default.
2 or DB_PROMPTALWAYS (from FOXPRO.H).
3 or DB_PROMPTNEVER (from FOXPRO.H).
If 1 or DB_PROMPTCOMPLETE is specified, X# displays the ODBC Login dialog box only if any required information is missing.
If 2 or DB_PROMPTALWAYS is specified, the ODBC Login dialog box is always displayed, making it possible for you to change settings before connecting.
If 3 or DB_PROMPTNEVER is specified, the ODBC Login dialog box isn't displayed and X# generates an error if the required login information isn't available. Read/write.
DispWarnings
Specifies if error messages are displayed (True (.T.)) or are not displayed (False (.F.), the default).  Read/write.
IdleTimeout
The idle timeout interval in minutes. Active connections are deactivated after the specified time interval. The default value is 0 (wait indefinitely).  Read/write.
ODBChdbc
The internal ODBC connection handle, which may be used by external library files (FLL files) to call ODBC.  Read-only.
ODBChstmt
The internal ODBC statement handle, which may be used by external library files (FLL files) to call ODBC.  Read-only.
PacketSize
The size of the network packet used by the connection. Adjusting this value can improve performance. The default value is 4096 bytes (4K).  Read/write
Password
The connection password.  Read-only.
QueryTimeOut
Specifies the time to wait (in seconds) before returning a general time-out error. If you specify 0 (the default), the wait is indefinite and a time-out error is never returned. QueryTimeOut can be 0 to 600.  Read/write.
Shared
Specifies whether the underlying connection is a shared connection (True (.T.)), or not (False (.F.)). 
Transactions
Contains a numeric value that determines how the connection manages transactions on the remote table. Transactions may assume the following values:
1 or DB_TRANSAUTO (from FOXPRO.H).1 is the default. Transaction processing for the remote table is automatically handled.
2 or DB_TRANSMANUAL (from FOXPRO.H). Transaction processing is handled manually through SQLCOMMIT( ) and SQLROLLBACK( ). Read/write.
UserId
The user identification. Read-only.
WaitTime
The amount of time in milliseconds that elapses before X# checks if the SQL statement has completed executing. The default is 100 milliseconds.  Read/write.

</param>
<param name="eExpression">

Specifies the value for the setting you designate with cSetting. If you omit eExpression, the default value is restored for the setting.
</param>
<returns>
Numeric data type. SQLSETPROP( ) returns 1 if it is successful. Otherwise, it returns – 1 if a connection level error occurs or – 2 if an environment level error occurs.
</returns>
<remarks>
You can use SQLGETPROP( ) to return the current value for a specified setting.
You must disable the Open Database Connectivity (ODBC) login dialog box to support SQL pass through with Microsoft Transaction Server. To disable the ODBC login dialog box, use the statement codeSQLSETPROP(cStatementHandle, 'DispLogin', 3)/code, where cStatementHandle is the statement handle returned by <b>SQLCONNECT( )</b>. You can also disable the ODBC login dialog box in the Connection Designer.
The ConnectTimeOut option can be set only at the X# level and has no equivalent at the connection level. You can set all other options at either the connection or the X# level. Each option set at the X# level serves as a default value for subsequent connections.
</remarks>
<example>
 <code language="X#">CLOSE ALL
CLEAR ALL
CLEAR
nHandle=SQLCONNECT()
IF nHandle &gt; 0
nSet=SQLSETPROP(nHandle, "PacketSize", 2048 )
IF nSet &gt; 0
=MESSAGEBOX("PacketSize was set to 2048",0,"Connection Results")
ELSE
=MESSAGEBOX("Error setting PacketSize",0,"Connection Results")
ENDIF
ELSE
=MESSAGEBOX("No Connection",0,"Connection Results")
ENDIF
=SQLDISCONNECT(nHandle)</code>
</example>
</sqlsetprop>
<sqlstringconnect>
<summary>
Establishes a connection to a data source using a connection string.
</summary>
<param name="lShared">

Specifies whether to create a shared connection.
lShared
False (.F.)
<b>SQLSTRINGCONNECT( )</b> does not create a shared connection. (Default)
True (.T.)
<b>SQLSTRINGCONNECT( )</b> creates a shared connection.

</param>
<param name="cConnectString">

Specifies the data source connection string required by some Open Database Connectivity (ODBC) drivers. X# passes the connection string to the ODBC driver. For more information about data source connection strings, see your ODBC driver documentation.
You can also choose a data source from the Select Connection or Data Source Dialog Box, which appears when you call <b>SQLSTRINGCONNECT( )</b> without cConnectString. 

</param>
<param name="lSharable">

Specifies if the data source specified with cConnectString has a shared connection.
</param>
<returns>
Numeric data type. <b>SQLSTRINGCONNECT( )</b> returns a positive nonzero numeric value as the statement handle if you successfully connect to the data source. <b>SQLSTRINGCONNECT( )</b> returns –1 if it cannot make the connection.
You should store this statement handle in a memory variable and use the variable in subsequent function calls that require a connection handle.
</returns>
<remarks>
The <b>SQLCONNECT( )</b> and <b>SQLSTRINGCONNECT( )</b> functions return a numeric value as the statement handle rather than a connection handle. You cannot obtain a connection handle directly. You can still set and get connection properties using the <b>SQLSETPROP( )</b> and <b>SQLGETPROP( )</b> functions by passing the statement handle for that connection and the string, "Shared", as arguments. All other SQL functions use a statement handle instead of a connection handle.

<b>SQLSTRINGCONNECT( )</b> always creates a new connection when it successfully makes a connection. However, setting the lShared parameter determines whether you can share the connection later. If you specify a connection as shareable by setting lShared to True (.T.), you can share the connection later by calling <b>SQLCONNECT( )</b> and passing the numeric value of the connection handle as the first parameter. For more information, see SQLCONNECT( ) Function.
You can use <b>SQLCONNECT( )</b> to obtain a new statement handle on a shared connection that was opened using <b>SQLSTRINGCONNECT( )</b>.
</remarks>
<example>

<b>Example 1</b>

The following example assumes that an ODBC data source called MyFoxSQLNT exists and is available. <b>SQLSTRINGCONNECT( )</b> returns a numeric value, which is stored to a variable named codegnHandle/code.
If you successfully connect to the data source, <b>SQLSTRINGCONNECT( )</b> returns a positive number, a dialog box appears, and <b>SQLDISCONNECT( )</b> is called to disconnect from the data source.
If you cannot connect to the data source, <b>SQLSTRINGCONNECT( )</b> returns a negative number and displays a message.
 <code language="X#">STORE SQLSTRINGCONNECT('dsn=MyFoxSQLNT;uid=myUserID;pwd=myPassword')
TO gnConnHandle
IF gnConnHandle &lt; 0
= MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
ELSE
= MESSAGEBOX('Connection made', 48, 'SQL Connect Message')
= SQLDISCONNECT(gnHandle)
ENDIF</code>

<b>Example 2</b>

The following examples show how you can use the <b>SQLSTRINGCONNECT( )</b> function without a Data Source Name (DSN).
 <code language="X#">lcDSNLess="driver = SQL Server;server=&lt;servername&gt;;uid=&lt;userid&gt;;pwd=&lt;password&gt;"</code>
-or-
 <code language="X#">lcDSNLess="driver = {SQL Server};server=&lt;servername&gt;;uid=&lt;userid&gt;;pwd=&lt;password&gt;" </code>
-or-
 <code language="X#">lcDSNLess="DRIVER = {SQL Server};" ;
+ "SERVER=&lt;servername&gt;;" ;
+ "UID=&lt;userid&gt;;" ;
+ "PWD=&lt;password&gt;;" ;
+ "DATABASE=PUBS;" ;
+ "WSID=&lt;machine name or userid&gt;;" ;
+ "APP=MicroX(R) Sample App"
lnConnHandle=SQLSTRINGCONNECT(m.lcDSNLess)</code>

<b>Example 3</b>

Each of the following examples creates a new shared connection. In the first statement, the Select Connection or Data Source Dialog Box appears and <b>SQLSTRINGCONNECT( )</b> creates the resulting connection as shared.
 <code language="X#">SQLSTRINGCONNECT(.T.)
SQLSTRINGCONNECT('myConnectionString', .T.)</code>
</example>
</sqlstringconnect>
<sqltables>
<summary>
Stores the names of tables in a data source to a X# cursor.
</summary>
<param name="nStatementHandle">

Specifies the statement handle to the data source returned by SQLCONNECT( ).

</param>
<param name="cTableTypes">

Specifies one or more table types. Valid table types are 'TABLE,' 'VIEW,' 'SYSTEM TABLE,' or any valid data source-specific table type identifier. If you include a list of table types, separate the table types with commas.
All table names in the data source are selected if you omit cTableTypes or if cTableTypes is the empty string.   
The table type you specify must be delimited with single quotation marks. The following example demonstrates how to specify the 'VIEW' and 'SYSTEM TABLE' table types as a string literal.   
 <code language="X#">? SQLTABLES(handle, "'VIEW', 'SYSTEM TABLE'", "mydbresult")</code>

</param>
<param name="cCursorName">

Specifies the name of the X# cursor to which the result set is sent. If you don't include a cursor name, X# uses the default name SQLRESULT. The structure of the results depends on the internal SQLTABLES( ) function for the ODBC Handle.
</param>
<returns>
Numeric. SQLTABLES( ) returns 1 if the cursor is successfully created, 0 if SQLTABLES( ) is still executing, – 1 if a connection level error occurs, and – 2 if an environment level error occurs.
</returns>
<remarks>
SQLTABLES( ) is one of the four functions that you can execute either synchronously or asynchronously. The setting of the SQLSETPROP( ) asynchronous option determines if these functions execute synchronously or asynchronously. In asynchronous mode, you must call SQLTABLES( ) repeatedly until it returns a value other than False (.F.), meaning the function is still executing.
</remarks>
<example>
 <code language="X#">STORE SQLCONNECT('MyFoxSQLNT', '&lt;userid&gt;', '&lt;password&gt;') TO gnConnHandle
IF gnConnHandle &lt; 0
= MESSAGEBOX('Cannot make connection', 16, 'SQL Connect Error')
ELSE
= MESSAGEBOX('Connection made', 48, 'SQL Connect Message')
STORE SQLTABLES(gnConnHandle, 'TABLE', 'mycursor') TO nTables
IF nTables = 1
SELECT mycursor
LIST
ENDIF
ENDIF</code>
</example>
</sqltables>
<sqrt>
<summary>
Returns the square root of the specified numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression SQRT( ) evaluates. nExpression cannot be negative.
</param>
<returns>
Numeric
</returns>
<remarks>
The number of decimal places in the value returned by SQRT( ) is the larger of the current decimal place setting and the number of decimal places contained in nExpression. The current decimal place setting is specified with SET DECIMALS.
</remarks>
<example>
 <code language="X#">CLEAR
? SQRT(4)  &amp;&amp; Displays 2.00
? SQRT(2*SQRT(2))  &amp;&amp; Displays 1.68</code>
</example>
</sqrt>
<srows>
<summary>
Returns the number of rows available in the main X# window.
</summary>
<returns>
SROWS( )Return Value
Numeric
</returns>
<remarks>
In X# for Windows, the value returned by SROWS( ) depends on the current display mode. The display mode can be changed with SET DISPLAY.
</remarks>
<example>
 <code language="X#">CLEAR
? SROWS( )</code>
</example>
</srows>
<str>
<summary>
Returns the character equivalent of a numeric expression.
</summary>
<param name="nExpression">

Specifies the numeric expression to evaluate.

</param>
<param name="nLength">

Specifies the length of the character string returned. If nLength is omitted, nLength defaults to 10 characters. 
If the expression contains a decimal point, the length includes one character for the decimal point and one character for each digit in the character string.

</param>
<param name="nDecimalPlaces">

Specifies the number of decimal places in the character string returned. To specify the number of decimal places using nDecimalPlaces, you must include nLength. If nDecimalPlaces is omitted, the number of decimal places defaults to zero (0). 
X# contains a limit of 16 digits of precision in numeric calculations. For more information about numeric precision in X#, see X# System Capacities.
</param>
<returns>
Character data type. <b>STR( )</b> returns a character string equivalent to the specified numeric expression.
Depending on certain conditions, <b>STR( )</b> can return the following:
If you specify fewer decimal places than exist in nExpression, the return value is rounded up. To round results to the nearest decimal place instead of upward, include the <b>ROUND( )</b> function. For more information, see ROUND( ) Function.
If nExpression is an integer, and nLength is less than the number of digits in nExpression, <b>STR( )</b> returns a string of asterisks, indicating numeric overflow.
If nExpression contains a decimal point, and nLength is equal to or less than the number of digits to the left of the decimal point, <b>STR( )</b> returns a string of asterisks, indicating numeric overflow.
If nLength is greater than the length of the value evaluated by nExpression, <b>STR( )</b> returns a character string padded with leading spaces.
If nExpression has <b>Numeric</b> or <b>Float</b> type, and nLength is less than the number of digits in nExpression, and , <b>STR( )</b> returns a value using scientific notation.
In the following example, <b>STR( )</b> evaluates 1.154994 as a character expression, specifies a length of 8 characters and the same number of decimal places that the specified expression contains, and displays 1.154994 using the <b>?</b> command.
 <code language="X#">? STR(1.154995,8,6)</code>
In the following example, <b>STR( )</b> evaluates 1.154994 as a character expression and specifies a length of 8 characters and 2 decimal places, four fewer decimal places than the specified expression contains. <b>STR( )</b> displays 1.16 using the <b>?</b> command, which represents 1.154994 rounded upward.
 <code language="X#">? STR(1.154995,8,2)</code>
In the following example, <b>STR( )</b> includes the <b>ROUND( )</b> function, evaluates 1.154994 as a character expression, and specifies a length of 8 characters 2 decimal places, four fewer decimal places than the specified expression contains. <b>STR( )</b> displays 1.15 using the <b>?</b> command, which represents 1.154994, rounded to the nearest significant digit.
 <code language="X#">? STR(ROUND(1.154995,2),8,2)</code>
</returns>
</str>
<strconv>
<summary>
Converts character expressions between single-byte, double-byte, UNICODE, and locale-specific representations.
</summary>
<param name="cExpression">

Specifies the character expression that STRCONV( ) converts.

</param>
<param name="nConversionSetting">

Specifies the type of conversion. The following table lists the values of nConversionSetting and the type of conversion performed.
1
Converts single-byte characters in cExpression to double-byte characters.
Supported for Locale ID only (specified with the nRegionalIdentifier or nRegionalIDType parameters).
2
Converts double-byte characters in cExpression to single-byte characters. 
3
Converts double-byte Katakana characters in cExpression to double-byte Hiragana characters. 
4
Converts double-byte Hiragana characters in cExpression to double-byte Katakana characters. 
5
Converts double-byte characters to UNICODE (wide characters).
6
Converts UNICODE (wide characters) to double-byte characters.
7
Converts cExpression to locale-specific lowercase. 
8
Converts cExpression to locale-specific uppercase. 
9
Converts double-byte characters in cExpression to UTF-8
10
Converts Unicode characters in cExpression to UTF-8
11
Converts UTF-8 characters in cExpression to double-byte characters.
12
Converts UTF-8 characters in cExpression to UNICODE characters.
13
Converts single-byte characters in cExpression to encoded base64 binary.
14
Converts base64 encoded data in cExpression to original unencoded data.
15
Converts single-byte characters in cExpression to encoded hexBinary.
16
Converts single-byte characters in cExpression to decoded hexBinary.

</param>
<param name="nRegionalIdentifier">

Specifies the Locale ID, code page, or FontCharSet value to use for the conversion. If nRegionalIDType is omitted, the Locale ID is used for the conversion. If nRegionalIdentifier is omitted, the system locale ID is used by default.
If nRegionalIdentifier is invalid or not supported on the machine, the error "Invalid locale ID" is generated.
1029
Czech
1031
German
1033
English (Default)
1034
Spanish
1036
French
1040
Italian
1045
Polish
1046
Portuguese (Brazil)
2070
Portuguese (Portugal)

</param>
<param name="nRegionalIDType">

Specifies if a Locale ID, code page, or FontCharSet is used for the conversion. 
The nRegionalIdentifier parameter, described above, is used to specify the actual Locale ID, code page, or FontCharSet used for the conversion.
nRegionalIDType
0
(Default) Specifies that the nRegionalIdentifier parameter is a Locale ID value.
1
Specifies that nRegionalIdentifier is a code page value.
2
Specifies that nRegionalIdentifier is a FontCharSet value.

</param>
<returns>
Character data type. STRCONV( ) returns the converted character expression.
</returns>
<remarks>
X# disregards invalid characters or incorrect length in base 64- and hexBinary- encoded strings.
This function is useful for manipulating double-byte character sets for languages such as Hiragana and Katakana.
</remarks>
</strconv>
<strextract>
<summary>
Retrieves a string between two delimiters. 
</summary>
<param name="cSearchExpression">

Specifies the string to search.

</param>
<param name="cBeginDelim">

Specifies the character that delimits the beginning of cSearchExpression.

</param>
<param name="cEndDelim">

Specifies the character that delimits the end of cSearchExpression.

</param>
<param name="nOccurrence">

Specifies at which occurrence of cBeginDelim in cSearchExpression to start the extraction.

</param>
<param name="nFlag">

Specify the type of controls placed on the search. The number you specify in nFlag provides a bit-value that determines options according to the following table:
0
1
Case-insensitive search
2
End delimiter not required. Specifies that a search, which finds no occurrence of cEndDelim, returns the contents of cSearchExpression from the cBeginDelim location.
4
Include the delimiters in the returned expression.
Character or Varbinary.br
The Result data type is derived by the first parameter data type.
</param>
<remarks>
The default is a case sensitive search in which delimiters must be found (no nFlag value).
If cBeginDelim is an empty string, the search is conducted from the beginning of cSearchExpression to the first occurrence of cEndDelim. If cEndDelim is an empty string STREXTRACT( ) returns a string from nOccurrence of cBeginDelim to the end of cSearchExpression.
</remarks>
<example>
 <code language="X#">CLEAR
SET PATH TO (HOME(2) + 'Data\')   &amp;&amp;Set path to the customer table
USE customer &amp;&amp; any table
?cursortoxml(0,"x",1,0,2)   &amp;&amp; Produce variable "x" that has XML of  first 2 records of table
?x         &amp;&amp; show the XML
xmlproc(x,0)      &amp;&amp; Parse the XML
PROCEDURE xmlproc(x as String, nLev as Integer)   as void
LOCAL cTagName, cContents, mterm
DO WHILE .t.
cTagName = STREXTRACT(x,"&lt;","&gt;")
IF LEN(cTagName) = 0   &amp;&amp; no tag found
??' ',x   &amp;&amp; print out raw string as contents
EXIT
ENDIF
IF RIGHT(cTagName,1) = '/'   &amp;&amp; like "&lt;region/&gt;"
cTagName = LEFT(cTagName, LEN(cTagName)-1)
cContents=""
mterm = "&lt;"+cTagName+"/&gt;"   &amp;&amp; "&lt;region/&gt;"
ELSE
mterm = "&lt;/"+cTagName+"&gt;"   &amp;&amp; "&lt;/region&gt;"
cContents = STREXTRACT(x,"&lt;"+cTagName+"&gt;", mterm,1,2)
ENDIF
?REPLICATE("  ",nLev),nLev+1,PADR(cTagName,20)
xmlproc(cContents, nLev+1)
x = STREXTRACT(x, mterm)   &amp;&amp; get the rest of the xml
ENDDO</code>
</example>
</strextract>
<strtofile>
<summary>
Writes the contents of a character string to a file.
STRTOFILE( ) does not write to hidden files when running X# on Windows 2000 and later.
</summary>
<param name="cExpression">

Specifies the character string that is written to the file. cExpression can be a literal character string, an expression that evaluates to a character string, or a character type variable, array element, or field.

</param>
<param name="cFileName">

Specifies the name of the file to which the character string is written. Include a path with the file name if the file is in a directory other than the current default directory. If the file you specify does not exist, X# automatically creates it.

lAdditive (for backward compatibility) 
Specifies whether the character string is appended to the end of the file. If lAdditive is true (.T.), the character string is appended to the end of the file.
If lAdditive is false (.F.) (the default), the file is overwritten with the character string. You are asked if you want to overwrite an existing file if SET SAFETY is set to ON. If SET SAFETY is set to OFF, the file is overwritten without warning.
</param>
<param name="nFlag">

Beginning with X# 7, you can use the nFlag parameter instead of lAdditive which enables you to also chose to write UTF-8 and Unicode Byte Order Marks. The following table describes the valid nFlag values.
0 (default)
0000
The file is overwritten with the character string (formerly lAdditive=.f.)
1
0001
The string is appended to the end of the file (formerly lAdditive=.t.).
2
0010
Write Unicode Byte Order Mark (BOM) FF FE at the beginning of file. cExpression is assumed to be UNICODE, therefore no translation is performed. The file is overwritten
4
0100
Write UTF-8 Byte Order Mark (BOM) EF BB BF at the beginning of file. cExpression is assumed to be UTF-8, therefore no translation is performed. The file is overwritten.
</param>
<returns>
Numeric; the number of bytes written to the file.
</returns>
<remarks>
An nFlag value of 3 or 5 is not valid. You cannot attempt to write a new Byte Order Mark if nFlag bit 1, Additive, is set.
Unlike earlier versions of X#, STRTOFILE( ) opens a file in Shared rather than Exclusive mode. This is useful when multiple servers attempt to simultaneously write to the same file. Because of this change, you might not need to check for STRTOFILE( ) to return 0 (failure to open a file). 
</remarks>
</strtofile>
<strtran>
<summary>
Searches a character expression or memo field for a second character expression or memo field and replaces each occurrence with a third character expression or memo field. You can specify where the replacement begins and how many replacements are made. 
</summary>
<param name="cSearched">

Specifies the character expression to search. cSearched can be a memo field, a blob field, or a varbinary expression.

</param>
<param name="cExpressionSought">

Specifies the character expression to search for in cSearched. The search is case-sensitive. cExpressionSought can be a memo field, a blob field, or a varbinary expression.
cReplacement
Specifies the character expression to replace every occurrence of cExpressionSought in cSearched. Omitting cReplacement replaces every occurrence of cExpressionSought with an empty string. cReplacement can also be a memo field, a blob field, or a varbinary expression.
nStartOccurrence
Specifies which occurrence of cExpressionSought to replace first. 
For example, if nStartOccurrence is 4, replacement begins with the fourth occurrence of cExpressionSought in cSearched and the first three occurrences of cExpressionSought remain unchanged. Omitting nStartOccurrence defaults the occurrence where replacement begins to the first occurrence of cExpressionSought. 
nNumberOfOccurrences
Specifies the number of occurrences of cExpressionSought to replace. Omitting nNumberOfOccurrences replaces all occurrences of cExpressionSought, starting with the occurrence specified with nStartOccurrence.
If you need to specify only the nFlags setting along with the required parameters, specify empty string for the cReplacement and –1 for the optional numeric parameters you want disregarded.
nFlags
Specifies the case-sensitivity of a search according to the following values.
The following table lists the values for nFlags:
</param>
<param name="nFlags">
0
Search is case-sensitive and replacement is performed with exact cReplacement text. (Default)
This setting specifies the original behavior for <b>STRTRAN( )</b> in versions prior to X# 7.0.br
You can also specify default behavior by passing –1 as the nFlags value.
&amp;nbsp;
Search is case-insensitive and replacement is performed with exact cReplacement text. 
2
Search is case-sensitive and replacement is performed with the case of cReplacement changed to match the case of the string found. 
3
Search is case-insensitive and replacement is performed with the case of cReplacement changed to match the case of the string found. 
The case of cReplacement changes only if the string found is all uppercase, lowercase, or proper case.
</param>
<returns>
Character or Varbinary.br
<b>STRTRAN( )</b> returns the resulting character or varbinary string. The Result data type is derived by the first parameter data type.
</returns>
<example>
 
<code language="X#">STORE 'abracadabra' TO gcString
? STRTRAN(gcString, 'a', 'z')
? STRTRAN(gcString, 'a', 'q', 2, 3)</code>
 
<code language="X#">? STRTRAN(gcString, 0h61, 0h7A)
? STRTRAN(0h + gcString, 'a', 0h7A)         &amp;&amp; This command shows parameters data type variability and returns varbinary string
? STRTRAN(0h1234567890, 0h5678, 0h876543)   &amp;&amp; Returns 0h123487654390</code>
</example>
</strtran>
<stuff>
<summary>
Returns a character string created by replacing a specified number of characters in a character expression with another character expression.
</summary>
<param name="cExpression">

Specify the character expression in which the replacement occurs.

</param>
<param name="nStartReplacement">

Specifies the position in cExpression where the replacement begins.

</param>
<param name="nCharactersReplaced">

Specifies the number of characters to be replaced. If nCharactersReplaced is 0, the replacement string cReplacement is inserted into cExpression.

</param>
<param name="cReplacement">

Specifies the replacement character expression. If cReplacement is the empty string, the number of characters specified by nCharactersReplaced are removed from cExpression.
</param>
<returns>
Character
</returns>
<example>
 <code language="X#">STORE 'abcdefghijklm' TO gcString1
STORE '12345' TO gcString2
CLEAR
? STUFF(gcString1, 4, 0, gcString2)     &amp;&amp; insert
? STUFF(gcString1, 4, 3, gcString2)     &amp;&amp; replace
? STUFF(gcString1, 4, 6, '')     &amp;&amp; delete
? STUFF(gcString1, 4, 1, gcString2)     &amp;&amp; replace and insert
? STUFF(gcString1, 4, 4, gcString2)     &amp;&amp; replace and delete
? STUFF(gcString1, 4, LEN(gcString1), gcString2)   &amp;&amp; replace, delete rest</code>
</example>
</stuff>
<substr>
<summary>
Returns a character string from the given character expression or memo field, starting at a specified position in the character expression or memo field and continuing for a specified number of characters.
</summary>
<param name="cExpression">

Specifies the character expression or memo field from which the character string is returned.

</param>
<param name="nStartPosition">

Specifies the position in the character expression or memo field cExpression from where the character string is returned. The first character of cExpression is position 1.
If nStartPosition is greater than the number of characters in cExpression, <b>SUBSTR( )</b><b> </b>returns an empty string ("").

</param>
<param name="nCharactersReturned">

Specifies the number of characters to return from cExpression. If you omit nCharactersReturned, characters are returned until the end of the character expression is reached.
</param>
<returns>
Character. <b>SUBSTR( )</b> returns a character string.
<b>SUBSTR( )</b> will not return a value for a memo field when issued in the Debug window. To return a value in the Debug window, place the memo field name within <b>ALLTRIM( )</b>, and place <b>ALLTRIM( )</b> within <b>SUBSTR( )</b>.
</returns>
<remarks>
When using <b>SUBSTR( )</b> with memo fields in a SQL <b>SELECT</b> command, include the <b>PADR( )</b> function in <b>SUBSTR( )</b> so that empty or variable length memo fields produce consistent results when converted to character strings.
</remarks>
<example>
 <code language="X#">STORE 'abcdefghijklm' TO myString
CLEAR
? SUBSTR(myString, 1, 5)
? SUBSTR(myString, 6)  </code>
</example>
</substr>
  <sys>
    <summary>
      Returns system information or sets its behavior.
    </summary>
    <param name="nSetting">Number of setting to query or change</param>
    <param name="uNewValue">Optional new value for setting</param>
  </sys>
<sysmetric>
<summary>
Returns the size of the operating system's screen elements.
</summary>
<param name="nScreenElement">

Specifies a screen element. The following table shows values for nScreenElement and the corresponding screen element:
1
Screen width
2
Screen height.
3
Width of sizable window frame
4
Height of sizable window frame
5
Width of scroll arrows on vertical scroll bar
6
Height of scroll arrows on vertical scroll bar
7
Width of scroll arrows on horizontal scroll bar
8
Height of scroll arrows on horizontal scroll bar
9
Height of window title
10
Width of non-sizable window frame
11
Height of non-sizable window frame
12
Width of DOUBLE or PANEL window frame
13
Height of DOUBLE or PANEL window frame
14
Scroll box width on horizontal scroll bar in text editing windows
15
Scroll box height on vertical scroll bar in text editing windows
16
Minimized window icon width
17
Minimized window icon height
18
Maximum insertion point width
19
Maximum insertion point height
20
Single-line menu bar height
21
Maximized window width
22
Maximized window height
23
Kanji window height 
24
Minimum sizable window width
25
Minimum sizable window height
26
Minimum window width
27
Minimum window height
28
Window controls width
29
Window controls height
30
1 if mouse hardware present; otherwise 0
31
1 for Microsoft Windows debugging version; otherwise 0
32
1 if mouse buttons swapped; otherwise 0
33
Width of a button in a half-caption window's caption or title bar
34
Height of half-caption window caption area
</param>
<returns>
Character
</returns>
<remarks>
SYSMETRIC( ) returns the size of screen elements. Screen elements include menus, windows, window controls, and the insertion point. Values are returned in pixels unless otherwise noted and can vary for different displays, display drivers, and video hardware. For further information on screen elements, refer to the GetSystemMetrics function in the MSDN Library at <b>http://msdn.microsoft.com/library</b>.
SYSMETRIC( ) enables you to determine the size of menus, windows, and window controls you create in X#. Windows and menus created with DEFINE WINDOW and DEFINE MENU use the same screen element sizes as the operating system's windows and menus.
</remarks>
</sysmetric>
<tablerevert>
<summary>
Discards changes made to a buffered row or a buffered table or cursor and restores the OLDVAL( ) data for remote cursors and the current disk values for local tables and cursors.
On a network, the data currently on disk might differ from the data on the disk when the table was opened or the cursor was created. Other users on the network might have changed the data after the table was opened or the cursor was created.
</summary>
<param name="lAllRows">

Determines whether all changes made to the table or cursor are discarded. The following table describes the values for lAllRows.
False (.F.)
If table buffering is enabled, only changes made to the current record in the table or cursor are discarded. (Default)
True (.T.)
If table buffering is enabled, changes made to all records are discarded in the table or cursor.
If row buffering is enabled, X# disregards the value of lAllRows, and changes made to the current record in the table or cursor are discarded. 

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor in which the changes are discarded.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor in which the changes are discarded.
</param>
<returns>
Numeric data type. TABLEREVERT( ) returns the number of records for which changes were discarded.
</returns>
<remarks>
TABLEREVERT( ) cannot discard changes made to a table or cursor that does not have row or table buffering enabled. If you issue TABLEREVERT( ) and row or table buffering is not enabled, X# generates an error message. Use CURSORSETPROP( ) to enable or disable row and table buffering.
Changes are discarded in the table or cursor open in the currently selected work area if TABLEREVERT( ) is issued without the optional cTableAlias or nWorkArea arguments.
TABLEREVERT( ) does not return the record pointer to its original position.
TABLEREVERT( ) operates on CursorAdapter objects in the same way as other buffered cursors.
In X# 9.0, you cannot issue the TABLEREVERT( ) function when a TABLEUPDATE( ) is in operation.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
SET MULTILOCKS ON  &amp;&amp; Must be on for table buffering
SET PATH TO (HOME(2) + 'data\')     &amp;&amp; Sets path to database
OPEN DATABASE testdata  &amp;&amp; Open testdata database
USE Customer     &amp;&amp; Open customer table
= CURSORSETPROP('Buffering', 5, 'customer')  &amp;&amp; Enable table buffering
CLEAR
? 'Original cust_id value: '
?? cust_id  &amp;&amp; Displays current cust_id value
REPLACE cust_id    WITH '***'  &amp;&amp; Changes field contents
? 'New cust_id value: '
?? cust_id  &amp;&amp; Displays new cust_id value
= TABLEREVERT(.T.)  &amp;&amp; Discard all table changes
? 'Reverted cust_id value: '
?? cust_id  &amp;&amp; Displays reverted cust_id value</code>
</example>
</tablerevert>
<tableupdate>
<summary>
Commits changes made to a buffered row, a buffered table, cursor, or cursor adapter.
</summary>
<param name="nRows">

Specifies which changes made to the table or cursor should be committed. 
X# enables Optimistic Row Buffering by default for those cursors associated with a <b>CursorAdapter</b> object.
The following table describes the values for nRows.   
0 
If row or table buffering is enabled, commit only the changes made to the current row in the cursor. (Default)
When working with <b>CursorAdapter</b> objects, X# executes the appropriate command in the InsertCmd, UpdateCmd, or DeleteCmd property for that row only.
1 
If table buffering is enabled, commit changes made to all records to the table or cursor. 
If row buffering is enabled, commit only changes made to the current record in the table or cursor.
When working with <b>CursorAdapter</b> objects, X# executes the appropriate commands in the <b>InsertCmd</b>, <b>UpdateCmd</b>, and <b>DeleteCmd</b> properties for each affected row.
Commit changes made to the table or cursor in the same manner as when nRows = 1. However, an error does not occur when a change cannot be committed. X# continues to process any remaining records in the table or cursor. 
If cErrorArray is included, an array containing error information is created when an error occurs.
For compatibility with previous X# applications, the nRows parameter also accepts False (.F.) and True (.T.) instead of 0 and 1 respectively.
When specifying 0 or 1 for nRows, the record pointer remains on the record where changes could not be committed. To determine why the changes could not be committed, use the AERROR( ) function.   
When working with <b>CursorAdapter</b> objects and specifying 1 or 2 for nRows, all changes made to the cursor in the following <b>CursorAdapter</b> events must be committed during the same call to <b>TABLEUPDATE( )</b> unless an error occurs:
<b>BeforeInsert</b>

<b>AfterInsert</b>
<b>BeforeDelete</b>
<b>AfterDelete</b>
<b>BeforeUpdate</b>
<b>AfterUpdate</b>
X# passes the values of nRows to the <b>CursorAdapter</b> BeforeCursorUpdate event.  

</param>
<param name="lForce">

Determines whether X# overwrites changes made to the table or cursor by another user on a network. 
The following table describes the values for lForce.   
False (.F.)
Commits changes to the table or cursor, starting with the first record and continuing towards the end of the table or cursor. (Default)
True (.T.)
Overwrites any changes made to the table or cursor by another user on a network. The <b>WHERE</b> clause uses only key fields.
When working with <b>CursorAdapter</b> objects, X# passes the value of lForce to the following <b>CursorAdapter</b> events:   
BeforeCursorUpdate

BeforeInsert
BeforeUpdate
BeforeDelete
AfterInsert
AfterUpdate
AfterDelete

</param>
<param name="cTableAlias">

Specifies the alias of the table or cursor in which the changes are committed. If you include a table or cursor alias, you must include the lForce argument.

</param>
<param name="nWorkArea">

Specifies the work area of the table or cursor in which the changes are committed. If you include a work area, you must include the lForce argument.

</param>
<param name="cErrorArray">

Specifies the name of an array created when nRows = 2 and changes to a record cannot be committed. The array contains a single column containing the record numbers of the records for which changes could not be committed. If you include an array name, you must include either a table or cursor alias cTableAlias or a work area number nWorkArea.
If an error other than a simple commit error occurs while updating records, the first element of cErrorArray will contain –1, and you can then use <b>AERROR( )</b> to determine the why the changes could not be committed.
X# passes the value of cErrorArray, when it exists, to the <b>CursorAdapter</b> AfterCursorUpdate event.
</param>
<returns>
Logical data type. <b>TABLEUPDATE( )</b> returns True (.T.) if changes to all records are committed.
Otherwise, <b>TABLEUPDATE( )</b> returns False (.F.) indicating a failure. An ON ERROR routine isn't executed. The AERROR( ) function can be used to retrieve information about the cause of the failure.
<b>TABLEUPDATE( )</b> always returns True (.T.) when you are updating data, using Table Buffering, and updating the table or tables in the data source from multiple clients when setting <b>BatchUpdateCount</b> to a value greater than 1. Therefore, avoid setting <b>BatchUpdateCount</b> to a value greater than 1 in these scenarios.
</returns>
<remarks>

<b>TABLEUPDATE( )</b> cannot commit changes made to a table or cursor that does not have row or table buffering enabled. If you issue <b>TABLEUPDATE( )</b> and row or table buffering is not enabled, X# generates an error message. However, <b>TABLEUPDATE( )</b> can still commit changes to a table or cursor that has validation rules. To enable or disable row and table buffering, use <b>CURSORSETPROP( )</b>.
Changes are committed to the table or cursor open in the currently selected work area if <b>TABLEUPDATE( )</b> is issued without the optional cTableAlias or nWorkArea arguments.
If table buffering is used and multiple records are updated, <b>TABLEUPDATE( )</b> moves the record pointer to the last record updated.
Calling <b>TABLEUPDATE( )</b> for a local table or view that does not use key fields generates a long <b>WHERE</b> clause to find the update row. The default number of fields supported in the <b>WHERE</b> clause is 40. If you receive the error SQL: Statement too long (Error 1812), you should either use a key field for the update or increase the complexity of the <b>WHERE</b> clause with SYS(3055). If you use the <b>SYS(3055)</b> function, increase its value to a number that is eight times the number of fields in the table as shown in the following example:
 <code language="X#">SYS(3055, 8 * MIN(40, FCOUNT( ))</code>
When performing a batched <b>TABLEUPDATE( )</b> operation, due to the way that Open Database Connectivity (ODBC) behaves, X# is unable to detect conflicts when no error is generated by the server, yet nothing is updated, for example, no row matches the <b>WHERE</b> clause. This can occur when you use WhereType set to DB_KEYANDUPDATABLE, DB_KEYANDMODIFIED, or DB_KEYANDTIMESTAMP, and another user has changed one of the underlying values in the <b>WHERE</b> clause such that the row is not found by the update statement.

<b>Interaction with CursorAdapter Objects</b>   The following behaviors apply when working with <b>CursorAdapter</b> objects:  

<b>TABLEUPDATE( )</b> operates only on the cursor associated with the <b>CursorAdapter</b> object.

<b>TABLEUPDATE( )</b> executes commands according to the data source type and those stored in the <b>CursorAdapter</b> <b>InsertCmd</b>, <b>UpdateCmd</b>, or <b>DeleteCmd</b> properties against the current cursor row or rows as appropriate. 

<b>TABLEUPDATE( )</b> passes the value of codeGETFLDSTATE(1)/code to the following <b>CursorAdapter</b> events of each row affected: 

BeforeInsert


BeforeUpdate


BeforeDelete

For more information about <b>GETFLDSTATE( )</b>, see GETFLDSTATE( ) Function.
The successful completion of <b>TABLEUPDATE( )</b> resets the field states according to usual <b>TABLEUPDATE( )</b><b> </b>behavior.
When table buffering is enabled, you can move away from the current record in the following <b>CursorAdapter</b> events:

BeforeInsert


AfterInsert


BeforeUpdate


AfterUpdate


BeforeDelete


AfterDelete

You can also modify data in the cursor. This functionality supports scenarios such as retrieving the autoincrement value from the base table and inserting it into the cursor. When this scenario occurs, the <b>CursorAdapter</b> object should automatically return to the record whose changes are about to be committed after the event has occurred and commit the changes.
In X# 9.0, you cannot issue the TABLEREVERT( ) Function when a TABLEUPDATE( ) is in operation.
Typically, the CursorAdapter object uses the transaction management functionality provided by the ADO or ODBC API's and X# closes transactions when the TABLEUPDATE( ) function completes successfully. However, if you want to send transaction management commands directly to the backend, you can set the UseTransactions property of the CursorAdaptor object to False (.F.) and the CursorAdapter does not use transactions to send Insert, Update, or Delete commands.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
CREATE TABLE employee (cLastName C(10))
SET MULTILOCKS ON  &amp;&amp; Must turn on for table buffering.
= CURSORSETPROP('Buffering', 5, 'employee' )  &amp;&amp; Enable table buffering.
INSERT INTO employee (cLastName) VALUES ('Smith')
CLEAR
? 'Original cLastName value: '
?? cLastName  &amp;&amp; Displays current cLastName value (Smith).
REPLACE cLastName WITH 'Jones'
? 'New cLastName value: '
?? cLastName  &amp;&amp; Displays new cLastName value (Jones).
= TABLEUPDATE(.T.)  &amp;&amp; Commits changes.
? 'Updated cLastName value: '
?? cLastName  &amp;&amp; Displays current cLastName value (Jones).</code>
</example>
</tableupdate>
<tag>
<summary>
Returns a tag name from an open compound index (.cdx) file or the name of an open single-entry (.idx) index file.
</summary>
<param name="CDXFileName">

Specifies the name of the .cdx file to return a tag name from.

</param>
<param name="nTagNumber">

Specifies a number corresponding to the order in which a tag was created in the compound index file. 
For example, if nTagNumber is 1, <b>TAG( )</b> returns the name of the first tag created in the compound index file. If nTagNumber is 2, <b>TAG( )</b> returns the name of the second tag created, and so on. TAG( ) returns the empty string when nTagNumber exceeds the number of tag names.   
If you omit CDXFileName, <b>TAG( )</b> returns compound index file tag names and single-entry index file names in a specific order as follows:   
Names of single-entry index files are returned based on their order in the <b>INDEX</b> clause of <b>USE</b> or <b>SET INDEX</b>. For more information, see USE Command and SET INDEX Command.
Tag names from the structural compound index file (if one exists for the table) are returned.
Tag names from other open compound index files are returned, again in the order in which the tags were created in the compound index files and in the order in which the compound index files are specified in the <b>INDEX</b> clause for <b>USE</b> or <b>SET INDEX</b>.

nWorkArea| cTableAlias
Returns tag names and index file names from files open in another work area. nWorkArea specifies a work area number and cTableAlias specifies a table alias. By default, tag names and index file names are returned from files in the current work area.
</param>
<returns>
Character. <b>TAG( )</b> returns an index tag name as an uppercase character string.
</returns>
<remarks>
Tags are index entries in compound index (.cdx) files created with the <b>INDEX</b> command. Single-entry index (.idx) files contain only one entry; therefore, <b>TAG( )</b> returns the file name for .idx files.
A structural compound index (.cdx) file opens with its table automatically. You can open non-structural .cdx files and .idx index files for a table using the <b>INDEX</b> clause in the <b>USE</b> command or using the <b>SET INDEX</b> command.
</remarks>
<example>

<code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\TestData')
USE Customer
CLEAR
FOR nCount = 1 TO TAGCOUNT()
? TAG(CDX(1),nCount)
ENDFOR</code>
</example>
</tag>
<tagcount>
<summary>
Returns the number of .cdx compound index file tags and open .idx single-entry index files.
</summary>
<param name="CDXFileName">

Specifies the name of a compound index file for which TAGCOUNT( ) returns the number of tags. If CDXFileName does not exist for the current table, you must specify the nWorkarea or cTableAlias in which it does exist.
If you omit CDXFileName, TAGCOUNT( ) returns the number of tags in all .cdx compound index files and open .idx single-entry index files in the currently selected work area or alias. 

</param>
<param name="nWorkarea">

Specifies the work area of the table for which TAGCOUNT( ) returns the number of tags for the .cdx compound index file. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which TAGCOUNT( ) returns the number of tags for the .cdx compound index file.
</param>
<returns>
Numeric
</returns>
<remarks>
Included for compatibility with dBASE.
</remarks>
</tagcount>
<tagno>
<summary>
Returns the index position for .cdx compound index file tags and open .idx single-entry index files.
</summary>
<param name="IndexName">

Specifies the name of a .cdx compound index file tag or an open .idx single-entry index file for which TAGNO( ) returns the index position. 

</param>
<param name="CDXFileName">

Specifies the name of a .cdx compound index file containing the name of the tag you specify with IndexName.

</param>
<param name="nWorkArea">

Specifies the work area of the table for which TAGNO( ) returns the index position for .cdx compound index file tags and .idx single-entry index files. 

</param>
<param name="cTableAlias">

Specifies the alias of the table for which TAGNO( ) returns the index position for .cdx compound index file tags and .idx single-entry index files.
</param>
<returns>
Numeric
</returns>
<remarks>
TAGNO( ) returns 0 if a master index is not set (the table is in natural record number order) and the optional parameters are omitted.
Included for compatibility with dBASE.
</remarks>
</tagno>
<tan>
<summary>
This trigonometric function returns the tangent of an angle.
</summary>
<param name="nExpression">

Specifies the angle in radians for which TAN( ) returns the tangent. To convert an angle from degrees to radians, use DTOR( ). The number of decimal places returned by TAN( ) can be specified with SET DECIMALS.
</param>
<returns>
Numeric
</returns>
<example>
 <code language="X#">CLEAR
? TAN(0)  &amp;&amp; Displays 0.00
? TAN(PI( )/4)  &amp;&amp; Displays 1.00
? TAN(PI( )*3/4)  &amp;&amp; Displays -1.00</code>
</example>
</tan>
<target>
<summary>
Returns the alias of a table that is the target for a relation as specified in the INTO clause of SET RELATION.
</summary>
<param name="nRelationshipNumber">

Specifies the number of a relationship. Include a number from 1 to the number of relationships out of the specified work area. The aliases of the target tables are returned (in no specific order) until nRelationshipNumber is greater than the number of relationships. When nRelationshipNumber is greater than the number of relationships, the empty string is returned.

nWorkArea| cTableAlias
Returns the alias of the target table in another work area. nWorkArea specifies a work area number and cTableAlias specifies a table alias. By default, the alias of the target table from the current work area is returned if you don't specify the work area or alias.
</param>
<returns>
Character
</returns>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE orders IN 0 ORDER order_id
USE customer IN 0 ORDER cust_id
SELECT orders
SET RELATION TO cust_id INTO customer
? TARGET(1)  &amp;&amp; Displays customer
? TARGET(2)  &amp;&amp; Empty string</code>
</example>
</target>
<textmerge>
<summary>
Provides evaluation of a character expression.
</summary>
<param name="cExpression">

Specifies the string expression to be evaluated.

</param>
<param name="lRecursive">

Specifies whether to repeatedly iterate through all levels of delimiters in cExpression, evaluating until no text merge delimiters remain.

</param>
<param name="cLeftDelim">

Specifies the left delimiter to use for the text merge search. cLeftDelim is limited to two characters.

</param>
<param name="cRightDelim">

Specifies the right delimiter to use for the text merge search. cRightDelim is limited to two characters.
</param>
<returns>
Character string. Represents the value of cExpression, the merged text.
</returns>
<remarks>
The cLeftDelim and cRightDelim parameters temporarily override any SET TEXTMERGE DELIMITERS values.
The TEXTMERGE( ) function responds to current settings of SET TEXTMERGE SHOW | NOSHOW. 
</remarks>
<example>
 <code language="X#">SET TEXTMERGE OFF
TEXT to myvar noshow &amp;&amp;textm
this is a test   &lt;&lt;datetime()&gt;&gt;
&lt;&lt;program(-1)&gt;&gt;
&lt;&lt;myvar&gt;&gt;
textmerge(myvar) (this line is literal)
&lt;&lt;doit(myvar)&gt;&gt;   (cause recursion
END of orig text
endtext
?myvar
?"Now starting textmerge"
?textmerge(myvar)
PROCEDURE doit(myvar)
*  r=i   &amp;&amp; cause an error
if program(-1) &gt; 3
return "THEEND*********"
endif
return textmerge(myvar)</code>
</example>
</textmerge>
<time>
<summary>
Returns the current system time in 24-hour, eight-character string (hh:mm:ss) format.
</summary>
<param name="nExpression">

The time returned includes hundredths of a second if nExpression is included. The numeric expression nExpression can be any value. However, the actual maximum resolution is about 1/18 second. Use SECONDS( ) for greater resolution.
</param>
<returns>
Character
</returns>
</time>
<transform>
<summary>
Returns a character string from an expression in a format determined by a format code.
Using <b>TRANSFORM( )</b> with a large negative number that contains a decimal might result in numeric overflow when that number is passed in as a memory variable. You should use the <b>STR( )</b> function instead with such numbers.
</summary>
<param name="eExpression">

Specifies the expression to format.

</param>
<param name="cFormatCodes">

Specifies one or more format codes that determine how to format the expression. 
The following table lists the available format codes for cFormatCodes.
@B
Left-justifies <b>Numeric</b> data within the display region.
@C
Appends a CR to positive <b>Currency</b> or <b>Numeric</b> values to indicate a credit.
@D
Converts <b>Date</b> and <b>DateTime</b> values to the current <b>SET DATE</b> format.
@E
Converts <b>Date</b> and <b>DateTime</b> values to a BRITISH date format.
@L
Pads numeric data with leading zeroes.
@R
The transformation uses a format mask. The mask characters are not stored to the transformed value. Use only with character or numeric data. Mask characters include:
9 or #   Represents a character or number.
!   Converts lower-case letters to uppercase letters.
X# does not display specified mask characters that exceed the converted string length of the passed expression.
@T
Trims leading and trailing spaces from character values.
@X
Appends DB to negative currency or numeric values to indicate a debit.
@YL
Use Long Date system setting.
@YS
Use Short Date system setting.
@Z
If 0, converts currency or numeric values to spaces.
@(
Encloses negative currency or numeric values in parentheses.
@^
Converts currency or numeric values to scientific notation.
@0
Converts numeric or currency values to their hexadecimal equivalents. The numeric or currency value must be positive and less than 4,294,967,296.
@!
Converts an entire character string to uppercase.
@$
Adds the current currency symbol specified by <b>SET</b><b> </b><b>CURRENCY</b> to currency and numeric values. By default, the symbol is placed immediately before or after the value. However, the currency symbol and its placement (specified with <b>SET CURRENCY</b>), the separator character (specified with <b>SET SEPARATOR</b>) and the decimal character (specified with <b>SET POINT</b>) can all be changed.
Specifies the width of character values. For example, if cFormatCodes is 'XX', 2 characters are returned.
Converts logical True (.T.) and False (.F.) values to Y and N, respectively.
Converts a lowercase character to uppercase in the corresponding position in a character string.
Specifies the decimal point position in currency and numeric values.
Separates digits to the left of the decimal point in currency and numeric values.
Specifies width of numeric values. 
For example, if cFormatCodes is '999.99', the numeric characters are formatted with three characters to the left of the decimal point, and two characters to the right.
When specifying cFormatCodes for numeric values, the format code must be at least the size of the value you want to display. 
The following example shows the results when the format code is missing, less than, and equal to the size of the value you want to display.
 <code language="X#">CREATE CURSOR myCursor (col1 n(5,2))
INSERT INTO myCursor VALUES (-555.5)
* No format code and returns **.**
? TRANSFORM(myCursor.col1 )
* A format code 1 less than value returns ***.**
? TRANSFORM(myCursor.col1,'999.99' )
* A format code same size as value returns -556.00
? TRANSFORM(myCursor.col1,'9999.99' )</code>
When the expression value is longer than the width of the numeric field, X# forces the value to fit by performing the following steps:  
Truncate decimal places and round the remaining decimal portion of the field.
If the value does not fit, store the field contents using scientific notation.
If the value still does not fit, replace the field contents with asterisks.
For more information about format codes, see InputMask Property and Format Property.
If you omit cFormatCodes, X# performs a default transformation on eExpression. The following table describes the transformation performed for each data type eExpression can assume.
<b>Blob</b>

Outputs character string representation of the binary value without the hexadecimal prefix. For example, the following line of code outputs the character string "FEOAF2": 
 <code language="X#">TRANSFORM(0hFE0AF2)</code>
For binary values, <b>TRANSFORM(</b> <b>)</b> disregards format codes except for those that restrict width. For example, the following lines of code output "FE0A":
 <code language="X#">TRANSFORM(0hFE0AF2, "XXXX")
TRANSFORM(0hFE0AF2, "9999")
TRANSFORM(0hFE0AF2, "####")</code>
For those format codes that restrict width, the maximum output length is 255 characters.
<b>Character</b>
Performs no transformation.
Transformation is determined by the settings specified in the Regional tab of the Options dialog box.
Performs a <b>DTOC( )</b> transformation on the date.
Performs a <b>TTOC( )</b> transformation on the date time.
<b>General</b>
Returns "Gen" if the <b>General</b> field contains an object or "gen" if the <b>General</b> field does not contain an object.
<b>Logical</b>
Transforms logical True (.T.) and False (.F.) values to the character strings ".T." and ".F." respectively.
<b>Memo</b>
<b>Numeric</b> (includes <b>Double</b>, <b>Float</b>, or <b>Integer</b> data types)
Removes trailing zeros from the decimal portion of a numeric value when all the numbers following the decimal point are zeros.
If the numeric value is a whole number, a decimal point is not included in the transformed value, for example, 4.0 is transformed to 4. 
If the numeric value is less than one but greater than negative one, zero is included before the decimal point, for example, .4 is transformed to 0.4.
Object
Returns the character string "(Object)".
<b>Varbinary</b>
For binary values, <b>TRANSFORM( )</b> disregards format codes except for those that restrict width. For example, the following lines of code output "FE0A":
</param>
<returns>
Character data type. <b>TRANSFORM( )</b> returns character string from an expression in a format determined by a format code.
</returns>
<example>
 <code language="X#">STORE 12.34 TO gnPrice
CLEAR
? TRANSFORM(gnPrice, '$$$$.99')  &amp;&amp; Displays $12.34
? TRANSFORM(_SCREEN)   &amp;&amp; Displays (Object)</code>
</example>
</transform>
<trim>
<summary>
Removes all trailing spaces or parsing characters from the specified character expression, or all trailing zero (0) bytes from the specified binary expression.
</summary>
<param name="cExpression">

Specifies an expression of <b>Character</b> or <b>Varbinary</b> type to remove all trailing spaces or 0 bytes from, respectively.

</param>
<param name="nFlags">

Specifies if trimming is case-sensitive when one or more parse characters (cParseChar, cParseChar2, … are included. Trimming is case-sensitive if nFlags is zero or is omitted. Trimming is case-insensitive if nFlags 1.

cParseChar [, cParseChar2 [, ...]]
Specifies one or more character strings that are trimmed from the end of cExpression. If cParseChar isn't included, then trailing spaces or 0 bytes are removed from Expression.
<b>Note</b>   The maximum number of strings permitted in cParseChar is 23. 
</param>
<returns>
Character or Varbinary. <b>TRIM( )</b> returns the specified expression without trailing spaces or parsing characters, or 0 bytes.
</returns>
<remarks>

<b>TRIM( )</b> is identical to <b>RTRIM( )</b>.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
CLEAR
? 'The contact for '+ TRIM(company) + ' is ' + contact</code>
</example>
</trim>
<ttoc>
<summary>
Converts a <b>DateTime</b> expression to a <b>Character</b> value with the specified format.
</summary>
<param name="tExpression">

Specifies a <b>DateTime</b> expression to convert into a character string. 
If tExpression contains only a time, X# adds the default date of 12/30/1899 to tExpression. If tExpression contains only a date, X# adds a default time of 12:00:00 AM (if SET HOURS is 12) or 00:00:00 (if SET HOURS is 24) to tExpression to produce a valid DateTime value.
1 
Returns tExpression as a character string in a format suitable for indexing. The character string returned has a 14-character format, yyyymmddhhmmss, that is not affected by the <b>SET CENTURY</b>, the <b>SET HOURS</b>, or <b>SET SECONDS</b> commands. For more information, see SET CENTURY, SET HOURS, and SET SECONDS.
2 
Returns tExpression as a character string containing only the time portion of tExpression. 
To control whether to include the seconds of the time portion in the character string, set the <b>SET SECONDS</b> and <b>SET DATE</b> commands. The <b>SET HOURS</b> command determines if AM or PM is appended to the time portion returned.
For more information, see SET DATE and SET HOURS.   
If <b>SET DATE</b> is set to <b>LONG</b> or <b>SHORT</b>, the format of the time setting in the Windows Control Panel determines the format of the character string.
3 
Returns tExpression as a character string with the XML DateTime format. The character string returned has a 19-character yyyy-mm-ddThh:mm:ss format that is not affected by the settings of the <b>SET CENTURY</b>, <b>SET HOURS</b>, or <b>SET SECONDS</b> commands.
</param>
<returns>
Character. <b>TTOC( )</b> returns a <b>DateTime</b> expression as a character string.
When passing the value 1 or 3 as the second parameter, the character string returned does not include the AM or PM designations to indicate times before or after noon, respectively. Instead, the string uses a 24-hour clock, also known as military time. For example, the time 18:30:00 is equivalent to 06:30:00 PM.
</returns>
<remarks>
If an invalid value is passed as the second parameter, <b>TTOC( )</b> handles the invalid value as if it was a value of 1.
</remarks>
<example>
 <code language="X#">STORE DATETIME( ) TO gtDateTime
? "gtDateTime has type: "+TYPE('gtDateTime')
gtDateTime = TTOC(gtDateTime)
? "gtDateTime is now type: "+TYPE('gtDateTime')</code>
</example>
</ttoc>
<txnlevel>
<summary>
Returns a numeric value indicating the current transaction level.
</summary>
<returns>
TXNLEVEL( )Return Value
Numeric
</returns>
<remarks>
Use BEGIN TRANSACTION to create a transaction. Transactions are nested by issuing BEGIN TRANSACTION when another transaction is in progress. Transactions can be nested in this manner to five levels. Use TXNLEVEL( ) to determine the current transaction level.
TXNLEVEL( ) returns a value from 0 to 5. TXNLEVEL( ) returns 0 if a transaction is not in progress.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE Customer     &amp;&amp; Open customer table
CLEAR
BEGIN TRANSACTION
tLevel = ALLTRIM(STR(TXNLEVEL()))
=MESSAGEBOX("Current Transaction: " + tLevel, 0, "Transaction Level")
BEGIN TRANSACTION
tLevel = ALLTRIM(STR(TXNLEVEL()))
=MESSAGEBOX("Current Transaction: " + tLevel, 0, ;
"Transaction Level")
END TRANSACTION
END TRANSACTION</code>
</example>
</txnlevel>
<txtwidth>
<summary>
Returns the length of a character expression with respect to the average character width for a font.
</summary>
<param name="cExpression">

Specifies a character expression for which TXTWIDTH( ) returns the length. If you include only cExpression, the length of the character expression is returned for the current font for the main X# window or the active output window. A non-proportional font always returns a value equal to the number of characters in cExpression.
Include the optional arguments cFontName, nFontSize and cFontStyle to determine the length of a character expression with a specific font, font point size, or font style.  

</param>
<param name="cFontName">

Specifies the name of the font. Include cFontName to return the length of a character expression with a specific font.

</param>
<param name="nFontSize">

Specifies a number that corresponds to the point size of the font. Include nFontSize to return the length of a character expression with a specific point size.

</param>
<param name="cFontStyle">

Specifies a special font style for the character expression. cFontStyle is a font style code specified by a character or a set of characters. The Normal font style is used if cFontStyle isn't included. Here are the characters for each font style:
B
Bold
I
Italic
O
Outline
Q
Opaque
Shadow
-
Strikeout 
Transparent
U
Underline
You can include more than one character to specify a combination of font styles. For example, BI specifies a Bold Italic font style.   
The following command displays a message in a Courier normal 24-point font, centered horizontally in the main X# window:   
 <code language="X#">@ 25,(WCOLS( )-TXTWIDTH('Hello!','Courier ',24)* ;
FONTMETRIC(6,'Courier ',24)/FONTMETRIC(6))/2  ;
SAY 'Hello!' FONT 'Courier ',24</code>
</param>
<returns>
Numeric
</returns>
<remarks>
TXTWIDTH( ) returns the number of characters a character expression cExpression occupies, based on the average character width of a specified font (the average character width of a font is called a foxel). Use FONTMETRIC(6) to determine the average character width of a font.
If you don't include a font in TXTWIDTH( ), the value returned by TXTWIDTH( ) is determined by the current font for the main X# window, as long as output is directed to the main X# window when TXTWIDTH( ) is issued. If output is being directed to a user-defined window, the value returned is determined by the window's current font.
</remarks>
</txtwidth>
<type>
<summary>
Returns the data type of an expression.
<b>VARTYPE( )</b> is similar to the <b>TYPE( )</b> function, but <b>VARTYPE( )</b> is faster and does not require quotation marks ("") to enclose the specified expression.
</summary>
<param name="cExpression">

Specifies the expression, which can be a variable, array, field, memo field, or other expression, for which  the data type is returned. 
You must pass the expression as a character string by enclosing the expression with quotation marks (""). If you do not enclose the expression with quotation marks, <b>TYPE( )</b> evaluates the contents of the expression. 

</param>
<param name="1">

Include the optional parameter 1 to determine if cExpression is an array or a Collection Class. COM objects are not supported with the 1 parameter.
</param>
<returns>
Character. <b>TYPE( )</b> returns a character representing the data type of the specified expression.
The following table lists the character values that <b>TYPE( )</b> returns and their corresponding data types.
A

<b>Array (only returned when the optional 1 parameter is included)</b>

C

<b>Character</b>, <b>Varchar</b>, <b>Varchar</b> (Binary) 
If the optional 1 parameter is included, a return value of C indicates that the data type is a collection.
D

<b>Date</b>

G

<b>General</b>

L

<b>Logical</b>

M

<b>Memo</b>

N

<b>Numeric</b>, <b>Float</b>, <b>Double</b>, or <b>Integer</b>
O
Object
Q

<b>Varbinary</b>

S
Screen 
The Screen type is created when using the <b>SAVE SCREEN</b> command. For more information, see SAVE SCREEN Command.
T

<b>DateTime</b>

U
Undefined type of expression or cannot evaluate expression.
If the optional 1 parameter is included, a return value of U indicates that the data type is not an array.
W

<b>Blob</b>

Y

<b>Currency</b>

</returns>
<remarks>
If you pass an array as a parameter to <b>TYPE( )</b>, the data type returned corresponds to the first element in the array. If you want to check the data type for a specific array element, you must specify that element in the parameter. For example:
 <code language="X#">? TYPE("myarray[3]")</code>
You can also use the <b>TYPE( )</b> function to check if a memory variable is an array. For example:
 <code language="X#">? TYPE("myarray[1]")#"U"</code>
<b>TYPE( )</b> cannot be used to evaluate UDFs (user-defined functions).
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
USE customer  &amp;&amp; Opens Customer table
nTest = 1.01
cTest = "String"
CLEAR
? TYPE('customer.contact')  &amp;&amp; Displays C
? TYPE('(12 * 3) + 4')  &amp;&amp; Displays N
? TYPE('DATE( )')  &amp;&amp; Displays D
? TYPE('.F. OR .T.')  &amp;&amp; Displays L
? TYPE('ANSWER=42')  &amp;&amp; Displays U
? TYPE('$19.99')  &amp;&amp; Displays Y
? TYPE('nTest')  &amp;&amp; Displays N
? TYPE('cTest')  &amp;&amp; Displays C</code>
</example>
</type>
<unbindevents>
<summary>
You can use <b>UNBINDEVENTS( )</b> to unbind, or detach, an event that was originally bound to a X# object using <b>BINDEVENT( )</b>. To detach events from Component Object Model (COM) objects, use the <b>EVENTHANDLER( ) </b>function. There are three versions of the syntax.
</summary>
<param name="oEventSource">

Specifies the event source, which must be a valid X# object.

</param>
<param name="oEventObject">

Specifies an object reference, which can be used as the event source or event handler. 

</param>
<param name="cEvent">

Specifies the name of the event, method, or property you want to unbind.

</param>
<param name="oEventHandler">

Specifies the object that is handling the event.

</param>
<param name="cDelegate">

Specifies the delegate method handling the event for oEventHandler.

</param>
<param name="hWnd">

Specifies the integer handle of the window for which events are unbound.
If hWnd is 0, all hWnds are unbound.
If the nMessage parameter isn't included, then all Windows message bindings for the window handle hWnd are unbound.

</param>
<param name="nMessage">

Specifies a valid Windows message (Win Msg) that is unbound. See MSDN (the Microsoft Developer Network) for information about Windows messages.
</param>
<returns>
Numeric data type.<b> UNBINDEVENTS( )</b> returns the number of events that are unbound if unbinding succeeds. <b>UNBINDEVENTS( )</b> returns a value of 0 if no events exist for unbinding. X# generates an error if <b>UNBINDEVENTS( )</b> fails to unbind events that are available for unbinding.
</returns>
<remarks>
The following table describes the ways you can use <b>UNBINDEVENTS( )</b>.

codeUNBINDEVENTS(oEventSource, cEvent, oEventHandler, cDelegate)/code

Unbinds a specific event from an event handler.

codeUNBINDEVENTS(oEventObject)/code

Unbinds all events associated with this object. This includes events that are bound to it as an event source and its delegate methods that serve as event handlers.

codeUNBINDEVENTS(hWnd [, nMessage])/code

Unbinds all or specific Windows Message (Win Msg) events. 
If an event is occurring, and <b>UNBINDEVENTS( )</b> or the delegate method handling the event is called, the event and its delegate method finish running before <b>UNBINDEVENTS( )</b> unbinds the event.
You can call the <b>AEVENTS( )</b> function retrieve information about all the events and delegate methods attached to a particular object.
</remarks>
<example>
 <code language="X#">PUBLIC oHandler
oHandler=NEWOBJECT("myhandler")
DO (_browser)
BINDEVENT(_SCREEN,"Resize",oHandler,"myresize")
UNBINDEVENTS(_SCREEN,"Resize",oHandler,"myresize")
DEFINE CLASS myhandler AS Session
PROCEDURE myresize
_obrowser.left = _SCREEN.Width - _obrowser.width
RETURN
ENDDEFINE</code>
</example>
</unbindevents>
<unique>
<summary>
Included for compatibility with dBASE.
 
</summary>
</unique>
<updated>
<summary>
Included for backward compatibility. Use the InteractiveChange Event or ProgrammaticChange Event instead.
 
Returns true (.T.) if you changed any data during the most recent READ.
</summary>
<returns>
Return value - Logical
</returns>
<remarks>
<br />
UPDATED() returns true if the data in a field, spinner or text editing region was changed or if a choice was made from a check box; an invisible, push or radio button; a list; or a popup.  <br />
<br />
UPDATED() returns false (.F.) if the data in a field, spinner or text-editing region wasn't changed or no choices were made from a check box, an invisible, push or radio button, a list, or a popup during the most recent READ. UPDATED() returns false if a control was updated from within a program (for example, with REPLACE or SHOW GETS).<br />
<br />

</remarks>
</updated>
<upper>
<summary>
Returns the specified character expression in uppercase.
</summary>
<param name="cExpression">

Specifies the character expression UPPER( ) converts to uppercase.
</param>
<returns>
Character
</returns>
<remarks>
Each lowercase letter (a – z) in the character expression is converted to uppercase (A – Z) in the returned string. This is true for high-ASCII characters as well, even if the current font does not display them as lowercase accented characters.
</remarks>
<example>
 <code language="X#">CLEAR
? UPPER('abcdefgh')  &amp;&amp; Displays ABCDEFGH</code>
</example>
</upper>
<used>
<summary>
Determines if an alias is in use or a table is open in a specific work area.
</summary>
<returns>
Logical
</returns>
<remarks>
USED( ) can determine if an alias is in use or if a table is open in a specific work area.
</remarks>
<example>
 <code language="X#">CLOSE DATABASES
OPEN DATABASE (HOME(2) + 'Data\testdata')
SELECT A
USE customer  &amp;&amp; Opens Customer table
SELECT B
USE orders  &amp;&amp; Opens Orders table
SELECT C
USE employee  &amp;&amp; Opens Employee table
? USED('A')  &amp;&amp; Displays .T.
? USED('B')  &amp;&amp; Displays .T.
? USED(4)  &amp;&amp; Displays .F.</code>
</example>
</used>
<val>
<summary>
Returns a numeric or currency value from a character expression composed of numbers. You can use <b>VAL( )</b> to convert the character strings returned by the X# <b>SYS( )</b> functions to numeric values.
</summary>
<param name="cExpression">

Specifies a character expression composed of up to 16 numbers. Rounding occurs if more than 16 numbers are included in cExpression. 
If the first character of cExpression is a dollar sign ($),<b>VAL( ) </b>returns a currency value. In all other situations <b>VAL( )</b> returns a numeric value.
</param>
<returns>
Numeric or Currency data type. <b>VAL( )</b> returns the numbers in the character expression from left to right until a non-numeric character is encountered. Leading blanks are ignored. <b>VAL( )</b> returns 0 if the first character of the character expression is not a number, a dollar sign ($), a plus sign (+), or minus sign (-). You can control the result of VAL( ) by issuing the SET DECIMALS command before using the VAL( ) function.
</returns>
<example>
 <code language="X#">CLEAR
STORE '12' TO A
STORE '13' TO B
? VAL(A) + VAL(B)  &amp;&amp; Displays 25.00
STORE '1.25E3' TO C
? 2 * VAL(C)  &amp;&amp; Displays 2500.00</code>
</example>
</val>
<varread>
<summary>
Included for backward compatibility in X#. Use the ControlSource Property or Name Property (X#) instead.
 
Returns in uppercase the name of the memory variable, array element, or field used to create the current @ ... GET field or control.
</summary>
<returns>
Return value - Character
</returns>
<remarks>
<br />
Controls include check boxes, fields, invisible, push or radio buttons, lists, popups, spinners, and text-editing regions.<br />
<br />
If a Browse, Change or Edit window is active, the name of the current field is returned with the first letter of the field name capitalized.<br />
<br />
VARREAD() is identical to SYS(18). Both can be used to pass the current field or control name to a procedure that in turn can provide context-sensitive help, as in the following example.<br />
<br />

</remarks>
<example>




 






<code language="X#">SET TALK OFF
CLOSE DATABASES
ON KEY LABEL F1 DO Help WITH VARREAD()
USE customer
SCATTER TO temp
DEFINE WINDOW input FROM 6,10 to 18,70 PANEL
ACTIVATE WINDOW input
@ 1,3  SAY 'Customer: ' GET company
@ 3,3  SAY 'Address: '  GET address
@ 5,3  SAY 'City: '     GET city
@ 7,3  SAY 'State: '    GET state
@ 7,18 SAY 'Zip: '      GET zip
@ 9,7  SAY 'Press Esc to cancel or F1 for help'
READ
GATHER FROM temp
DEACTIVATE WINDOW input
RELEASE WINDOW input
ON KEY LABEL F1
RETURN
*** Help Procedure ***
PROCEDURE Help
PARAMETERS fieldname
DO CASE
CASE fieldname = 'COMPANY'
WAIT WINDOW 'Enter the company name' NOWAIT
CASE fieldname = 'ADDRESS'
WAIT WINDOW 'Enter the street address' NOWAIT
CASE fieldname = 'CITY'
WAIT WINDOW 'Enter the city name' NOWAIT
CASE fieldname = 'STATE'
WAIT WINDOW 'Enter a two-character state abbreviation' NOWAIT
CASE fieldname = 'ZIP'
WAIT WINDOW 'Enter the five-digit Zip code' NOWAIT
ENDCASE
RETURN
</code>					




</example>
</varread>
<vartype>
<summary>
Returns the data type of an expression.
<b>VARTYPE( )</b> is similar to the <b>TYPE( )</b> function, but <b>VARTYPE( )</b> is faster and does not require quotation marks to enclose the expression for which the data type is returned.
</summary>
<param name="eExpression">

Specifies the expression for which the data type is returned. <b>VARTYPE( )</b> returns a single character indicating the data type of the expression. 
The following table lists the characters that <b>VARTYPE( )</b> returns for each data type.   
C
<b>Character</b>, <b>Memo</b>, <b>Varchar</b>, <b>Varchar</b> (Binary)
D
<b>Date</b>
G
<b>General</b>
L
<b>Logical</b>
N
<b>Numeric</b>, <b>Float</b>, <b>Double</b>, or <b>Integer</b>
O
Object
Q
<b>Blob</b>, <b>Varbinary</b>
<b>DateTime</b>
U
Unknown or variable does not exist
X
Null
<b>Currency</b>
If eExpression is an array, the first element in the array is evaluated.

</param>
<param name="lNullDataType">

Specifies whether <b>VARTYPE( )</b> returns the data type when eExpression contains the null value. 
The following table lists the values of lNullDataType.   
True (.T.)
Return data type for eExpression.
False (.F.) or omitted
Return 'X' to indicate eExpression contains a null value.
</param>
<returns>
Character. <b>VARTYPE( )</b> returns a character representing the data type of the specified expression.
</returns>
</vartype>
<version>
<summary>
Returns information about the X# version you are using.
</summary>
<param name="nExpression">

Specifies that <b>VERSION( )</b> returns additional information about X#. If you omit nExpression, <b>VERSION( )</b> returns the X# version number.
The following table lists values for nExpression and the additional X# information returned.   
1
X# date and serial number.
2
X# version type:
0 - Run time version
1 - Standard Edition (earlier versions)
2 - Professional Edition (earlier versions)
3
Localized X# language. The following two character values indicate the language for which X# is localized: 
00 - English
07 - Russian
33 - French
34 - Spanish
39 - Czech
48 - German
55 - Korean&amp;nbsp; 42 - Czechbr49 - Germanbr82 - Korean 
86 - Simplified Chinese
88 - Traditional Chinese
The X# version number in a standard, easily parsed format. 
For versions prior to X# 8.0, the standard format is "MM.mm.0000.DDDD" where MM is the major release number, mm is the incremental minor revision number, 0000 is a fixed placeholder, and DDDD is the four digit product date for the day the version was created. 
For X# 8.0, the formula for calculating the product date, DDDD, is 8000 + number of days since the beginning of 1998. For example, 8397 corresponds to February 1, 1999.
For X# 9.0, the formula for calculating the product date, DDDD, is number of months since January 1, 2003 concatenated with the day of the current month. For example, 2215 corresponds to October 15, 2004.
The format for X# 8.0 and 9.0 is "MM.mm.0000.NNNN" where MM is the major release number, mm is the incremental minor revision number, 0000 is a fixed placeholder, and NNNN is the build number.
The X# release version in the format Mmm where M is the major release number and mm is the incremental minor revision number. For example, VERSION(5) returns 700 in X# 7.0.
</param>
<returns>
Character, Numeric
</returns>
<remarks>
Use <b>VERSION( )</b> to conditionally execute version-specific portions of code.
VERSION( ), VERSION(1), VERSION(3), and VERSION(4) return character strings; VERSION(2) and VERSION(5) return numeric values.
</remarks>
<example>
 <code language="X#">CLEAR
? <b>VERSION( )</b>
? <b>VERSION(</b>1<b>)</b>
? <b>VERSION(</b>2<b>)</b>
? <b>VERSION(</b>3<b>)</b>
? <b>VERSION(</b>4<b>)</b>
? <b>VERSION(</b>5<b>)</b></code>
</example>
</version>
<wborder>
<summary>
Determines whether the active or specified window has a border.
</summary>
<param name="WindowName">

Specifies the name of the window for which WBORDER( ) returns a logical value.
WBORDER( ) returns a logical value for the active output window if you omit a window name.
</param>
<returns>
Logical
</returns>
<remarks>
WBORDER( ) returns true (.T.) if the specified window has a border; otherwise WBORDER( ) returns false (.F.). By default, windows have borders. Include the NONE clause in DEFINE WINDOW to create a window without a border.
</remarks>
</wborder>
<wchild>
<summary>
Returns either the number of child windows in a parent window or the names of the child windows in the order in which they are stacked in the parent window.
</summary>
<param name="WindowName">

Specifies a window other than the active output window for which WCHILD( ) returns the number of child windows. The number of child windows in the specified window is returned if you include just a window name without the numeric expression nChildWindow. 
If you include both WindowName and nChildWindow, WCHILD( ) returns the names of the child windows in the specified window. If you include both WindowName and nChildWindow, separate WindowName and nChildWindow with a comma.   
You can also include the empty string in WindowName to specify the main X# window. 

</param>
<param name="nChildWindow">

Specifies a numeric expression included to return the names of child windows in the active output window when you omit WindowName.
The numeric expression nChildWindow can be 0 or any positive value. The name of the child window at the bottom of the stack of child windows in the current output window is returned if nChildWindow is 0.   
If nChildWindow is a positive number, WCHILD( ) returns the name of the next child window in the window stack. The name of next child window in the stack is returned if you issue WCHILD( ) again with a positive number, and so on. The empty string is returned if WCHILD( ) is called more times than the number of child windows in the parent window. For more information on window stacking, see ACTIVATE WINDOW.   
In X# for Windows, if the main X# window is active, all windows are children of the main X# window. In X#, toolbars that are not docked in the border of the main X# window are children of the main X# window. Issuing a series of WCHILD() functions with positive numbers returns the names of the active windows and toolbars.
If you include both WindowName and nChildWindow, separate WindowName and nChildWindow with a comma.
</param>
<returns>
Character or Numeric
</returns>
<remarks>
You can create a window (the parent window) and place other windows (child windows) inside. Including the IN or IN WINDOW clause in DEFINE WINDOW creates a child window inside the parent window. A child window created and activated inside a parent window cannot be moved outside the parent window. If the parent window is moved, the child window moves with it.
The number of child windows in the active output window is returned if you issue WCHILD( ) without any arguments.
</remarks>
</wchild>
<wcols>
<summary>
Returns the number of columns within the active or specified window.
</summary>
<param name="WindowName">

Specifies the window for which WCOLS( ) returns the number of columns. In X#, you can also specify the name of a toolbar. If you do not specify a window, the number of columns in the active output window is returned. If no window is active, WCOLS( ) returns the number of columns in the main X# window.
You can specify the name of a system window (the Command window, the Data Session window, a Browse window, and so on) in WCOLS( ) if the system window has been activated and is visible or hidden. In X#, you can specify the name of a toolbar (the Standard toolbar, the Color Palette toolbar, and so on) in WCOLS( ) if the toolbar has been activated and is visible or hidden. If you specify the name of a system window or toolbar that has not been activated, X# generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WCOLS( ) if it is visible, hidden or closed.   
You can also include the empty string as the window name to return the number of columns in the main X# window.   
The empty string can be used to specify the main X# window in functions such as WLCOL( ), WLROW( ), and WROWS( ), which return window locations or sizes.
</param>
<returns>
Numeric
</returns>
<remarks>
In X#, the value returned by WCOLS( ) depends on the font specified for the window. Many fonts can be displayed in a wide variety of sizes, and some are proportionally spaced. A column corresponds to the average width of a letter in the current font. For more information, see the Fonts Overview topic.
</remarks>
<example>
 <code language="X#">CLEAR
DO SendMesg WITH 'Message', WCOLS( ), WROWS( ) –1
*** SendMesg ***
PROCEDURE SendMesg
PARAMETERS gcMsg, gnCol, gnRow
STORE (gnCol – LEN(gcMsg))/2 TO gnCol
@ gnRow, gnCol SAY gcMsg
RETURN</code>
</example>
</wcols>
<wdockable>
<summary>
Returns the dockable state of the specified window
</summary>
<param name="cWindowName">

Specifies the name of the window to evaluate.

</param>
<param name="lEnable">

Specifies the dockable state for the window specified with the cWindowName parameter. If the specified window does not support docking, then X# ignores the lEnable parameter.
</param>
<returns>
Logical data type. Returns the current dockable state for the specified window.
</returns>
<remarks>
The <b>WDOCKABLE( )</b> function always returns False (.F.) for undockable windows. Use the <b>WDOCKABLE( )</b> function on X# windows that support docking. For a list of dockable X# windows, see How to: Dock Windows.
</remarks>
</wdockable>
<week>
<summary>
Returns a number representing the week of the year from a Date or DateTime expression.
</summary>
<param name="nFirstWeek">
0
Specifies that WEEK( ) return the week that is currently selected in the <b>First Week of Year</b> box on the Regional tab of the Options dialog box.
1
First week contains January 1st. This is the default when you omit nFirstWeek.
2
The larger half (four days) of the first week is in the current year.
3
First week has seven days.
[, nFirstDayOfWeek]
Specifies the first day of the week. The following table lists the values for nFirstDayOfWeek.
</param>
<param name="nFirstDayOfWeek">
0
Specifies that WEEK( ) return the day that is currently selected in the <b>Week Starts on</b> box on the Regional tab of the Options dialog box.
1
Sunday. This is the default when you omit nFirstDayOfWeek and is the first day of the week used in earlier FoxPro versions.
2
Monday
3
Tuesday
4
Wednesday
5
Thursday
6
Friday
7
Saturday
</param>
<returns>
Numeric type. WEEK( ) returns a number representing the week of the year.
</returns>
<remarks>
WEEK( ) returns a number from 1 to 53 that represents the week of the year. For example, WEEK( ) returns 1 for the first week of the year, 2 for the second week of the year, and so on. Note that a week can be split between years — the first week of the year can be in the current year and the previous year.
</remarks>
<example>
 <code language="X#">CLEAR
? WEEK(DATE( ))
? WEEK({^1998-02-16})  &amp;&amp; Displays 8</code>
</example>
</week>
<wexist>
<summary>
Determines whether the specified user-defined window exists.
</summary>
<param name="WindowName">

Specifies the name of the user-defined window.
You can also specify the name of a X# system window (the Command window, the Data Session window, a Browse window, and so on), and in X#, the name of a toolbar. WEXIST( ) returns true (.T.) if the system window or toolbar you specify is visible or hidden. WEXIST( ) returns false (.F.) if the specified system window or toolbar is closed.   
Two exceptions are the Command and Debug windows. Including the Command window's name in WEXIST( ) always returns a true value. If the Debug window has been opened, WEXIST( ) returns true, even if the Debug window is closed.
</param>
<returns>
Logical
</returns>
<remarks>
WEXIST( ) returns true (.T.) if the user-defined window you specify has been created with DEFINE WINDOW; otherwise WEXIST( ) returns false (.F.). The specified window does not have to be active or visible for WEXIST( ) to return true (.T.), but it must exist.
</remarks>
<example>
 <code language="X#">DEFINE WINDOW wScreen1 FROM 10,10 TO 20,69
DEFINE WINDOW wScreen2 FROM 1,0 TO 19,79
CLEAR
? WEXIST('wScreen1')  &amp;&amp; Displays .T.
STORE 'wScreen2' TO gcWinName
? WEXIST('win_name')  &amp;&amp; Displays .F.
? WEXIST(gcWinName)  &amp;&amp; Displays .T.
RELEASE WINDOWS wScreen1, wScreen2</code>
</example>
</wexist>
<wfont>
<summary>
Returns the name, size, or style of the current font for a window in X# for Windows.
</summary>
<param name="nFontAttribute">

Specifies the font attribute you want to return.
If nFontAttribute is 1, WFONT( ) returns the name of the current font for the active or specified window.   
If nFontAttribute is 2, WFONT( ) returns the font size.   
If nFontAttribute is 3, WFONT( ) returns a code that identifies the font style.   
The font style code is a character or set of characters that correspond to the current font style. For example, the current font style is Bold Italic if WFONT(3) returns BI.   
The following table lists the codes for each font style:   
Normal
Outline
Q
Opaque
Shadow
–
StrikeThru 
Transparent
U
Underline

</param>
<param name="WindowName">

Specifies the name of the window for which you want to determine the current font, font size, or font style. In X#, you can also include the name of a toolbar. Include the empty string to return the current font, font size, or font style for the main X# window.
WindowName can be the name of a user-defined window created with DEFINE WINDOW or a text- or memo-editing window.   
You can also include the name of a system window (View, Trace, Debug, and so on). WFONT( ) can return font attributes only for a system window that has been opened and is currently visible or hidden. If the system window you specify is closed, X# generates an error message.   
WFONT( ) returns the current font, font size or font style for the active output window if you omit WindowName.
</param>
<returns>
Character and Numeric
</returns>
<example>
 <code language="X#">CLEAR
DEFINE WINDOW wFontChar ;
FROM 1,1 TO 3,35 ;
FONT 'MS SANS SERIF',8 ;
STYLE 'BI'  &amp;&amp; Define window with font and style
ACTIVATE WINDOW wFontChar
? WFONT(1), WFONT(2), WFONT(3)  &amp;&amp; wFontChar window
ACTIVATE SCREEN
?
?
?
? 'Font characteristics for the window wFontChar'
?
?
? WFONT(1,''), WFONT(2,''), WFONT(3,'')  &amp;&amp; Main X# window
?
? 'Font characteristics for the main X# window'
WAIT WINDOW
RELEASE WINDOW wFontChar
CLEAR</code>
</example>
</wfont>
<window>
<summary>
Determines the active output window.
</summary>
<returns>
Character.
</returns>
<remarks>
<b>WINDOW( )</b> returns the name of the window to which output is currently directed./Pbr
<b>WINDOW( )</b> returns the empty string if output is being directed to the main X# window.
This function is included for backward compatibility. You may use the WOUTPUT( ) function instead.
</remarks>
<example>

<code language="X#">
PUBLIC oForm
oForm = CREATEOBJECT('Form')
oForm.AllowOutput = INT(SECONDS()) % 2 = 0
oForm.Caption = IIF(oForm.AllowOutput, "This form accepts output", ;
"This form does not accept output")
oForm.Show()
? "Default output window name is " + ;
IIF( EMPTY( WINDOW()), "None", WINDOW())
WAIT WINDOW "The default output window name should appear " + ;
IIF( EMPTY( WINDOW()), "nowhere", "in the form " + WINDOW())
</code>
</example>
</window>
<wlast>
<summary>
Returns the name of the window that was active prior to the current window or determines whether the specified window was active prior to the current window.
</summary>
<param name="WindowName">

Specifies a window that WLAST( ) evaluates. In X#, you can also specify the name of a toolbar. WLAST( ) returns true (.T.) if the specified window was active prior to the current window; otherwise false (.F.) is returned. False (.F.) is also returned if the window you specify doesn't exist.
The name of the window that was active prior to the current window is returned if you omit WindowName.
</param>
<returns>
Character or Logical
</returns>
<remarks>
WLAST( ) returns the empty string if the window that was active prior to the current window is the Debug, Trace, or Command window. Program execution isn't affected by bringing these windows forward when you are debugging a program that uses WLAST( ).
</remarks>
</wlast>
<wlcol>
<summary>
Returns the column coordinate of the upper-left corner of the active or specified window.
</summary>
<param name="WindowName">

Specifies the window for which WLCOL( ) returns the column coordinate. In X#, you can also specify the name of a toolbar. If you omit WindowName, WLCOLS( ) returns the column coordinate of the active output window. You can also use the empty string for WindowName to specify the main X# window.
In X#, if no window is active, WLCOLS( ) returns the column coordinate of the main X# window relative to the Windows desktop.    
If a system window (the Command window, the Data Session window, a Browse window, and so on) has been opened and is visible or hidden (its name appears on the Window menu), you can include its name in WLCOL( ). If you specify the name of a system window that is closed, X# generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WLCOL( ) if it is visible, hidden, or closed.
</param>
<returns>
Numeric
</returns>
<remarks>
The value returned by WLCOL( ) depends on the current video display mode, and is relative to the main X# window. The display mode can be changed with SET DISPLAY.
Windows can be positioned outside the main X# window. If the specified window is to the left of the main X# window, WCOL( ) returns a negative value. If the window's left border is to the right of the main X# window, WCOL( ) returns a positive value greater than the width of the main X# window.
</remarks>
</wlcol>
<wlrow>
<summary>
Returns the row coordinate of the upper-left corner of the active or specified window.
</summary>
<param name="WindowName">

Specifies the window for which WLROW( ) returns the row coordinate. In X#, you can also specify the name of a toolbar. If you omit WindowName, WLROW( ) returns the row coordinate of the active output window. You can also use the empty string for WindowName to specify the main X# window.
In X#, if no window is active, WLROW( ) returns the row coordinate of the main X# window relative to the Windows desktop.    
If a system window (the Command window, the Data Session window, a Browse window, and so on) has been opened and is visible or hidden (its name appears on the Window menu), you can include its name in WLROW( ). If you specify the name of a system window that is closed, X# generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WLROW( ) if it is visible, hidden, or closed.
</param>
<returns>
Numeric
</returns>
<remarks>
The value returned by WLROW( ) depends on the current video display mode, and the row coordinate is relative to the main X# window. The display mode can be changed with SET DISPLAY.
Windows can be positioned off the main X# window. If the top of the window is above the main X# window, WLROW( ) returns a negative value. If the top of the window is below the bottom of the main X# window, WLROW( ) returns a positive value greater than the height of the main X# window.
</remarks>
</wlrow>
<wmaximum>
<summary>
Determines whether the active or specified window is maximized.
</summary>
<param name="WindowName">

Specifies the name of the window WMAXIMUM( ) evaluates. You can specify the name of a X# system window (the Command window, the Data Session window, a Browse window, and so on). 
If you omit WindowName, WMAXIMUM( ) returns a logical value for the active window. You can also use the empty string for WindowName to specify the main X# window.
</param>
<remarks>
Windows can be enlarged to fill the window that contains them. In X# for Windows, the default container window is the main window.
A user-defined window created with DEFINE WINDOW can be maximized only if the ZOOM keyword is included in its definition.
WMAXIMUM( ) returns true (.T.) if the current or specified window is maximized; otherwise WMAXIMUM( ) returns false (.F.). In X#, you can include the name of a toolbar. However, WMAXIMUM( ) always returns false (.F.) for a toolbar because toolbars cannot be maximized.
</remarks>
</wmaximum>
<wminimum>
<summary>
Determines whether the active or specified window is minimized.
</summary>
<param name="WindowName">

Specifies the name of the window WMINIMUM( ) evaluates. You can specify the name of a X# system window (the Command window, the Data Session window, a Browse window, and so on).
If you omit WindowName, WMINIMUM( ) returns a logical value for the active window. You can also include the empty string in WindowName to specify the main X# window.
</param>
<returns>
Logical
</returns>
<remarks>
In X# for Windows, windows can be reduced to an icon.
A user-defined window created with DEFINE WINDOW can be minimized only if the MINIMIZE keyword is included in its definition.
WMINIMUM( ) returns true (.T.) if the current or specified window is minimized; otherwise it returns false (.F.). In X#, you can include the name of a toolbar. However, WMINIMUM( ) always returns false (.F.) for a toolbar because toolbars cannot be minimized.
</remarks>
</wminimum>
<wontop>
<summary>
Determines whether the active or specified window is in front of all other windows.
</summary>
<param name="WindowName">

Specifies the name of the window WONTOP( ) evaluates. You can specify the name of a user-defined window created with DEFINE WINDOW or a system window (the Command window, the Data Session window, a Browse window, and so on). If you omit WindowName, WONTOP( ) returns the name of the "frontmost" or active window. You can also include the empty string in WindowName to specify the main X# window.
If the Debug, Trace, or Command window is active and you don't specify a window name, WONTOP( ) returns the name of the window most recently in front. When you are debugging a program that uses WONTOP( ), program execution isn't affected by bringing these windows forward.
</param>
<returns>
Character or Logical
</returns>
<remarks>
WONTOP( ) returns true (.T.) if the specified window is active. It returns false (.F.) if the window isn't active or doesn't exist.
Historically in prior versions of X#, the Data Session window has always been referred to as the View window. Additionally, language used to control this window, such as <b>HIDE WINDOW</b>, <b>ACTIVATE WINDOW</b>, <b>WONTOP( )</b>, also refers to this window as the View window. X# continues to refer to the View window for the <b>WONTOP( ) </b>function.
</remarks>
<example>
 <code language="X#">IF NOT EMPTY(WONTOP( ))
WAIT WINDOW 'Frontmost window: ' + WONTOP( )
ELSE
WAIT WINDOW 'No windows are open'
ENDIF</code>
</example>
</wontop>
<woutput>
<summary>
Determines whether output is being directed to the active or specified window.
</summary>
<param name="WindowName">

Specifies the window WOUTPUT( ) evaluates for output. Output cannot be directed to a system window or toolbar. If you omit WindowName, WOUTPUT( ) returns the name of the window to which output is currently directed. You can also include the empty string in WindowName to specify the main X# window.
WOUTPUT( ) returns the empty string if output is being directed to the main X# window.
</param>
<returns>
Logical and Character
</returns>
<remarks>
WOUTPUT( ) returns true (.T.) if the specified user-defined window is the active output window. WOUTPUT( ) returns false (.F.) if the window you specify doesn't exist or is a system window. The last user-defined window activated with ACTIVATE WINDOW is the active output window.
</remarks>
<example>
 <code language="X#">DEFINE WINDOW wOutput1 FROM 2,2 TO 12,32 TITLE 'Output Window'
ACTIVATE WINDOW wOutput1
WAIT WINDOW 'wOutput1 window: ' + WOUTPUT( )
RELEASE WINDOW wOutput1
IF EMPTY(WOUTPUT( ))
WAIT WINDOW 'Output being directed to the main X# window'
ELSE
WAIT WINDOW 'Output window: ' + WOUTPUT( )
ENDIF</code>
</example>
</woutput>
<wparent>
<summary>
Returns the name of the parent window of the active or specified window.
</summary>
<param name="WindowName">

Specifies a window whose parent window name WPARENT( ) returns. WPARENT( ) returns the empty string if the specified window doesn't have a parent window. If you omit WindowName, WPARENT( ) returns the name of the parent window of the active output window. WPARENT( ) returns the empty string if the active output window doesn't have a parent window.
</param>
<returns>
Character
</returns>
<remarks>
You can use DEFINE WINDOW to create a window and place it in a parent window. The child window becomes integrated with its parent window. For example, a child window defined and activated inside a parent window can't be moved outside the parent window. If the parent window is moved, the child window moves with it.
</remarks>
<example>
 <code language="X#">CLEAR ALL
CLEAR
DEFINE WINDOW wParent ;
FROM 1,1 TO 20,20 ;
TITLE 'wParent'     &amp;&amp; Parent window
ACTIVATE WINDOW wParent
DEFINE WINDOW wChild ;
FROM 1,1 TO 10,10 ;
TITLE 'wChild' ;
IN WINDOW wParent  &amp;&amp; Child window
ACTIVATE WINDOW wChild
WAIT WINDOW 'The parent window is ' + WPARENT( )
RELEASE WINDOW wParent, wChild</code>
</example>
</wparent>
<wread>
<summary>
 
Included for backward compatibility. Use the Form Designer instead.
Determines whether or not the current or specified window is involved in the current READ.
</summary>
<returns>
Return value - Logical
</returns>
<remarks>
<br />
WREAD() returns true (.T.) if the specified window is participating in the current READ; false (.F.) is returned if the specified window isn't involved in the current READ or doesn't exist.<br />
<br />
You can have a window participate in a READ by:<br />
<br />
ulliIncluding the window's title in the READ WITH clause. Windows that typically aren't involved in a READ can participate in this way. Browse windows, memo- and text-editing windows, FoxPro system windows, and so on can participate in a READ./li
liCreating a control in the window. A READ can span multiple windows if you create controls in multiple windows and then issue READ. /li/ul

</remarks>
</wread>
<wrows>
<summary>
Returns the number of rows within the active or specified window.
</summary>
<param name="WindowName">

Specifies the window for which WROWS( ) returns the number of rows. In X#, you can also specify the name of a toolbar.
In X#, the value returned by WROWS( ) depends on the font specified for the window. Most fonts can be displayed in a wide variety of sizes, and some are proportionally spaced. A row corresponds to the height of the current font. For more information, see the Fonts Overview topic.   
You can specify the name of a system window (the Command window, the Data Session window, a Browse window, and so on) in WROWS( ) if the system window has been opened and is visible or hidden. If you specify the name of a system window that is closed, FoxPro generates an error message. The Debug window is an exception. Once the Debug window has been opened, its name can be included in WROWS( ) if it is visible, hidden, or closed.   
You can also include the empty string in WindowName to return the number of rows in the main X# window.   
The empty string can be used to specify the main X# window in functions such as WLCOL( ), WLROW( ), and WCOLS( ), which return window locations or sizes.
</param>
<returns>
Numeric
</returns>
<remarks>
If you don't specify a window name, the number of rows in the active output window is returned. If no window is active, the number of rows in the main X# window is returned.
</remarks>
</wrows>
<wtitle>
<summary>
Returns the title assigned to the active or specified window.
</summary>
<param name="WindowName">

Specifies a window whose title WTITLE( ) returns. The title assigned to the window with the TITLE clause is returned if you include the name of a user-defined window created with DEFINE WINDOW.
When you issue BROWSE WINDOW to open a Browse window in a user-defined window, WTITLE( ) returns the title of the user-defined window if the Browse window doesn't have a title. WTITLE( ) returns the title of the Browse window if the Browse window does have a title.   
You can also use the empty string for WindowName to specify the main X# window.
</param>
<returns>
Character
</returns>
<remarks>
WTITLE( ) can be used to return a window's title, which appears in the top border of the window. The title is returned for the active window if you omit WindowName. WTITLE( ) returns the empty string if the Debug, Trace or Command window is active or output is being directed to the main X# window.

<b>Window Names and Titles</b>   Names are assigned to user-defined windows, system windows, toolbars (in X#), and Browse windows in the following manner:
User-defined windows are assigned names when they are created with DEFINE WINDOW. There is a distinction between user-defined window names and titles. By default, user-defined windows don't have titles. If the TITLE clause is included when the window is created, the specified title appears in the top border of the window, but isn't the name of the window.
By default, each system window, which is part of the X# interface, derives its name from the title of the window. Examples of system windows include the Command window, the Data Session window, and the Trace window. In X#, each toolbar derives its name from the title of the toolbar.
Program and editing windows and the Label and Report Designer windows derive their names from the name of the file being created or modified.
A Browse window derives its name from the title of the window. The name and title of the Browse window is assigned in one of three ways: either by the default title assignment of the table alias, or by the window title (if any exists), or by the Browse title (if any exists).
By default, the Browse window name is the table alias.
To specify a system window and toolbar names in commands and functions, enclose the entire system window or toolbar name in quotation marks. For example, to hide the Report Controls toolbar in X#, issue the following command:
 <code language="X#">HIDE WINDOW "Report Controls"</code>

<b>Additional Notes on Window Names</b>   If you are unsure of the name assigned to a window, check the Window menu. All window names are listed at the bottom of the Window menu.
Two windows exist if you issue BROWSE WINDOW WindowName. The Browse window is a separate window and takes on the attributes of the specified user-defined window. If a window is active when you issue BROWSE and you don't include the WINDOW clause, the Browse window takes on the attributes of the active window. You can override this behavior by including NORMAL in BROWSE.
You can include window names that contain spaces in commands and functions that accept window names, such as MOVE WINDOW, DEACTIVATE WINDOW, and WONTOP( ), by specifying the part of the window name that begins with the first non-space character and continuing until the last non-space character is encountered.
For example, a Browse window with the name Invoice Entry can be moved with this command:
 <code language="X#">MOVE WINDOW invoice BY 1,1</code>
The names of user-defined windows cannot contain spaces, but the names of Browse and system windows can.
</remarks>
</wtitle>
<wvisible>
<summary>
Determines if the specified window has been activated and isn't hidden.
</summary>
<param name="WindowName">

Specifies the name of the window WVISIBLE( ) evaluates. In X#, you can also specify the name of a toolbar. You can also include the empty string in WindowName to specify the main X# window.
</param>
<returns>
Logical
</returns>
<remarks>
WVISIBLE( ) returns true (.T.) if the specified window is shown or activated and isn't hidden. Windows are shown and activated with SHOW WINDOW and ACTIVATE WINDOW.
WVISIBLE( ) returns false (.F.) if the window has not been activated, has been hidden with HIDE WINDOW, has been deactivated with DEACTIVATE WINDOW, or doesn't exist.
</remarks>
<example>
 <code language="X#">ACTIVATE WINDOW View
? WVISIBLE( "View" ) &amp;&amp; return .T.
DEACTIVATE WINDOW View
? WVISIBLE( "View" ) &amp;&amp; return .F. </code>
</example>
</wvisible>
<xmltocursor>
<summary>
Converts XML text into a X# cursor or table.
</summary>
<param name="eExpression">

Specifies the XML text or an expression that evaluates to valid XML data. The eExpression parameter can be a X# memory variable, memo field contents, the return from an HTTP request, the return result from a SOAP method call, XML from the XMLDOM, or an ADO stream. 
XMLTOCURSOR( ) generates an error if eExpression is not found or if eExpression does not parse to valid XML.

</param>
<param name="cXMLFile">

Specifies the name, and, optionally, the path of a physical XML file that resides on your local computer or network. 
If you do not specify a path, X# searches the path along the X# directory for the XML file. 

</param>
<param name="cCursorName">

Specifies the name of the cursor to store the result and creates the cursor in the current work area. 
If the cursor name already exists or is open, X# closes the cursor and creates a new one in an unused work area. If you omit or pass an empty string ("") for cCursorName, X# creates a cursor named "XMLRESULT" for returning the result.
If cCursorName contains data and nFlags is set to 8192, X# appends the data being imported from the XML file to the existing table or cursor. The table or cursor must be open or in use. If cCursorName is an empty string (""), X# imports XML into the table or cursor that is open in the current work area. 

</param>
<param name="nFlags">

Specifies how XMLSource eExpression is handled in <b>XMLTOCURSOR( )</b>. The following table describes the values for nFlags.
0
0000
(Default) Treats the first parameter as a string containing XML data. 
4
0100
Preserves white space in data and overrides the xml:space attribute of the XML data.
512
01000000000
Specifies that the first parameter, either an eExpression or a cXMLFile, is a string containing the name and path of an XML data file. 
1024
10000000000
NOCPTRANS – Creates <b>Character</b> and <b>Memo</b> fields in the resultant cursor with the NOCPTRANS option and inserts the text or XML values in the incoming elements into the <b>Character</b> or <b>Memo</b> field on an untranslated, byte-for-byte basis. 
When used with flag 1024, <b>XMLTOCURSOR( )</b> returns a string padded with trailing spaces equal to the actual string, that is, a string twice the length.
2048
100000000000
Use when the imported schema has an XML schema definition (XSD) schema containing decimal data type with restrictions, or facets, of totalDigits="19" and fractionDigits="4." 
XSD data type values are mapped to the X# <b>Currency</b> data type in the resulting cursor.
4096
1000000000000   
Disables <b>base64</b> decoding. 
In X#, base64 encoding is intended for encoding only binary data. 
8192
1100000000
Specifies that cCursorName is the name or alias of an existing table or cursor and imports the data from the specified XML file into an existing table or predefined cursor. 
If cCursorName contains data, the data imported from the XML file is appended to the existing data. If cCursorName is an empty string (""), the data from the XML file is imported into the table or cursor in the current work area.
Setting nFlags to 8192 can be useful when an XML schema is not available or not practical for use.
32768
0x8000
Indicates that a code page should be used.
65536
0x10000
Maps XML Char fields to native Fox Varchar fields. If not specified, XML Char fields are mapped to Fox Character fields.
131072
0x20000
Maps XML base64Binary fields to native Fox Varbinary fields if less than 255 bytes or Blob fields if greater than this length. If not specified, XML base64Binary fields are mapped to Fox Memo fields.
When you use flag 8192, be aware of the following:   
You must make sure the table schema matches the incoming XML elements in the appropriate manner. X# enforces the data types in cCursorName as described in the Data Type Matching table in this topic but makes no other assumptions about data types. Attempting to import incompatible values generates the appropriate message. 
If the XML contains or references a schema, and the data types in the schema conflict with the data types of the cursor or table, the data types in the cursor or table are used.
Element names in the XML file are mapped to the column names in cCursorName. In addition, X# imports only data from the element names in the XML file that match the column names in cCusorName.
The cursor or table can have fewer columns than those in the XML file, but it must have at least one matching column. The cursor or table can have additional columns that do not correspond to an element in the XML file.
If the table contains autoincrementing fields, <b>XMLTOCURSOR( )</b> fails if <b>AUTOINCERROR</b> is set to <b>ON</b>. Setting <b>AUTOINCERROR</b> to <b>OFF</b> or turning off autoincrementing in the target table by using <b>CURSORSETPROP( )</b> allows <b>XMLTOCURSOR( )</b> to succeed. The target table's autoincrementing field or fields are incremented according to the values specified, and the values in the source table are not copied. 
The following table describes data type matching restrictions when setting nFlags to 8192.
<b>Character</b>, <b>Character</b> (Binary), <b>Memo</b>, <b>Memo</b> (Binary)
Accepts any data but truncates any data exceeding the length of a <b>Character</b> column.
Accepts numeric data within accepted range of the <b>Currency</b> type but truncates numbers outside this range.
<b>Date</b>
Accepts XML format date and dateTime values. 
X# converts the XML date and dateTime formats to the corresponding X# date. X# preserves only the M/D/Y portion of the XML date or dateTime value.
<b>DateTime</b>
X# converts the XML date and dateTime formats to the corresponding X# date and discards precision beyond the extent supported by X#.
<b>Double</b>
Accepts numeric data within the accepted range of the <b>Double</b> type but truncates numbers outside this range.
<b>Integer</b>
Accepts integer data within the accepted range of the <b>Integer</b> type but truncates numbers outside this range.
<b>Logical</b>
Accepts the values True, .T., 1, False, .F., and 0.
<b>Numeric</b>, <b>Float</b>
Accepts numeric data with or without decimals but truncates numbers outside the accepted range for these types according to X# rules or replaces with the numeric overflow indicator ("*************").
</param>
<returns>
Numeric data type. <b>XMLTOCURSOR( )</b> returns the number of records created.
</returns>
<remarks>
You can use <b>XMLTOCURSOR( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported because the <b>_VFP</b> system variable is not supported in the OLE DB Provider.
To use the X# OLE DB Provider with <b>XMLTOCURSOR( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.

<b>XMLTOCURSOR( )</b> generates a syntax error for record lengths greater than approximately 160 columns. The exact number of columns that cause an error depends on the length of the column names.

<b>XMLTOCURSOR( ) </b>does not use the <b>Varchar</b> type when creating a cursor from an XML document. However, <b>XMLTOCURSOR( )</b> supports appending data into an existing cursor with <b>Varchar</b> fields.
When calling <b>XMLTOCURSOR( )</b> in append mode, X# adds an empty row if no XML element name matches any table or cursor column.

<b>XMLTOCURSOR( )</b> converts <b>Decimal</b> data type to <b>Numeric</b> 20,19 (width, precision). In versions prior to X# 8.0, <b>Decimal</b> mapped to <b>Numeric</b> 8,0.

<b>Numeric Overflow Conditions</b>   <b>XMLTOCURSOR( )</b> imports XML data containing X# numeric overflow conditions, for example, "*******", in place of a numeric or integer value. If a schema is provided, X# creates the correct data type in the resulting cursor but changes the overflow from asterisk (*) characters to 0.0 or 0 values. Therefore, the XML parser used by <b>XMLTOCURSOR( )</b> does not throw an error as a result of character values stored in a decimal type element.
For more information about converting XML to X# data, see Converting Between XML and X# Data.
</remarks>
</xmltocursor>
<xmlupdategram>
<summary>
Mirrors changes made in a buffered table or cursor in an XML UpdateGram and returns a character string that contains the UpdateGram. 
An XML UpdateGram represents the before and after conditions of the changed portion of a X# table or cursor. Through additional processes, you can use an UpdateGram to commit these changes to the data represented by the XML UpdateGram document.
To use <b>XMLUPDATEGRAM( )</b>, you must use <b>SET MULTILOCKS ON</b> and enable table buffering.
Before calling <b>XMLUPDATEGRAM( )</b>, you should specify the key field list by calling <b>CURSORSETPROP( )</b> with the <b>KeyFieldList</b> property against existing cursors and tables. If you do not specify key fields, both the before and after representations contains all the fields in the table. If you specify one or more key fields, only those fields appear in the before section.
</summary>
<param name="cAliasList">

Specifies a comma-separated list of open tables or cursors, listed either by name or work area numbers in any combination, to include in the XML UpdateGram. If you specify no value or an empty string ("") for cAliasList, X# uses all open tables and cursors in the current data session that contain buffered changes.

</param>
<param name="nFlags">

Specifies whether to return a formatted file. The following table lists the additive flags for nFlags.
nFlag
0
0000
(Default) Use UTF-8 formatted XML. 
1
0001
Use unformatted, for example, continuous string XML.
2
0010
Enclose empty elements with both open and closing elements, for example, &lt;cc04&gt;&lt;cc04/&gt;.
0100
Preserve white space in fields.
1000
Wrap Memo fields in CDATA sections.
16
10000
Output encoding.
32
100000
32768
none
Indicates that a code page should be used.
When output encoding is UTF-8 (default), the XML Declaration does not contain an Encoding= attribute (no encoding attribute = UTF-8).
When output encoding is set to default to the code page of the cursor or table, the encoding attribute will be written according to the following table.   
Encoding flags are set by combining bits 4 and 5 (0010000).
+0
(Default) Windows 1252 
+16
Set output encoding attribute to the code page of the cursor.
+32
Set output encoding attribute to UTF-8 (no character translation).
+48
11
Set output encoding attribute to UTF-8 and translate double-byte characters to UTF-8.

</param>
<param name="cSchemaLocation">

Specifies the name and location of the mapping schema, if it exists. 
You must supply the mapping schema.
For example, suppose you pass the a schema called codemySchema.xsd/code to cSchemaLocation, the UpdateGram created contains a mapping schema attirbute as it appears in the following XML:   
 <code language="X#">&lt;ROOT xmlns:updg="urn:schemas-microsoft-com:xml-updategram"&gt;
&lt;updg:sync mapping-schema="mySchema.xsd" &gt;
&lt;updg:before&gt;</code>
</param>
<returns>
Character data type. <b>XMLUPDATEGRAM( )</b> returns a character string that contains the XML UpdateGram.
</returns>
<remarks>
You can use <b>XMLUPDATEGRAM( )</b> with the OLE DB Provider for X#. However, the <b>_VFP</b> <b>VFPXMLProgID</b> property is not supported because the <b>_VFP</b> system variable is not supported in the OLD EB Provider.
To use the X# OLE DB Provider with <b>XMLUPDATEGRAM( )</b>, you must install MSXML 3.0 on the computer with the OLE DB Provider.
SQL Server and Visual Studio support the DiffGram format for updating XML. However, SQL XML requires a mapping schema to support this format. Therefore, <b>XMLUPDATEGRAM( )</b> does not support this format.
To avoid possible errors generated by <b>XMLUPDATEGRAM( )</b> on tables containing <b>Memo</b> or <b>General</b> fields, use the <b>CURSORSETPROP( )</b> function. The following example shows how to include memo data in an XML UpdateGram by setting the <b>KeyFieldList</b> property using <b>CURSORSETPROP( )</b>:
 <code language="X#">SET MULTILOCKS ON
CREATE CURSOR Test (mField M, cField I AUTOINC)
INSERT INTO Test (mField) VALUES ("123456789")
INSERT INTO Test (mField) VALUES ("23456789")
INSERT INTO Test (mField) VALUES ("3456789")
INSERT INTO Test (mField) VALUES ("456789")
CURSORSETPROP("Buffering",5)
CURSORSETPROP("keyfieldlist",'cField')
UPDATE Test SET mField = "XXXXXXX" WHERE cField &lt; 3
STRTOFILE(XMLUPDATEGRAM(),'xmlupdate.txt')
MODIFY FILE xmlupdate.txt
RETURN</code>
To write memo data in the XML UpdateGram to SQL Server, you must use an explicit schema on the SQL Server and reference the schema in the XML UpdateGram. 
Unlike the <b>CURSORTOXML( )</b> function, <b>XMLUPDATEGRAM( )</b> disregards <b>SET FIELDS</b> statements and reads from the underlying cursor directly. To change the table structure before calling<b> XMLUPDATEGRAM( )</b>, you must copy the data into a new cursor. For example, to change a <b>Numeric</b> field to a <b>Currency</b> field, the following example uses a SQL <b>SELECT</b> statement to create a new cursor and uses that cursor with <b>XMLUPDATEGRAM( )</b>. The example makes the Total_Price field a currency field, enables buffering with <b>CURSORSETPROP( )</b>, adds sales tax with the <b>REPLACE</b> command, and creates an XML UpdateGram using the <b>XMLUPDATEGRAM( )</b> function.
 <code language="X#">SELECT OrderID, CustID, NTOM(Total_Price) as Total_Price;
FROM Orders INTO CURSOR New_Orders READWRITE
CURSORSETPROP("Buffering", 5, "New_Orders")
REPLACE Total_Price WITH (Total_Price * 1.083)
cXMLUpdg = XMLUPDATEGRAM("New_Orders")      </code>
When using flag 32768, the flag's 16 and 32 settings can affect which code page is applied depending on the type of data you are writing to XML. The following tables show the possible combinations of settings and the code page each combination applies.
For XML documents written with the 32768 flag set, the following code pages are applied.
Flag 16
Flag 32
Flag 32768 is Set
Not set
Not set
XML documents: Window-1252.
Unicode data: code page 1252.
Character data: default code page, unless a field is marked as <b>NOCPTRANS</b>.
True (.T)
Not set
XML documents: Plus-<b>CodePage</b> property of the cursor. If XMLField <b>CodePage</b> property is greater than zero (0) and it doesn’t match the cursor’s code page, an error is reported.
Unicode data: the <b>Code page</b> property of the cursor object.
Character data: none. Raw data from the X# tables (.dbf) are used instead.
Not set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: Default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
Set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: default code page unless a field is marked as <b>NOCPTRANS</b>, in which case the data are translated to UTF-8 using the <b>SYS(3005)</b> setting.
For XML documents written without setting the 32768 flag, the following code pages are applied.
Flag 16
Flag 32
Without the 32768 flag
Not set
Not set
XML documents: Window-1252.
Unicode data: code page 1252.
Character data: default code page unless a field is marked as <b>NOCPTRANS</b>.
True (.T)
Not set
XML documents: <b>CodePage</b> property of the cursor.
Character data: none. Raw data from the X# tables (.dbf) are used instead.
Unicode data: code page property of the cursor object.
Not set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case no additional character translation to UTF-8 occurs.
Set
Set
XML documents: UTF-8 code page.
Unicode data: UTF-8 code page.
Character data: default code page unless field is marked as <b>NOCPTRANS</b>, in which case, they are translated to UTF-8 using code page for the current <b>SYS(3005)</b> setting.
For more information about converting XML to X# data, see Converting Between XML and X# Data.
</remarks>
</xmlupdategram>
<year>
<summary>
Returns the year from the specified date or datetime expression.
</summary>
<param name="dExpression">

Specifies a date expression from which YEAR( ) returns the year. dExpression can be a function that returns a date, or a Date-type memory variable, array element, or field. It can also be a literal date string, such as {^1998-06-06}.

</param>
<param name="tExpression">

Specifies a datetime expression from which YEAR( ) returns the year.
</param>
<returns>
Numeric
</returns>
<remarks>
YEAR( ) always returns the year with the century. The CENTURY setting (ON or OFF) doesn't affect the returned value.
</remarks>
<example>
 <code language="X#">CLEAR
? YEAR(DATE( ))</code>
</example>
</year>
</Runtimefunctions>
