//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.1-SNAPSHOT
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from F:\Projects\XSharp\XSharp\src\Compiler\XSharpCodeAnalysis\Parser\XSharpLexer.g4 by ANTLR 4.6.1-SNAPSHOT

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace LanguageService.CodeAnalysis.XSharp.SyntaxParser {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.1-SNAPSHOT")]
[System.CLSCompliant(false)]
public partial class XSharpLexer : Lexer {
	public const int
		FIRST_KEYWORD=1, ACCESS=2, ALIGN=3, AS=4, ASPEN=5, ASSIGN=6, BEGIN=7, 
		BREAK=8, CALLBACK=9, CASE=10, CAST=11, CLASS=12, CLIPPER=13, DECLARE=14, 
		DEFINE=15, DIM=16, DLL=17, DLLEXPORT=18, DO=19, DOWNTO=20, ELSE=21, ELSEIF=22, 
		END=23, ENDCASE=24, ENDDO=25, ENDIF=26, EXIT=27, EXPORT=28, FASTCALL=29, 
		FIELD=30, FOR=31, FUNC=32, FUNCTION=33, GLOBAL=34, HIDDEN=35, IF=36, IIF=37, 
		INHERIT=38, INIT1=39, INIT2=40, INIT3=41, INSTANCE=42, IS=43, IN=44, LOCAL=45, 
		LOOP=46, MEMBER=47, MEMVAR=48, METHOD=49, NAMEOF=50, NEXT=51, OTHERWISE=52, 
		PARAMETERS=53, PASCAL=54, PRIVATE=55, PROC=56, PROCEDURE=57, PROTECTED=58, 
		PUBLIC=59, RECOVER=60, RETURN=61, SELF=62, SEQUENCE=63, SIZEOF=64, STATIC=65, 
		STEP=66, STRICT=67, SUPER=68, THISCALL=69, TO=70, TYPEOF=71, UNION=72, 
		UPTO=73, USING=74, WHILE=75, WINCALL=76, CATCH=77, FINALLY=78, THROW=79, 
		FIRST_POSITIONAL_KEYWORD=80, ABSTRACT=81, ANSI=82, AUTO=83, CASTCLASS=84, 
		CONSTRUCTOR=85, CONST=86, DEFAULT=87, DELEGATE=88, DESTRUCTOR=89, ENUM=90, 
		EVENT=91, EXPLICIT=92, FOREACH=93, GET=94, IMPLEMENTS=95, IMPLICIT=96, 
		IMPLIED=97, INITONLY=98, INTERFACE=99, INTERNAL=100, LOCK=101, NAMESPACE=102, 
		NEW=103, OPERATOR=104, OUT=105, PARTIAL=106, PROPERTY=107, REPEAT=108, 
		SCOPE=109, SEALED=110, SET=111, STRUCTURE=112, TRY=113, UNICODE=114, UNTIL=115, 
		VALUE=116, VIRTUAL=117, VOSTRUCT=118, ADD=119, ARGLIST=120, ASCENDING=121, 
		ASSEMBLY=122, ASYNC=123, ASTYPE=124, AWAIT=125, BY=126, CHECKED=127, DESCENDING=128, 
		EQUALS=129, EXTERN=130, FIXED=131, FROM=132, GROUP=133, INTO=134, JOIN=135, 
		LET=136, NOP=137, MODULE=138, OF=139, ON=140, ORDERBY=141, OVERRIDE=142, 
		PARAMS=143, REMOVE=144, SELECT=145, SWITCH=146, UNCHECKED=147, UNSAFE=148, 
		VAR=149, VOLATILE=150, WHERE=151, YIELD=152, LAST_POSITIONAL_KEYWORD=153, 
		FIRST_TYPE=154, ARRAY=155, BYTE=156, CODEBLOCK=157, DATE=158, DWORD=159, 
		FLOAT=160, INT=161, LOGIC=162, LONGINT=163, OBJECT=164, PSZ=165, PTR=166, 
		REAL4=167, REAL8=168, REF=169, SHORTINT=170, STRING=171, SYMBOL=172, USUAL=173, 
		VOID=174, WORD=175, CHAR=176, INT64=177, UINT64=178, DYNAMIC=179, DECIMAL=180, 
		DATETIME=181, LAST_TYPE=182, UDC_KEYWORD=183, SCRIPT_REF=184, SCRIPT_LOAD=185, 
		ASSIGNMENT=186, DEFERRED=187, ENDCLASS=188, EXPORTED=189, FREEZE=190, 
		FINAL=191, INLINE=192, INTRODUCE=193, NOSAVE=194, READONLY=195, SHARING=196, 
		SHARED=197, SYNC=198, LAST_KEYWORD=199, FIRST_NULL=200, NIL=201, NULL=202, 
		NULL_ARRAY=203, NULL_CODEBLOCK=204, NULL_DATE=205, NULL_OBJECT=206, NULL_PSZ=207, 
		NULL_PTR=208, NULL_STRING=209, NULL_SYMBOL=210, LAST_NULL=211, FIRST_OPERATOR=212, 
		LT=213, LTE=214, GT=215, GTE=216, EQ=217, EEQ=218, SUBSTR=219, NEQ=220, 
		NEQ2=221, INC=222, DEC=223, PLUS=224, MINUS=225, DIV=226, MOD=227, EXP=228, 
		LSHIFT=229, RSHIFT=230, TILDE=231, MULT=232, QQMARK=233, QMARK=234, AND=235, 
		OR=236, NOT=237, VO_NOT=238, VO_AND=239, VO_OR=240, VO_XOR=241, ASSIGN_OP=242, 
		ASSIGN_ADD=243, ASSIGN_SUB=244, ASSIGN_EXP=245, ASSIGN_MUL=246, ASSIGN_DIV=247, 
		ASSIGN_MOD=248, ASSIGN_BITAND=249, ASSIGN_BITOR=250, ASSIGN_LSHIFT=251, 
		ASSIGN_RSHIFT=252, ASSIGN_XOR=253, LOGIC_AND=254, LOGIC_OR=255, LOGIC_NOT=256, 
		LOGIC_XOR=257, LPAREN=258, RPAREN=259, LCURLY=260, RCURLY=261, LBRKT=262, 
		RBRKT=263, COLON=264, COMMA=265, PIPE=266, AMP=267, ADDROF=268, ALIAS=269, 
		DOT=270, COLONCOLON=271, BACKSLASH=272, ELLIPSIS=273, LAST_OPERATOR=274, 
		FIRST_CONSTANT=275, FALSE_CONST=276, TRUE_CONST=277, HEX_CONST=278, BIN_CONST=279, 
		INT_CONST=280, DATE_CONST=281, REAL_CONST=282, INVALID_NUMBER=283, SYMBOL_CONST=284, 
		CHAR_CONST=285, STRING_CONST=286, ESCAPED_STRING_CONST=287, INTERPOLATED_STRING_CONST=288, 
		INCOMPLETE_STRING_CONST=289, LAST_CONSTANT=290, PP_FIRST=291, PP_COMMAND=292, 
		PP_DEFINE=293, PP_ELSE=294, PP_ENDIF=295, PP_ENDREGION=296, PP_ERROR=297, 
		PP_IFDEF=298, PP_IFNDEF=299, PP_INCLUDE=300, PP_LINE=301, PP_REGION=302, 
		PP_TRANSLATE=303, PP_UNDEF=304, PP_WARNING=305, PP_LAST=306, MACRO=307, 
		UDCSEP=308, ID=309, KWID=310, PRAGMA=311, DOC_COMMENT=312, SL_COMMENT=313, 
		ML_COMMENT=314, LINE_CONT=315, LINE_CONT_OLD=316, SEMI=317, WS=318, NL=319, 
		EOS=320, UNRECOGNIZED=321;
	public const int
		XMLDOCCHANNEL=2, DEFOUTCHANNEL=3, PREPROCESSORCHANNEL=4, PRAGMACHANNEL=5;
	public static string[] modeNames = {
		"DEFAULT_MODE"
	};

	public static readonly string[] ruleNames = {
		"UNRECOGNIZED"
	};


	public XSharpLexer(ICharStream input)
		: base(input)
	{
		_interp = new LexerATNSimulator(this,_ATN);
	}

	private static readonly string[] _LiteralNames = {
	};
	private static readonly string[] _SymbolicNames = {
		null, "FIRST_KEYWORD", "ACCESS", "ALIGN", "AS", "ASPEN", "ASSIGN", "BEGIN", 
		"BREAK", "CALLBACK", "CASE", "CAST", "CLASS", "CLIPPER", "DECLARE", "DEFINE", 
		"DIM", "DLL", "DLLEXPORT", "DO", "DOWNTO", "ELSE", "ELSEIF", "END", "ENDCASE", 
		"ENDDO", "ENDIF", "EXIT", "EXPORT", "FASTCALL", "FIELD", "FOR", "FUNC", 
		"FUNCTION", "GLOBAL", "HIDDEN", "IF", "IIF", "INHERIT", "INIT1", "INIT2", 
		"INIT3", "INSTANCE", "IS", "IN", "LOCAL", "LOOP", "MEMBER", "MEMVAR", 
		"METHOD", "NAMEOF", "NEXT", "OTHERWISE", "PARAMETERS", "PASCAL", "PRIVATE", 
		"PROC", "PROCEDURE", "PROTECTED", "PUBLIC", "RECOVER", "RETURN", "SELF", 
		"SEQUENCE", "SIZEOF", "STATIC", "STEP", "STRICT", "SUPER", "THISCALL", 
		"TO", "TYPEOF", "UNION", "UPTO", "USING", "WHILE", "WINCALL", "CATCH", 
		"FINALLY", "THROW", "FIRST_POSITIONAL_KEYWORD", "ABSTRACT", "ANSI", "AUTO", 
		"CASTCLASS", "CONSTRUCTOR", "CONST", "DEFAULT", "DELEGATE", "DESTRUCTOR", 
		"ENUM", "EVENT", "EXPLICIT", "FOREACH", "GET", "IMPLEMENTS", "IMPLICIT", 
		"IMPLIED", "INITONLY", "INTERFACE", "INTERNAL", "LOCK", "NAMESPACE", "NEW", 
		"OPERATOR", "OUT", "PARTIAL", "PROPERTY", "REPEAT", "SCOPE", "SEALED", 
		"SET", "STRUCTURE", "TRY", "UNICODE", "UNTIL", "VALUE", "VIRTUAL", "VOSTRUCT", 
		"ADD", "ARGLIST", "ASCENDING", "ASSEMBLY", "ASYNC", "ASTYPE", "AWAIT", 
		"BY", "CHECKED", "DESCENDING", "EQUALS", "EXTERN", "FIXED", "FROM", "GROUP", 
		"INTO", "JOIN", "LET", "NOP", "MODULE", "OF", "ON", "ORDERBY", "OVERRIDE", 
		"PARAMS", "REMOVE", "SELECT", "SWITCH", "UNCHECKED", "UNSAFE", "VAR", 
		"VOLATILE", "WHERE", "YIELD", "LAST_POSITIONAL_KEYWORD", "FIRST_TYPE", 
		"ARRAY", "BYTE", "CODEBLOCK", "DATE", "DWORD", "FLOAT", "INT", "LOGIC", 
		"LONGINT", "OBJECT", "PSZ", "PTR", "REAL4", "REAL8", "REF", "SHORTINT", 
		"STRING", "SYMBOL", "USUAL", "VOID", "WORD", "CHAR", "INT64", "UINT64", 
		"DYNAMIC", "DECIMAL", "DATETIME", "LAST_TYPE", "UDC_KEYWORD", "SCRIPT_REF", 
		"SCRIPT_LOAD", "ASSIGNMENT", "DEFERRED", "ENDCLASS", "EXPORTED", "FREEZE", 
		"FINAL", "INLINE", "INTRODUCE", "NOSAVE", "READONLY", "SHARING", "SHARED", 
		"SYNC", "LAST_KEYWORD", "FIRST_NULL", "NIL", "NULL", "NULL_ARRAY", "NULL_CODEBLOCK", 
		"NULL_DATE", "NULL_OBJECT", "NULL_PSZ", "NULL_PTR", "NULL_STRING", "NULL_SYMBOL", 
		"LAST_NULL", "FIRST_OPERATOR", "LT", "LTE", "GT", "GTE", "EQ", "EEQ", 
		"SUBSTR", "NEQ", "NEQ2", "INC", "DEC", "PLUS", "MINUS", "DIV", "MOD", 
		"EXP", "LSHIFT", "RSHIFT", "TILDE", "MULT", "QQMARK", "QMARK", "AND", 
		"OR", "NOT", "VO_NOT", "VO_AND", "VO_OR", "VO_XOR", "ASSIGN_OP", "ASSIGN_ADD", 
		"ASSIGN_SUB", "ASSIGN_EXP", "ASSIGN_MUL", "ASSIGN_DIV", "ASSIGN_MOD", 
		"ASSIGN_BITAND", "ASSIGN_BITOR", "ASSIGN_LSHIFT", "ASSIGN_RSHIFT", "ASSIGN_XOR", 
		"LOGIC_AND", "LOGIC_OR", "LOGIC_NOT", "LOGIC_XOR", "LPAREN", "RPAREN", 
		"LCURLY", "RCURLY", "LBRKT", "RBRKT", "COLON", "COMMA", "PIPE", "AMP", 
		"ADDROF", "ALIAS", "DOT", "COLONCOLON", "BACKSLASH", "ELLIPSIS", "LAST_OPERATOR", 
		"FIRST_CONSTANT", "FALSE_CONST", "TRUE_CONST", "HEX_CONST", "BIN_CONST", 
		"INT_CONST", "DATE_CONST", "REAL_CONST", "INVALID_NUMBER", "SYMBOL_CONST", 
		"CHAR_CONST", "STRING_CONST", "ESCAPED_STRING_CONST", "INTERPOLATED_STRING_CONST", 
		"INCOMPLETE_STRING_CONST", "LAST_CONSTANT", "PP_FIRST", "PP_COMMAND", 
		"PP_DEFINE", "PP_ELSE", "PP_ENDIF", "PP_ENDREGION", "PP_ERROR", "PP_IFDEF", 
		"PP_IFNDEF", "PP_INCLUDE", "PP_LINE", "PP_REGION", "PP_TRANSLATE", "PP_UNDEF", 
		"PP_WARNING", "PP_LAST", "MACRO", "UDCSEP", "ID", "KWID", "PRAGMA", "DOC_COMMENT", 
		"SL_COMMENT", "ML_COMMENT", "LINE_CONT", "LINE_CONT_OLD", "SEMI", "WS", 
		"NL", "EOS", "UNRECOGNIZED"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "XSharpLexer.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string[] ModeNames { get { return modeNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x2\x143\a\b\x1\x4"+
		"\x2\t\x2\x3\x2\x3\x2\x2\x2\x2\x3\x3\x2\x143\x3\x2\x2\x6\x2\x3\x3\x2\x2"+
		"\x2\x3\x5\x3\x2\x2\x2\x5\x6\v\x2\x2\x2\x6\x4\x3\x2\x2\x2\x3\x2\x2";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace LanguageService.CodeAnalysis.XSharp.SyntaxParser
