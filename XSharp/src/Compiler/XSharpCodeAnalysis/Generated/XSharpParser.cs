//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.5.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Projects\XSharpDev\XSharp\\src\Compiler\XSharpCodeAnalysis\Parser\XSharp.g4 by ANTLR 4.5.1

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591

namespace LanguageService.CodeAnalysis.XSharp.SyntaxParser {
using System;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.5.1")]
[System.CLSCompliant(false)]
public partial class XSharpParser : Parser {
	public const int
		ABSTRACT=1, ACCESS=2, ALIGN=3, AS=4, ASSIGN=5, AUTO=6, BEGIN=7, BREAK=8, 
		CASE=9, CAST=10, CATCH=11, CLASS=12, CLIPPER=13, CONSTRUCTOR=14, CONST=15, 
		DELEGATE=16, DESTRUCTOR=17, DIM=18, DLL=19, DO=20, DOWNTO=21, ELSE=22, 
		ELSEIF=23, END=24, ENDCASE=25, ENDDO=26, ENDIF=27, ENUM=28, EVENT=29, 
		EXIT=30, EXPLICIT=31, EXPORT=32, FASTCALL=33, FIELD=34, FINALLY=35, FOR=36, 
		FOREACH=37, FUNCTION=38, GET=39, GLOBAL=40, HIDDEN=41, IF=42, IIF=43, 
		IMPLEMENTS=44, IMPLICIT=45, IMPLIED=46, INHERIT=47, INITONLY=48, INSTANCE=49, 
		INTERFACE=50, INTERNAL=51, IN=52, IS=53, LOCAL=54, LOCK=55, LOOP=56, MEMBER=57, 
		METHOD=58, NAMESPACE=59, NEW=60, NEXT=61, OPERATOR=62, OTHERWISE=63, OUT=64, 
		PARTIAL=65, PASCAL=66, PRIVATE=67, PROCEDURE=68, PROTECTED=69, PROPERTY=70, 
		PUBLIC=71, RECOVER=72, REPEAT=73, RETURN=74, SCOPE=75, SEALED=76, SELF=77, 
		SEQUENCE=78, SET=79, SIZEOF=80, STATIC=81, STEP=82, STRICT=83, STRUCTURE=84, 
		SUPER=85, THISCALL=86, THROW=87, TO=88, TRY=89, TYPEOF=90, UNION=91, UNTIL=92, 
		UPTO=93, USING=94, VIRTUAL=95, WHILE=96, ARRAY=97, BYTE=98, CHAR=99, CODEBLOCK=100, 
		DATE=101, DWORD=102, FLOAT=103, INT=104, INT64=105, LOGIC=106, LONGINT=107, 
		OBJECT=108, PSZ=109, PTR=110, REAL4=111, REAL8=112, REF=113, SHORTINT=114, 
		STRING=115, SYMBOL=116, USUAL=117, UINT64=118, VOID=119, WORD=120, NIL=121, 
		NULL=122, NULL_ARRAY=123, NULL_CODEBLOCK=124, NULL_DATE=125, NULL_OBJECT=126, 
		NULL_PSZ=127, NULL_PTR=128, NULL_STRING=129, NULL_SYMBOL=130, FALSE_CONST=131, 
		TRUE_CONST=132, LOGIC_AND=133, LOGIC_OR=134, LOGIC_NOT=135, LOGIC_XOR=136, 
		INC=137, DEC=138, NOT=139, AND=140, OR=141, PLUS=142, MINUS=143, DIV=144, 
		MOD=145, EXP=146, LSHIFT=147, RSHIFT=148, TILDE=149, MULT=150, ASSIGN_OP=151, 
		ASSIGN_ADD=152, ASSIGN_SUB=153, ASSIGN_EXP=154, ASSIGN_MUL=155, ASSIGN_DIV=156, 
		ASSIGN_MOD=157, ASSIGN_BITAND=158, ASSIGN_BITOR=159, ASSIGN_LSHIFT=160, 
		ASSIGN_RSHIFT=161, ASSIGN_XOR=162, LT=163, LTE=164, GT=165, GTE=166, EQ=167, 
		EEQ=168, SUBSTR=169, NEQ=170, LPAREN=171, RPAREN=172, LCURLY=173, RCURLY=174, 
		LBRKT=175, RBRKT=176, COLON=177, COMMA=178, PIPE=179, AMP=180, ADDROF=181, 
		ALIAS=182, DOT=183, HEX_CONST=184, BIN_CONST=185, INT_CONST=186, DATE_CONST=187, 
		REAL_CONST=188, SYMBOL_CONST=189, STRING_CONST=190, WS=191, SL_COMMENT=192, 
		NL=193, ID=194, UNRECOGNIZED=195;
	public const int
		RULE_source = 0, RULE_entity = 1, RULE_function = 2, RULE_procedure = 3, 
		RULE_parameterList = 4, RULE_parameter = 5, RULE_statementBlock = 6, RULE_statement = 7, 
		RULE_conditionalBlock = 8, RULE_catchBlock = 9, RULE_expression = 10, 
		RULE_expressionList = 11, RULE_argumentList = 12, RULE_argument = 13, 
		RULE_iif = 14, RULE_name = 15, RULE_genericArgumentList = 16, RULE_identifierName = 17, 
		RULE_datatype = 18, RULE_arrayRank = 19, RULE_typeName = 20, RULE_literalArray = 21, 
		RULE_codeblock = 22, RULE_codeblockParamList = 23, RULE_identifier = 24, 
		RULE_nativeType = 25, RULE_literalValue = 26, RULE_accessModifier = 27, 
		RULE_eos = 28, RULE_eof = 29;
	public static readonly string[] ruleNames = {
		"source", "entity", "function", "procedure", "parameterList", "parameter", 
		"statementBlock", "statement", "conditionalBlock", "catchBlock", "expression", 
		"expressionList", "argumentList", "argument", "iif", "name", "genericArgumentList", 
		"identifierName", "datatype", "arrayRank", "typeName", "literalArray", 
		"codeblock", "codeblockParamList", "identifier", "nativeType", "literalValue", 
		"accessModifier", "eos", "eof"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, "'++'", "'--'", "'!'", "'&&'", "'||'", "'+'", 
		"'-'", "'/'", "'%'", "'^'", "'<<'", "'>>'", "'~'", "'*'", "':='", "'+='", 
		"'-='", "'^='", "'*='", "'/='", "'%='", "'&='", "'|='", "'<<='", "'>>='", 
		"'~='", "'<'", "'<='", "'>'", "'>='", "'='", "'=='", "'$'", null, "'('", 
		"')'", "'{'", "'}'", "'['", "']'", "':'", "','", "'|'", "'&'", "'@'", 
		"'->'", "'.'", null, null, null, null, null, null, null, null, null, "'\n'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "ABSTRACT", "ACCESS", "ALIGN", "AS", "ASSIGN", "AUTO", "BEGIN", 
		"BREAK", "CASE", "CAST", "CATCH", "CLASS", "CLIPPER", "CONSTRUCTOR", "CONST", 
		"DELEGATE", "DESTRUCTOR", "DIM", "DLL", "DO", "DOWNTO", "ELSE", "ELSEIF", 
		"END", "ENDCASE", "ENDDO", "ENDIF", "ENUM", "EVENT", "EXIT", "EXPLICIT", 
		"EXPORT", "FASTCALL", "FIELD", "FINALLY", "FOR", "FOREACH", "FUNCTION", 
		"GET", "GLOBAL", "HIDDEN", "IF", "IIF", "IMPLEMENTS", "IMPLICIT", "IMPLIED", 
		"INHERIT", "INITONLY", "INSTANCE", "INTERFACE", "INTERNAL", "IN", "IS", 
		"LOCAL", "LOCK", "LOOP", "MEMBER", "METHOD", "NAMESPACE", "NEW", "NEXT", 
		"OPERATOR", "OTHERWISE", "OUT", "PARTIAL", "PASCAL", "PRIVATE", "PROCEDURE", 
		"PROTECTED", "PROPERTY", "PUBLIC", "RECOVER", "REPEAT", "RETURN", "SCOPE", 
		"SEALED", "SELF", "SEQUENCE", "SET", "SIZEOF", "STATIC", "STEP", "STRICT", 
		"STRUCTURE", "SUPER", "THISCALL", "THROW", "TO", "TRY", "TYPEOF", "UNION", 
		"UNTIL", "UPTO", "USING", "VIRTUAL", "WHILE", "ARRAY", "BYTE", "CHAR", 
		"CODEBLOCK", "DATE", "DWORD", "FLOAT", "INT", "INT64", "LOGIC", "LONGINT", 
		"OBJECT", "PSZ", "PTR", "REAL4", "REAL8", "REF", "SHORTINT", "STRING", 
		"SYMBOL", "USUAL", "UINT64", "VOID", "WORD", "NIL", "NULL", "NULL_ARRAY", 
		"NULL_CODEBLOCK", "NULL_DATE", "NULL_OBJECT", "NULL_PSZ", "NULL_PTR", 
		"NULL_STRING", "NULL_SYMBOL", "FALSE_CONST", "TRUE_CONST", "LOGIC_AND", 
		"LOGIC_OR", "LOGIC_NOT", "LOGIC_XOR", "INC", "DEC", "NOT", "AND", "OR", 
		"PLUS", "MINUS", "DIV", "MOD", "EXP", "LSHIFT", "RSHIFT", "TILDE", "MULT", 
		"ASSIGN_OP", "ASSIGN_ADD", "ASSIGN_SUB", "ASSIGN_EXP", "ASSIGN_MUL", "ASSIGN_DIV", 
		"ASSIGN_MOD", "ASSIGN_BITAND", "ASSIGN_BITOR", "ASSIGN_LSHIFT", "ASSIGN_RSHIFT", 
		"ASSIGN_XOR", "LT", "LTE", "GT", "GTE", "EQ", "EEQ", "SUBSTR", "NEQ", 
		"LPAREN", "RPAREN", "LCURLY", "RCURLY", "LBRKT", "RBRKT", "COLON", "COMMA", 
		"PIPE", "AMP", "ADDROF", "ALIAS", "DOT", "HEX_CONST", "BIN_CONST", "INT_CONST", 
		"DATE_CONST", "REAL_CONST", "SYMBOL_CONST", "STRING_CONST", "WS", "SL_COMMENT", 
		"NL", "ID", "UNRECOGNIZED"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "XSharp.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public XSharpParser(ITokenStream input)
		: base(input)
	{
		Interpreter = new ParserATNSimulator(this,_ATN);
	}
	public partial class SourceContext : ParserRuleContext {
		public EofContext eof() {
			return GetRuleContext<EofContext>(0);
		}
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public EntityContext[] entity() {
			return GetRuleContexts<EntityContext>();
		}
		public EntityContext entity(int i) {
			return GetRuleContext<EntityContext>(i);
		}
		public SourceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_source; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterSource(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitSource(this);
		}
	}

	[RuleVersion(0)]
	public SourceContext source() {
		SourceContext _localctx = new SourceContext(Context, State);
		EnterRule(_localctx, 0, RULE_source);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 61;
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				{
				State = 60; eos();
				}
				break;
			}
			State = 66;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==FUNCTION) {
				{
				{
				State = 63; entity();
				}
				}
				State = 68;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 69; eof();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EntityContext : ParserRuleContext {
		public FunctionContext function() {
			return GetRuleContext<FunctionContext>(0);
		}
		public EntityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_entity; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterEntity(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitEntity(this);
		}
	}

	[RuleVersion(0)]
	public EntityContext entity() {
		EntityContext _localctx = new EntityContext(Context, State);
		EnterRule(_localctx, 2, RULE_entity);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 71; function();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionContext : ParserRuleContext {
		public IdentifierContext Id;
		public ParameterListContext ParamList;
		public DatatypeContext Type;
		public StatementBlockContext StmtBlk;
		public ITerminalNode FUNCTION() { return GetToken(XSharpParser.FUNCTION, 0); }
		public ITerminalNode AS() { return GetToken(XSharpParser.AS, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public FunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitFunction(this);
		}
	}

	[RuleVersion(0)]
	public FunctionContext function() {
		FunctionContext _localctx = new FunctionContext(Context, State);
		EnterRule(_localctx, 4, RULE_function);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 73; Match(FUNCTION);
			State = 74; _localctx.Id = identifier();
			State = 75; _localctx.ParamList = parameterList();
			State = 76; Match(AS);
			State = 77; _localctx.Type = datatype();
			State = 78; eos();
			State = 79; _localctx.StmtBlk = statementBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureContext : ParserRuleContext {
		public IdentifierContext Id;
		public ParameterListContext ParamList;
		public StatementBlockContext StmtBlk;
		public ITerminalNode PROCEDURE() { return GetToken(XSharpParser.PROCEDURE, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ParameterListContext parameterList() {
			return GetRuleContext<ParameterListContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitProcedure(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureContext procedure() {
		ProcedureContext _localctx = new ProcedureContext(Context, State);
		EnterRule(_localctx, 6, RULE_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81; Match(PROCEDURE);
			State = 82; _localctx.Id = identifier();
			State = 83; _localctx.ParamList = parameterList();
			State = 84; eos();
			State = 85; _localctx.StmtBlk = statementBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterListContext : ParserRuleContext {
		public ParameterContext _parameter;
		public IList<ParameterContext> _Params = new List<ParameterContext>();
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public ParameterContext[] parameter() {
			return GetRuleContexts<ParameterContext>();
		}
		public ParameterContext parameter(int i) {
			return GetRuleContext<ParameterContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public ParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameterList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterParameterList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitParameterList(this);
		}
	}

	[RuleVersion(0)]
	public ParameterListContext parameterList() {
		ParameterListContext _localctx = new ParameterListContext(Context, State);
		EnterRule(_localctx, 8, RULE_parameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 87; Match(LPAREN);
			State = 96;
			_la = TokenStream.La(1);
			if (_la==ID) {
				{
				State = 88; _localctx._parameter = parameter();
				_localctx._Params.Add(_localctx._parameter);
				State = 93;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 89; Match(COMMA);
					State = 90; _localctx._parameter = parameter();
					_localctx._Params.Add(_localctx._parameter);
					}
					}
					State = 95;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
			}

			State = 98; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public IdentifierContext Id;
		public ExpressionContext Default;
		public IToken _AS;
		public IList<IToken> _Modifiers = new List<IToken>();
		public IToken _REF;
		public IToken _OUT;
		public IToken _tset137;
		public IToken _CONST;
		public DatatypeContext Type;
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ITerminalNode AS() { return GetToken(XSharpParser.AS, 0); }
		public ITerminalNode REF() { return GetToken(XSharpParser.REF, 0); }
		public ITerminalNode OUT() { return GetToken(XSharpParser.OUT, 0); }
		public ITerminalNode ASSIGN_OP() { return GetToken(XSharpParser.ASSIGN_OP, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode CONST() { return GetToken(XSharpParser.CONST, 0); }
		public ParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterParameter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitParameter(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter() {
		ParameterContext _localctx = new ParameterContext(Context, State);
		EnterRule(_localctx, 10, RULE_parameter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 100; _localctx.Id = identifier();
			State = 103;
			_la = TokenStream.La(1);
			if (_la==ASSIGN_OP) {
				{
				State = 101; Match(ASSIGN_OP);
				State = 102; _localctx.Default = expression(0);
				}
			}

			State = 105;
			_localctx._tset137 = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !(_la==AS || _la==OUT || _la==REF) ) {
				_localctx._tset137 = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			_localctx._Modifiers.Add(_localctx._tset137);
			State = 107;
			_la = TokenStream.La(1);
			if (_la==CONST) {
				{
				State = 106; _localctx._CONST = Match(CONST);
				_localctx._Modifiers.Add(_localctx._CONST);
				}
			}

			State = 109; _localctx.Type = datatype();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementBlockContext : ParserRuleContext {
		public StatementContext _statement;
		public IList<StatementContext> _Stmts = new List<StatementContext>();
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statementBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterStatementBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitStatementBlock(this);
		}
	}

	[RuleVersion(0)]
	public StatementBlockContext statementBlock() {
		StatementBlockContext _localctx = new StatementBlockContext(Context, State);
		EnterRule(_localctx, 12, RULE_statementBlock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 114;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << BEGIN) | (1L << BREAK) | (1L << DO) | (1L << EXIT) | (1L << FOR) | (1L << FOREACH) | (1L << IF) | (1L << IIF) | (1L << LOOP))) != 0) || ((((_la - 73)) & ~0x3f) == 0 && ((1L << (_la - 73)) & ((1L << (REPEAT - 73)) | (1L << (RETURN - 73)) | (1L << (SIZEOF - 73)) | (1L << (THROW - 73)) | (1L << (TRY - 73)) | (1L << (TYPEOF - 73)) | (1L << (WHILE - 73)) | (1L << (ARRAY - 73)) | (1L << (BYTE - 73)) | (1L << (CODEBLOCK - 73)) | (1L << (DATE - 73)) | (1L << (DWORD - 73)) | (1L << (FLOAT - 73)) | (1L << (INT - 73)) | (1L << (INT64 - 73)) | (1L << (LOGIC - 73)) | (1L << (LONGINT - 73)) | (1L << (OBJECT - 73)) | (1L << (PSZ - 73)) | (1L << (PTR - 73)) | (1L << (REAL4 - 73)) | (1L << (REAL8 - 73)) | (1L << (SHORTINT - 73)) | (1L << (STRING - 73)) | (1L << (SYMBOL - 73)) | (1L << (USUAL - 73)) | (1L << (UINT64 - 73)) | (1L << (VOID - 73)) | (1L << (WORD - 73)) | (1L << (NIL - 73)) | (1L << (NULL - 73)) | (1L << (NULL_ARRAY - 73)) | (1L << (NULL_CODEBLOCK - 73)) | (1L << (NULL_DATE - 73)) | (1L << (NULL_OBJECT - 73)) | (1L << (NULL_PSZ - 73)) | (1L << (NULL_PTR - 73)) | (1L << (NULL_STRING - 73)) | (1L << (NULL_SYMBOL - 73)) | (1L << (FALSE_CONST - 73)) | (1L << (TRUE_CONST - 73)) | (1L << (LOGIC_NOT - 73)) | (1L << (LOGIC_XOR - 73)))) != 0) || ((((_la - 137)) & ~0x3f) == 0 && ((1L << (_la - 137)) & ((1L << (INC - 137)) | (1L << (DEC - 137)) | (1L << (NOT - 137)) | (1L << (PLUS - 137)) | (1L << (MINUS - 137)) | (1L << (TILDE - 137)) | (1L << (LT - 137)) | (1L << (LPAREN - 137)) | (1L << (LCURLY - 137)) | (1L << (ADDROF - 137)) | (1L << (HEX_CONST - 137)) | (1L << (BIN_CONST - 137)) | (1L << (INT_CONST - 137)) | (1L << (DATE_CONST - 137)) | (1L << (REAL_CONST - 137)) | (1L << (SYMBOL_CONST - 137)) | (1L << (STRING_CONST - 137)) | (1L << (ID - 137)))) != 0)) {
				{
				{
				State = 111; _localctx._statement = statement();
				_localctx._Stmts.Add(_localctx._statement);
				}
				}
				State = 116;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
	 
		public StatementContext() { }
		public virtual void CopyFrom(StatementContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ForStmtContext : StatementContext {
		public ExpressionContext Iter;
		public ExpressionContext InitExpr;
		public IToken Dir;
		public ExpressionContext FinalExpr;
		public ExpressionContext Step;
		public StatementBlockContext StmtBlk;
		public ITerminalNode FOR() { return GetToken(XSharpParser.FOR, 0); }
		public ITerminalNode ASSIGN_OP() { return GetToken(XSharpParser.ASSIGN_OP, 0); }
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode NEXT() { return GetToken(XSharpParser.NEXT, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ITerminalNode TO() { return GetToken(XSharpParser.TO, 0); }
		public ITerminalNode UPTO() { return GetToken(XSharpParser.UPTO, 0); }
		public ITerminalNode DOWNTO() { return GetToken(XSharpParser.DOWNTO, 0); }
		public ITerminalNode STEP() { return GetToken(XSharpParser.STEP, 0); }
		public ForStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterForStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitForStmt(this);
		}
	}
	public partial class LoopStmtContext : StatementContext {
		public ITerminalNode LOOP() { return GetToken(XSharpParser.LOOP, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public LoopStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterLoopStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitLoopStmt(this);
		}
	}
	public partial class WhileStmtContext : StatementContext {
		public ExpressionContext Expr;
		public StatementBlockContext StmtBlk;
		public ITerminalNode[] DO() { return GetTokens(XSharpParser.DO); }
		public ITerminalNode DO(int i) {
			return GetToken(XSharpParser.DO, i);
		}
		public ITerminalNode WHILE() { return GetToken(XSharpParser.WHILE, 0); }
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode END() { return GetToken(XSharpParser.END, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public WhileStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterWhileStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitWhileStmt(this);
		}
	}
	public partial class ForeachStmtContext : StatementContext {
		public IdentifierContext Id;
		public DatatypeContext Type;
		public ExpressionContext Container;
		public StatementBlockContext StmtBlk;
		public ITerminalNode FOREACH() { return GetToken(XSharpParser.FOREACH, 0); }
		public ITerminalNode IN() { return GetToken(XSharpParser.IN, 0); }
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode NEXT() { return GetToken(XSharpParser.NEXT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ITerminalNode IMPLIED() { return GetToken(XSharpParser.IMPLIED, 0); }
		public ITerminalNode AS() { return GetToken(XSharpParser.AS, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ForeachStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterForeachStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitForeachStmt(this);
		}
	}
	public partial class ScopeStmtContext : StatementContext {
		public StatementBlockContext StmtBlk;
		public ITerminalNode BEGIN() { return GetToken(XSharpParser.BEGIN, 0); }
		public ITerminalNode[] SCOPE() { return GetTokens(XSharpParser.SCOPE); }
		public ITerminalNode SCOPE(int i) {
			return GetToken(XSharpParser.SCOPE, i);
		}
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode END() { return GetToken(XSharpParser.END, 0); }
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ScopeStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterScopeStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitScopeStmt(this);
		}
	}
	public partial class ExpressionStmtContext : StatementContext {
		public ExpressionContext _expression;
		public IList<ExpressionContext> _Exprs = new List<ExpressionContext>();
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public ExpressionStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterExpressionStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitExpressionStmt(this);
		}
	}
	public partial class TryStmtContext : StatementContext {
		public StatementBlockContext StmtBlk;
		public CatchBlockContext _catchBlock;
		public IList<CatchBlockContext> _CatchBlock = new List<CatchBlockContext>();
		public StatementBlockContext FinBlock;
		public ITerminalNode[] TRY() { return GetTokens(XSharpParser.TRY); }
		public ITerminalNode TRY(int i) {
			return GetToken(XSharpParser.TRY, i);
		}
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode END() { return GetToken(XSharpParser.END, 0); }
		public StatementBlockContext[] statementBlock() {
			return GetRuleContexts<StatementBlockContext>();
		}
		public StatementBlockContext statementBlock(int i) {
			return GetRuleContext<StatementBlockContext>(i);
		}
		public ITerminalNode[] CATCH() { return GetTokens(XSharpParser.CATCH); }
		public ITerminalNode CATCH(int i) {
			return GetToken(XSharpParser.CATCH, i);
		}
		public ITerminalNode FINALLY() { return GetToken(XSharpParser.FINALLY, 0); }
		public CatchBlockContext[] catchBlock() {
			return GetRuleContexts<CatchBlockContext>();
		}
		public CatchBlockContext catchBlock(int i) {
			return GetRuleContext<CatchBlockContext>(i);
		}
		public TryStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterTryStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitTryStmt(this);
		}
	}
	public partial class ReturnStmtContext : StatementContext {
		public ExpressionContext Expr;
		public ITerminalNode RETURN() { return GetToken(XSharpParser.RETURN, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ITerminalNode VOID() { return GetToken(XSharpParser.VOID, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ReturnStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterReturnStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitReturnStmt(this);
		}
	}
	public partial class CondStmtContext : StatementContext {
		public ConditionalBlockContext _conditionalBlock;
		public IList<ConditionalBlockContext> _CondBlock = new List<ConditionalBlockContext>();
		public StatementBlockContext _statementBlock;
		public IList<StatementBlockContext> _ElseBlock = new List<StatementBlockContext>();
		public ITerminalNode[] IF() { return GetTokens(XSharpParser.IF); }
		public ITerminalNode IF(int i) {
			return GetToken(XSharpParser.IF, i);
		}
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ConditionalBlockContext[] conditionalBlock() {
			return GetRuleContexts<ConditionalBlockContext>();
		}
		public ConditionalBlockContext conditionalBlock(int i) {
			return GetRuleContext<ConditionalBlockContext>(i);
		}
		public ITerminalNode END() { return GetToken(XSharpParser.END, 0); }
		public ITerminalNode ENDIF() { return GetToken(XSharpParser.ENDIF, 0); }
		public ITerminalNode[] ELSEIF() { return GetTokens(XSharpParser.ELSEIF); }
		public ITerminalNode ELSEIF(int i) {
			return GetToken(XSharpParser.ELSEIF, i);
		}
		public ITerminalNode ELSE() { return GetToken(XSharpParser.ELSE, 0); }
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ITerminalNode DO() { return GetToken(XSharpParser.DO, 0); }
		public ITerminalNode[] CASE() { return GetTokens(XSharpParser.CASE); }
		public ITerminalNode CASE(int i) {
			return GetToken(XSharpParser.CASE, i);
		}
		public ITerminalNode ENDCASE() { return GetToken(XSharpParser.ENDCASE, 0); }
		public ITerminalNode OTHERWISE() { return GetToken(XSharpParser.OTHERWISE, 0); }
		public CondStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterCondStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitCondStmt(this);
		}
	}
	public partial class ThrowStmtContext : StatementContext {
		public ExpressionContext Expr;
		public ITerminalNode THROW() { return GetToken(XSharpParser.THROW, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ThrowStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterThrowStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitThrowStmt(this);
		}
	}
	public partial class BreakStmtContext : StatementContext {
		public ExpressionContext Expr;
		public ITerminalNode BREAK() { return GetToken(XSharpParser.BREAK, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public BreakStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterBreakStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitBreakStmt(this);
		}
	}
	public partial class RepeatStmtContext : StatementContext {
		public StatementBlockContext StmtBlk;
		public ExpressionContext Expr;
		public ITerminalNode REPEAT() { return GetToken(XSharpParser.REPEAT, 0); }
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode UNTIL() { return GetToken(XSharpParser.UNTIL, 0); }
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public RepeatStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterRepeatStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitRepeatStmt(this);
		}
	}
	public partial class LockStmtContext : StatementContext {
		public ExpressionContext Expr;
		public StatementBlockContext StmtBlk;
		public ITerminalNode BEGIN() { return GetToken(XSharpParser.BEGIN, 0); }
		public ITerminalNode[] LOCK() { return GetTokens(XSharpParser.LOCK); }
		public ITerminalNode LOCK(int i) {
			return GetToken(XSharpParser.LOCK, i);
		}
		public EosContext[] eos() {
			return GetRuleContexts<EosContext>();
		}
		public EosContext eos(int i) {
			return GetRuleContext<EosContext>(i);
		}
		public ITerminalNode END() { return GetToken(XSharpParser.END, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public LockStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterLockStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitLockStmt(this);
		}
	}
	public partial class ExitStmtContext : StatementContext {
		public ITerminalNode EXIT() { return GetToken(XSharpParser.EXIT, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ExitStmtContext(StatementContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterExitStmt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitExitStmt(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 14, RULE_statement);
		int _la;
		try {
			State = 293;
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				_localctx = new WhileStmtContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 117; Match(DO);
				State = 118; Match(WHILE);
				State = 119; ((WhileStmtContext)_localctx).Expr = expression(0);
				State = 120; eos();
				State = 121; ((WhileStmtContext)_localctx).StmtBlk = statementBlock();
				State = 122; Match(END);
				State = 123; Match(DO);
				State = 124; eos();
				}
				break;
			case 2:
				_localctx = new WhileStmtContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 126; Match(WHILE);
				State = 127; ((WhileStmtContext)_localctx).Expr = expression(0);
				State = 128; eos();
				State = 129; ((WhileStmtContext)_localctx).StmtBlk = statementBlock();
				State = 130; Match(END);
				State = 131; eos();
				}
				break;
			case 3:
				_localctx = new RepeatStmtContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 133; Match(REPEAT);
				State = 134; eos();
				State = 135; ((RepeatStmtContext)_localctx).StmtBlk = statementBlock();
				State = 136; Match(UNTIL);
				State = 137; ((RepeatStmtContext)_localctx).Expr = expression(0);
				State = 138; eos();
				}
				break;
			case 4:
				_localctx = new ForStmtContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 140; Match(FOR);
				State = 141; ((ForStmtContext)_localctx).Iter = expression(0);
				State = 142; Match(ASSIGN_OP);
				State = 143; ((ForStmtContext)_localctx).InitExpr = expression(0);
				State = 144;
				((ForStmtContext)_localctx).Dir = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !(_la==DOWNTO || _la==TO || _la==UPTO) ) {
					((ForStmtContext)_localctx).Dir = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 145; ((ForStmtContext)_localctx).FinalExpr = expression(0);
				State = 148;
				_la = TokenStream.La(1);
				if (_la==STEP) {
					{
					State = 146; Match(STEP);
					State = 147; ((ForStmtContext)_localctx).Step = expression(0);
					}
				}

				State = 150; eos();
				State = 151; ((ForStmtContext)_localctx).StmtBlk = statementBlock();
				State = 152; Match(NEXT);
				State = 153; eos();
				}
				break;
			case 5:
				_localctx = new ForeachStmtContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 155; Match(FOREACH);
				State = 162;
				switch (TokenStream.La(1)) {
				case IMPLIED:
					{
					State = 156; Match(IMPLIED);
					State = 157; ((ForeachStmtContext)_localctx).Id = identifier();
					}
					break;
				case ID:
					{
					State = 158; ((ForeachStmtContext)_localctx).Id = identifier();
					State = 159; Match(AS);
					State = 160; ((ForeachStmtContext)_localctx).Type = datatype();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 164; Match(IN);
				State = 165; ((ForeachStmtContext)_localctx).Container = expression(0);
				State = 166; eos();
				State = 167; ((ForeachStmtContext)_localctx).StmtBlk = statementBlock();
				State = 168; Match(NEXT);
				State = 169; eos();
				}
				break;
			case 6:
				_localctx = new CondStmtContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 171; Match(IF);
				State = 172; ((CondStmtContext)_localctx)._conditionalBlock = conditionalBlock();
				((CondStmtContext)_localctx)._CondBlock.Add(((CondStmtContext)_localctx)._conditionalBlock);
				State = 177;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==ELSEIF) {
					{
					{
					State = 173; Match(ELSEIF);
					State = 174; ((CondStmtContext)_localctx)._conditionalBlock = conditionalBlock();
					((CondStmtContext)_localctx)._CondBlock.Add(((CondStmtContext)_localctx)._conditionalBlock);
					}
					}
					State = 179;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 184;
				_la = TokenStream.La(1);
				if (_la==ELSE) {
					{
					State = 180; Match(ELSE);
					State = 181; eos();
					State = 182; ((CondStmtContext)_localctx)._statementBlock = statementBlock();
					((CondStmtContext)_localctx)._ElseBlock.Add(((CondStmtContext)_localctx)._statementBlock);
					}
				}

				State = 191;
				switch (TokenStream.La(1)) {
				case END:
					{
					State = 186; Match(END);
					State = 188;
					_la = TokenStream.La(1);
					if (_la==IF) {
						{
						State = 187; Match(IF);
						}
					}

					}
					break;
				case ENDIF:
					{
					State = 190; Match(ENDIF);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 193; eos();
				}
				break;
			case 7:
				_localctx = new CondStmtContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 195; Match(DO);
				State = 196; Match(CASE);
				State = 197; eos();
				State = 202;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==CASE) {
					{
					{
					State = 198; Match(CASE);
					State = 199; ((CondStmtContext)_localctx)._conditionalBlock = conditionalBlock();
					((CondStmtContext)_localctx)._CondBlock.Add(((CondStmtContext)_localctx)._conditionalBlock);
					}
					}
					State = 204;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 209;
				_la = TokenStream.La(1);
				if (_la==OTHERWISE) {
					{
					State = 205; Match(OTHERWISE);
					State = 206; eos();
					State = 207; ((CondStmtContext)_localctx)._statementBlock = statementBlock();
					((CondStmtContext)_localctx)._ElseBlock.Add(((CondStmtContext)_localctx)._statementBlock);
					}
				}

				State = 216;
				switch (TokenStream.La(1)) {
				case END:
					{
					State = 211; Match(END);
					State = 213;
					_la = TokenStream.La(1);
					if (_la==CASE) {
						{
						State = 212; Match(CASE);
						}
					}

					}
					break;
				case ENDCASE:
					{
					State = 215; Match(ENDCASE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 218; eos();
				}
				break;
			case 8:
				_localctx = new ExitStmtContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 220; Match(EXIT);
				State = 221; eos();
				}
				break;
			case 9:
				_localctx = new LoopStmtContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 222; Match(LOOP);
				State = 223; eos();
				}
				break;
			case 10:
				_localctx = new ExpressionStmtContext(_localctx);
				EnterOuterAlt(_localctx, 10);
				{
				State = 224; ((ExpressionStmtContext)_localctx)._expression = expression(0);
				((ExpressionStmtContext)_localctx)._Exprs.Add(((ExpressionStmtContext)_localctx)._expression);
				State = 229;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==COMMA) {
					{
					{
					State = 225; Match(COMMA);
					State = 226; ((ExpressionStmtContext)_localctx)._expression = expression(0);
					((ExpressionStmtContext)_localctx)._Exprs.Add(((ExpressionStmtContext)_localctx)._expression);
					}
					}
					State = 231;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 232; eos();
				}
				break;
			case 11:
				_localctx = new BreakStmtContext(_localctx);
				EnterOuterAlt(_localctx, 11);
				{
				State = 234; Match(BREAK);
				State = 236;
				_la = TokenStream.La(1);
				if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
					{
					State = 235; ((BreakStmtContext)_localctx).Expr = expression(0);
					}
				}

				State = 238; eos();
				}
				break;
			case 12:
				_localctx = new ThrowStmtContext(_localctx);
				EnterOuterAlt(_localctx, 12);
				{
				State = 239; Match(THROW);
				State = 241;
				_la = TokenStream.La(1);
				if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
					{
					State = 240; ((ThrowStmtContext)_localctx).Expr = expression(0);
					}
				}

				State = 243; eos();
				}
				break;
			case 13:
				_localctx = new TryStmtContext(_localctx);
				EnterOuterAlt(_localctx, 13);
				{
				State = 244; Match(TRY);
				State = 245; eos();
				State = 246; ((TryStmtContext)_localctx).StmtBlk = statementBlock();
				State = 251;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==CATCH) {
					{
					{
					State = 247; Match(CATCH);
					State = 248; ((TryStmtContext)_localctx)._catchBlock = catchBlock();
					((TryStmtContext)_localctx)._CatchBlock.Add(((TryStmtContext)_localctx)._catchBlock);
					}
					}
					State = 253;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				State = 258;
				_la = TokenStream.La(1);
				if (_la==FINALLY) {
					{
					State = 254; Match(FINALLY);
					State = 255; eos();
					State = 256; ((TryStmtContext)_localctx).FinBlock = statementBlock();
					}
				}

				State = 260; Match(END);
				State = 262;
				_la = TokenStream.La(1);
				if (_la==TRY) {
					{
					State = 261; Match(TRY);
					}
				}

				State = 264; eos();
				}
				break;
			case 14:
				_localctx = new ReturnStmtContext(_localctx);
				EnterOuterAlt(_localctx, 14);
				{
				State = 266; Match(RETURN);
				State = 269;
				switch ( Interpreter.AdaptivePredict(TokenStream,23,Context) ) {
				case 1:
					{
					State = 267; Match(VOID);
					}
					break;
				case 2:
					{
					State = 268; ((ReturnStmtContext)_localctx).Expr = expression(0);
					}
					break;
				}
				State = 271; eos();
				}
				break;
			case 15:
				_localctx = new LockStmtContext(_localctx);
				EnterOuterAlt(_localctx, 15);
				{
				State = 272; Match(BEGIN);
				State = 273; Match(LOCK);
				State = 274; ((LockStmtContext)_localctx).Expr = expression(0);
				State = 275; eos();
				State = 276; ((LockStmtContext)_localctx).StmtBlk = statementBlock();
				State = 277; Match(END);
				State = 279;
				_la = TokenStream.La(1);
				if (_la==LOCK) {
					{
					State = 278; Match(LOCK);
					}
				}

				State = 281; eos();
				}
				break;
			case 16:
				_localctx = new ScopeStmtContext(_localctx);
				EnterOuterAlt(_localctx, 16);
				{
				State = 283; Match(BEGIN);
				State = 284; Match(SCOPE);
				State = 285; eos();
				State = 286; ((ScopeStmtContext)_localctx).StmtBlk = statementBlock();
				State = 287; Match(END);
				State = 289;
				_la = TokenStream.La(1);
				if (_la==SCOPE) {
					{
					State = 288; Match(SCOPE);
					}
				}

				State = 291; eos();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalBlockContext : ParserRuleContext {
		public ExpressionContext Cond;
		public StatementBlockContext StmtBlk;
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public ConditionalBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterConditionalBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitConditionalBlock(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalBlockContext conditionalBlock() {
		ConditionalBlockContext _localctx = new ConditionalBlockContext(Context, State);
		EnterRule(_localctx, 16, RULE_conditionalBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 295; _localctx.Cond = expression(0);
			State = 296; eos();
			State = 297; _localctx.StmtBlk = statementBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CatchBlockContext : ParserRuleContext {
		public IdentifierContext Id;
		public DatatypeContext Type;
		public StatementBlockContext StmtBlk;
		public ITerminalNode AS() { return GetToken(XSharpParser.AS, 0); }
		public EosContext eos() {
			return GetRuleContext<EosContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public StatementBlockContext statementBlock() {
			return GetRuleContext<StatementBlockContext>(0);
		}
		public CatchBlockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_catchBlock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterCatchBlock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitCatchBlock(this);
		}
	}

	[RuleVersion(0)]
	public CatchBlockContext catchBlock() {
		CatchBlockContext _localctx = new CatchBlockContext(Context, State);
		EnterRule(_localctx, 18, RULE_catchBlock);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 299; _localctx.Id = identifier();
			State = 300; Match(AS);
			State = 301; _localctx.Type = datatype();
			State = 302; eos();
			State = 303; _localctx.StmtBlk = statementBlock();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
	 
		public ExpressionContext() { }
		public virtual void CopyFrom(ExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class CtorCallContext : ExpressionContext {
		public DatatypeContext Type;
		public ArgumentListContext ArgList;
		public ITerminalNode LCURLY() { return GetToken(XSharpParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(XSharpParser.RCURLY, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public CtorCallContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterCtorCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitCtorCall(this);
		}
	}
	public partial class AssignmentExpressionContext : ExpressionContext {
		public ExpressionContext Left;
		public IToken Op;
		public ExpressionContext Right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode ASSIGN_OP() { return GetToken(XSharpParser.ASSIGN_OP, 0); }
		public ITerminalNode ASSIGN_ADD() { return GetToken(XSharpParser.ASSIGN_ADD, 0); }
		public ITerminalNode ASSIGN_EXP() { return GetToken(XSharpParser.ASSIGN_EXP, 0); }
		public ITerminalNode ASSIGN_MUL() { return GetToken(XSharpParser.ASSIGN_MUL, 0); }
		public ITerminalNode ASSIGN_DIV() { return GetToken(XSharpParser.ASSIGN_DIV, 0); }
		public ITerminalNode ASSIGN_MOD() { return GetToken(XSharpParser.ASSIGN_MOD, 0); }
		public ITerminalNode ASSIGN_BITAND() { return GetToken(XSharpParser.ASSIGN_BITAND, 0); }
		public ITerminalNode ASSIGN_BITOR() { return GetToken(XSharpParser.ASSIGN_BITOR, 0); }
		public ITerminalNode ASSIGN_LSHIFT() { return GetToken(XSharpParser.ASSIGN_LSHIFT, 0); }
		public ITerminalNode ASSIGN_RSHIFT() { return GetToken(XSharpParser.ASSIGN_RSHIFT, 0); }
		public ITerminalNode ASSIGN_XOR() { return GetToken(XSharpParser.ASSIGN_XOR, 0); }
		public AssignmentExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterAssignmentExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitAssignmentExpression(this);
		}
	}
	public partial class ParenExpressionContext : ExpressionContext {
		public ExpressionContext Expr;
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ParenExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterParenExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitParenExpression(this);
		}
	}
	public partial class TypeOfExpressionContext : ExpressionContext {
		public DatatypeContext Type;
		public ITerminalNode TYPEOF() { return GetToken(XSharpParser.TYPEOF, 0); }
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public TypeOfExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterTypeOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitTypeOfExpression(this);
		}
	}
	public partial class BinaryExpressionContext : ExpressionContext {
		public ExpressionContext Left;
		public IToken Op;
		public ExpressionContext Right;
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode EXP() { return GetToken(XSharpParser.EXP, 0); }
		public ITerminalNode MULT() { return GetToken(XSharpParser.MULT, 0); }
		public ITerminalNode DIV() { return GetToken(XSharpParser.DIV, 0); }
		public ITerminalNode MOD() { return GetToken(XSharpParser.MOD, 0); }
		public ITerminalNode PLUS() { return GetToken(XSharpParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(XSharpParser.MINUS, 0); }
		public ITerminalNode LSHIFT() { return GetToken(XSharpParser.LSHIFT, 0); }
		public ITerminalNode RSHIFT() { return GetToken(XSharpParser.RSHIFT, 0); }
		public ITerminalNode LT() { return GetToken(XSharpParser.LT, 0); }
		public ITerminalNode LTE() { return GetToken(XSharpParser.LTE, 0); }
		public ITerminalNode GT() { return GetToken(XSharpParser.GT, 0); }
		public ITerminalNode GTE() { return GetToken(XSharpParser.GTE, 0); }
		public ITerminalNode EQ() { return GetToken(XSharpParser.EQ, 0); }
		public ITerminalNode EEQ() { return GetToken(XSharpParser.EEQ, 0); }
		public ITerminalNode SUBSTR() { return GetToken(XSharpParser.SUBSTR, 0); }
		public ITerminalNode NEQ() { return GetToken(XSharpParser.NEQ, 0); }
		public ITerminalNode AMP() { return GetToken(XSharpParser.AMP, 0); }
		public ITerminalNode TILDE() { return GetToken(XSharpParser.TILDE, 0); }
		public ITerminalNode PIPE() { return GetToken(XSharpParser.PIPE, 0); }
		public ITerminalNode LOGIC_AND() { return GetToken(XSharpParser.LOGIC_AND, 0); }
		public ITerminalNode LOGIC_XOR() { return GetToken(XSharpParser.LOGIC_XOR, 0); }
		public ITerminalNode LOGIC_OR() { return GetToken(XSharpParser.LOGIC_OR, 0); }
		public BinaryExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterBinaryExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitBinaryExpression(this);
		}
	}
	public partial class TypeCastContext : ExpressionContext {
		public DatatypeContext Type;
		public ExpressionContext Expr;
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public TypeCastContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterTypeCast(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitTypeCast(this);
		}
	}
	public partial class PrefixExpressionContext : ExpressionContext {
		public IToken Op;
		public ExpressionContext Expr;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode PLUS() { return GetToken(XSharpParser.PLUS, 0); }
		public ITerminalNode MINUS() { return GetToken(XSharpParser.MINUS, 0); }
		public ITerminalNode TILDE() { return GetToken(XSharpParser.TILDE, 0); }
		public ITerminalNode ADDROF() { return GetToken(XSharpParser.ADDROF, 0); }
		public ITerminalNode INC() { return GetToken(XSharpParser.INC, 0); }
		public ITerminalNode DEC() { return GetToken(XSharpParser.DEC, 0); }
		public ITerminalNode LOGIC_NOT() { return GetToken(XSharpParser.LOGIC_NOT, 0); }
		public ITerminalNode LOGIC_XOR() { return GetToken(XSharpParser.LOGIC_XOR, 0); }
		public ITerminalNode NOT() { return GetToken(XSharpParser.NOT, 0); }
		public PrefixExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterPrefixExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitPrefixExpression(this);
		}
	}
	public partial class SizeOfExpressionContext : ExpressionContext {
		public DatatypeContext Type;
		public ITerminalNode SIZEOF() { return GetToken(XSharpParser.SIZEOF, 0); }
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public SizeOfExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterSizeOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitSizeOfExpression(this);
		}
	}
	public partial class LiteralArrayExpressionContext : ExpressionContext {
		public LiteralArrayContext LiteralArray;
		public LiteralArrayContext literalArray() {
			return GetRuleContext<LiteralArrayContext>(0);
		}
		public LiteralArrayExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterLiteralArrayExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitLiteralArrayExpression(this);
		}
	}
	public partial class IifExpressionContext : ExpressionContext {
		public IifContext Expr;
		public IifContext iif() {
			return GetRuleContext<IifContext>(0);
		}
		public IifExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterIifExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitIifExpression(this);
		}
	}
	public partial class CodeblockExpressionContext : ExpressionContext {
		public CodeblockContext CbExpr;
		public CodeblockContext codeblock() {
			return GetRuleContext<CodeblockContext>(0);
		}
		public CodeblockExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterCodeblockExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitCodeblockExpression(this);
		}
	}
	public partial class ArrayAccessContext : ExpressionContext {
		public ExpressionContext Expr;
		public ExpressionListContext ArgList;
		public ITerminalNode LBRKT() { return GetToken(XSharpParser.LBRKT, 0); }
		public ITerminalNode RBRKT() { return GetToken(XSharpParser.RBRKT, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public ArrayAccessContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterArrayAccess(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitArrayAccess(this);
		}
	}
	public partial class LiteralExpressionContext : ExpressionContext {
		public LiteralValueContext Literal;
		public LiteralValueContext literalValue() {
			return GetRuleContext<LiteralValueContext>(0);
		}
		public LiteralExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterLiteralExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitLiteralExpression(this);
		}
	}
	public partial class AccessMemberContext : ExpressionContext {
		public ExpressionContext Left;
		public IToken Op;
		public IdentifierNameContext Right;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public IdentifierNameContext identifierName() {
			return GetRuleContext<IdentifierNameContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(XSharpParser.DOT, 0); }
		public ITerminalNode COLON() { return GetToken(XSharpParser.COLON, 0); }
		public AccessMemberContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterAccessMember(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitAccessMember(this);
		}
	}
	public partial class NameExpressionContext : ExpressionContext {
		public NameContext Name;
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public NameExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterNameExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitNameExpression(this);
		}
	}
	public partial class PostfixExpressionContext : ExpressionContext {
		public ExpressionContext Expr;
		public IToken Op;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ITerminalNode INC() { return GetToken(XSharpParser.INC, 0); }
		public ITerminalNode DEC() { return GetToken(XSharpParser.DEC, 0); }
		public PostfixExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterPostfixExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitPostfixExpression(this);
		}
	}
	public partial class TypeExpressionContext : ExpressionContext {
		public NativeTypeContext Type;
		public NativeTypeContext nativeType() {
			return GetRuleContext<NativeTypeContext>(0);
		}
		public TypeExpressionContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterTypeExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitTypeExpression(this);
		}
	}
	public partial class MethodCallContext : ExpressionContext {
		public ExpressionContext Expr;
		public ArgumentListContext ArgList;
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public MethodCallContext(ExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterMethodCall(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitMethodCall(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return expression(0);
	}

	private ExpressionContext expression(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		ExpressionContext _localctx = new ExpressionContext(Context, _parentState);
		ExpressionContext _prevctx = _localctx;
		int _startState = 20;
		EnterRecursionRule(_localctx, 20, RULE_expression, _p);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 342;
			switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
			case 1:
				{
				_localctx = new PrefixExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 306;
				((PrefixExpressionContext)_localctx).Op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !(((((_la - 137)) & ~0x3f) == 0 && ((1L << (_la - 137)) & ((1L << (INC - 137)) | (1L << (DEC - 137)) | (1L << (PLUS - 137)) | (1L << (MINUS - 137)) | (1L << (TILDE - 137)) | (1L << (ADDROF - 137)))) != 0)) ) {
					((PrefixExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 307; ((PrefixExpressionContext)_localctx).Expr = expression(27);
				}
				break;
			case 2:
				{
				_localctx = new PrefixExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 308;
				((PrefixExpressionContext)_localctx).Op = TokenStream.Lt(1);
				_la = TokenStream.La(1);
				if ( !(((((_la - 135)) & ~0x3f) == 0 && ((1L << (_la - 135)) & ((1L << (LOGIC_NOT - 135)) | (1L << (LOGIC_XOR - 135)) | (1L << (NOT - 135)))) != 0)) ) {
					((PrefixExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
				}
				else {
				    Consume();
				}
				State = 309; ((PrefixExpressionContext)_localctx).Expr = expression(18);
				}
				break;
			case 3:
				{
				_localctx = new TypeCastContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 310; Match(LPAREN);
				State = 311; ((TypeCastContext)_localctx).Type = datatype();
				State = 312; Match(RPAREN);
				State = 313; ((TypeCastContext)_localctx).Expr = expression(7);
				}
				break;
			case 4:
				{
				_localctx = new CtorCallContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 315; ((CtorCallContext)_localctx).Type = datatype();
				State = 316; Match(LCURLY);
				State = 318;
				_la = TokenStream.La(1);
				if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
					{
					State = 317; ((CtorCallContext)_localctx).ArgList = argumentList();
					}
				}

				State = 320; Match(RCURLY);
				}
				break;
			case 5:
				{
				_localctx = new LiteralExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 322; ((LiteralExpressionContext)_localctx).Literal = literalValue();
				}
				break;
			case 6:
				{
				_localctx = new LiteralArrayExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 323; ((LiteralArrayExpressionContext)_localctx).LiteralArray = literalArray();
				}
				break;
			case 7:
				{
				_localctx = new CodeblockExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 324; ((CodeblockExpressionContext)_localctx).CbExpr = codeblock();
				}
				break;
			case 8:
				{
				_localctx = new TypeOfExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 325; Match(TYPEOF);
				State = 326; Match(LPAREN);
				State = 327; ((TypeOfExpressionContext)_localctx).Type = datatype();
				State = 328; Match(RPAREN);
				}
				break;
			case 9:
				{
				_localctx = new SizeOfExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 330; Match(SIZEOF);
				State = 331; Match(LPAREN);
				State = 332; ((SizeOfExpressionContext)_localctx).Type = datatype();
				State = 333; Match(RPAREN);
				}
				break;
			case 10:
				{
				_localctx = new NameExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 335; ((NameExpressionContext)_localctx).Name = name(0);
				}
				break;
			case 11:
				{
				_localctx = new TypeExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 336; ((TypeExpressionContext)_localctx).Type = nativeType();
				}
				break;
			case 12:
				{
				_localctx = new IifExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 337; ((IifExpressionContext)_localctx).Expr = iif();
				}
				break;
			case 13:
				{
				_localctx = new ParenExpressionContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 338; Match(LPAREN);
				State = 339; ((ParenExpressionContext)_localctx).Expr = expression(0);
				State = 340; Match(RPAREN);
				}
				break;
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 399;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,32,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 397;
					switch ( Interpreter.AdaptivePredict(TokenStream,31,Context) ) {
					case 1:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 344;
						if (!(Precpred(Context, 26))) throw new FailedPredicateException(this, "Precpred(Context, 26)");
						State = 345; ((BinaryExpressionContext)_localctx).Op = Match(EXP);
						State = 346; ((BinaryExpressionContext)_localctx).Right = expression(27);
						}
						break;
					case 2:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 347;
						if (!(Precpred(Context, 25))) throw new FailedPredicateException(this, "Precpred(Context, 25)");
						State = 348;
						((BinaryExpressionContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(((((_la - 144)) & ~0x3f) == 0 && ((1L << (_la - 144)) & ((1L << (DIV - 144)) | (1L << (MOD - 144)) | (1L << (MULT - 144)))) != 0)) ) {
							((BinaryExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						State = 349; ((BinaryExpressionContext)_localctx).Right = expression(26);
						}
						break;
					case 3:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 350;
						if (!(Precpred(Context, 24))) throw new FailedPredicateException(this, "Precpred(Context, 24)");
						State = 351;
						((BinaryExpressionContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(_la==PLUS || _la==MINUS) ) {
							((BinaryExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						State = 352; ((BinaryExpressionContext)_localctx).Right = expression(25);
						}
						break;
					case 4:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 353;
						if (!(Precpred(Context, 23))) throw new FailedPredicateException(this, "Precpred(Context, 23)");
						State = 354;
						((BinaryExpressionContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(_la==LSHIFT || _la==RSHIFT) ) {
							((BinaryExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						State = 355; ((BinaryExpressionContext)_localctx).Right = expression(24);
						}
						break;
					case 5:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 356;
						if (!(Precpred(Context, 22))) throw new FailedPredicateException(this, "Precpred(Context, 22)");
						State = 357;
						((BinaryExpressionContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(((((_la - 163)) & ~0x3f) == 0 && ((1L << (_la - 163)) & ((1L << (LT - 163)) | (1L << (LTE - 163)) | (1L << (GT - 163)) | (1L << (GTE - 163)) | (1L << (EQ - 163)) | (1L << (EEQ - 163)) | (1L << (SUBSTR - 163)) | (1L << (NEQ - 163)))) != 0)) ) {
							((BinaryExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						State = 358; ((BinaryExpressionContext)_localctx).Right = expression(23);
						}
						break;
					case 6:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 359;
						if (!(Precpred(Context, 21))) throw new FailedPredicateException(this, "Precpred(Context, 21)");
						State = 360; ((BinaryExpressionContext)_localctx).Op = Match(AMP);
						State = 361; ((BinaryExpressionContext)_localctx).Right = expression(22);
						}
						break;
					case 7:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 362;
						if (!(Precpred(Context, 20))) throw new FailedPredicateException(this, "Precpred(Context, 20)");
						State = 363; ((BinaryExpressionContext)_localctx).Op = Match(TILDE);
						State = 364; ((BinaryExpressionContext)_localctx).Right = expression(21);
						}
						break;
					case 8:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 365;
						if (!(Precpred(Context, 19))) throw new FailedPredicateException(this, "Precpred(Context, 19)");
						State = 366; ((BinaryExpressionContext)_localctx).Op = Match(PIPE);
						State = 367; ((BinaryExpressionContext)_localctx).Right = expression(20);
						}
						break;
					case 9:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 368;
						if (!(Precpred(Context, 17))) throw new FailedPredicateException(this, "Precpred(Context, 17)");
						State = 369; ((BinaryExpressionContext)_localctx).Op = Match(LOGIC_AND);
						State = 370; ((BinaryExpressionContext)_localctx).Right = expression(18);
						}
						break;
					case 10:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 371;
						if (!(Precpred(Context, 16))) throw new FailedPredicateException(this, "Precpred(Context, 16)");
						State = 372; ((BinaryExpressionContext)_localctx).Op = Match(LOGIC_XOR);
						State = 373; ((BinaryExpressionContext)_localctx).Right = expression(17);
						}
						break;
					case 11:
						{
						_localctx = new BinaryExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((BinaryExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 374;
						if (!(Precpred(Context, 15))) throw new FailedPredicateException(this, "Precpred(Context, 15)");
						State = 375; ((BinaryExpressionContext)_localctx).Op = Match(LOGIC_OR);
						State = 376; ((BinaryExpressionContext)_localctx).Right = expression(16);
						}
						break;
					case 12:
						{
						_localctx = new AssignmentExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((AssignmentExpressionContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 377;
						if (!(Precpred(Context, 14))) throw new FailedPredicateException(this, "Precpred(Context, 14)");
						State = 378;
						((AssignmentExpressionContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(((((_la - 151)) & ~0x3f) == 0 && ((1L << (_la - 151)) & ((1L << (ASSIGN_OP - 151)) | (1L << (ASSIGN_ADD - 151)) | (1L << (ASSIGN_EXP - 151)) | (1L << (ASSIGN_MUL - 151)) | (1L << (ASSIGN_DIV - 151)) | (1L << (ASSIGN_MOD - 151)) | (1L << (ASSIGN_BITAND - 151)) | (1L << (ASSIGN_BITOR - 151)) | (1L << (ASSIGN_LSHIFT - 151)) | (1L << (ASSIGN_RSHIFT - 151)) | (1L << (ASSIGN_XOR - 151)))) != 0)) ) {
							((AssignmentExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						State = 379; ((AssignmentExpressionContext)_localctx).Right = expression(15);
						}
						break;
					case 13:
						{
						_localctx = new AccessMemberContext(new ExpressionContext(_parentctx, _parentState));
						((AccessMemberContext)_localctx).Left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 380;
						if (!(Precpred(Context, 29))) throw new FailedPredicateException(this, "Precpred(Context, 29)");
						State = 381;
						((AccessMemberContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(_la==COLON || _la==DOT) ) {
							((AccessMemberContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						State = 382; ((AccessMemberContext)_localctx).Right = identifierName();
						}
						break;
					case 14:
						{
						_localctx = new PostfixExpressionContext(new ExpressionContext(_parentctx, _parentState));
						((PostfixExpressionContext)_localctx).Expr = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 383;
						if (!(Precpred(Context, 28))) throw new FailedPredicateException(this, "Precpred(Context, 28)");
						State = 384;
						((PostfixExpressionContext)_localctx).Op = TokenStream.Lt(1);
						_la = TokenStream.La(1);
						if ( !(_la==INC || _la==DEC) ) {
							((PostfixExpressionContext)_localctx).Op = ErrorHandler.RecoverInline(this);
						}
						else {
						    Consume();
						}
						}
						break;
					case 15:
						{
						_localctx = new MethodCallContext(new ExpressionContext(_parentctx, _parentState));
						((MethodCallContext)_localctx).Expr = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 385;
						if (!(Precpred(Context, 13))) throw new FailedPredicateException(this, "Precpred(Context, 13)");
						State = 386; Match(LPAREN);
						State = 388;
						_la = TokenStream.La(1);
						if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
							{
							State = 387; ((MethodCallContext)_localctx).ArgList = argumentList();
							}
						}

						State = 390; Match(RPAREN);
						}
						break;
					case 16:
						{
						_localctx = new ArrayAccessContext(new ExpressionContext(_parentctx, _parentState));
						((ArrayAccessContext)_localctx).Expr = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_expression);
						State = 391;
						if (!(Precpred(Context, 12))) throw new FailedPredicateException(this, "Precpred(Context, 12)");
						State = 392; Match(LBRKT);
						State = 394;
						_la = TokenStream.La(1);
						if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
							{
							State = 393; ((ArrayAccessContext)_localctx).ArgList = expressionList();
							}
						}

						State = 396; Match(RBRKT);
						}
						break;
					}
					} 
				}
				State = 401;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,32,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		public ExpressionContext _expression;
		public IList<ExpressionContext> _Exprs = new List<ExpressionContext>();
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(Context, State);
		EnterRule(_localctx, 22, RULE_expressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 402; _localctx._expression = expression(0);
			_localctx._Exprs.Add(_localctx._expression);
			State = 407;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 403; Match(COMMA);
				State = 404; _localctx._expression = expression(0);
				_localctx._Exprs.Add(_localctx._expression);
				}
				}
				State = 409;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		public ArgumentContext _argument;
		public IList<ArgumentContext> _Args = new List<ArgumentContext>();
		public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(Context, State);
		EnterRule(_localctx, 24, RULE_argumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 410; _localctx._argument = argument();
			_localctx._Args.Add(_localctx._argument);
			State = 417;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 411; Match(COMMA);
				State = 413;
				_la = TokenStream.La(1);
				if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
					{
					State = 412; _localctx._argument = argument();
					_localctx._Args.Add(_localctx._argument);
					}
				}

				}
				}
				State = 419;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		public ExpressionContext Expr;
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 26, RULE_argument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 420; _localctx.Expr = expression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IifContext : ParserRuleContext {
		public ExpressionContext Cond;
		public ExpressionContext TrueExpr;
		public ExpressionContext FalseExpr;
		public ITerminalNode IIF() { return GetToken(XSharpParser.IIF, 0); }
		public ITerminalNode LPAREN() { return GetToken(XSharpParser.LPAREN, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public ITerminalNode RPAREN() { return GetToken(XSharpParser.RPAREN, 0); }
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public IifContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_iif; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterIif(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitIif(this);
		}
	}

	[RuleVersion(0)]
	public IifContext iif() {
		IifContext _localctx = new IifContext(Context, State);
		EnterRule(_localctx, 28, RULE_iif);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 422; Match(IIF);
			State = 423; Match(LPAREN);
			State = 424; _localctx.Cond = expression(0);
			State = 425; Match(COMMA);
			State = 426; _localctx.TrueExpr = expression(0);
			State = 427; Match(COMMA);
			State = 428; _localctx.FalseExpr = expression(0);
			State = 429; Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
	 
		public NameContext() { }
		public virtual void CopyFrom(NameContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class GenericNameContext : NameContext {
		public IdentifierContext Id;
		public GenericArgumentListContext GenericArgList;
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public GenericArgumentListContext genericArgumentList() {
			return GetRuleContext<GenericArgumentListContext>(0);
		}
		public GenericNameContext(NameContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterGenericName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitGenericName(this);
		}
	}
	public partial class SimpleNameContext : NameContext {
		public IdentifierContext Id;
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public SimpleNameContext(NameContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterSimpleName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitSimpleName(this);
		}
	}
	public partial class QualifiedNameContext : NameContext {
		public NameContext Left;
		public IToken Op;
		public IdentifierContext Right;
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode DOT() { return GetToken(XSharpParser.DOT, 0); }
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public QualifiedNameContext(NameContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterQualifiedName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitQualifiedName(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		return name(0);
	}

	private NameContext name(int _p) {
		ParserRuleContext _parentctx = Context;
		int _parentState = State;
		NameContext _localctx = new NameContext(Context, _parentState);
		NameContext _prevctx = _localctx;
		int _startState = 30;
		EnterRecursionRule(_localctx, 30, RULE_name, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 436;
			switch ( Interpreter.AdaptivePredict(TokenStream,36,Context) ) {
			case 1:
				{
				_localctx = new GenericNameContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;

				State = 432; ((GenericNameContext)_localctx).Id = identifier();
				State = 433; ((GenericNameContext)_localctx).GenericArgList = genericArgumentList();
				}
				break;
			case 2:
				{
				_localctx = new SimpleNameContext(_localctx);
				Context = _localctx;
				_prevctx = _localctx;
				State = 435; ((SimpleNameContext)_localctx).Id = identifier();
				}
				break;
			}
			Context.Stop = TokenStream.Lt(-1);
			State = 443;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( ParseListeners!=null )
						TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					{
					_localctx = new QualifiedNameContext(new NameContext(_parentctx, _parentState));
					((QualifiedNameContext)_localctx).Left = _prevctx;
					PushNewRecursionContext(_localctx, _startState, RULE_name);
					State = 438;
					if (!(Precpred(Context, 3))) throw new FailedPredicateException(this, "Precpred(Context, 3)");
					State = 439; ((QualifiedNameContext)_localctx).Op = Match(DOT);
					State = 440; ((QualifiedNameContext)_localctx).Right = identifier();
					}
					} 
				}
				State = 445;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,37,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class GenericArgumentListContext : ParserRuleContext {
		public DatatypeContext _datatype;
		public IList<DatatypeContext> _GenericArgs = new List<DatatypeContext>();
		public ITerminalNode LT() { return GetToken(XSharpParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(XSharpParser.GT, 0); }
		public DatatypeContext[] datatype() {
			return GetRuleContexts<DatatypeContext>();
		}
		public DatatypeContext datatype(int i) {
			return GetRuleContext<DatatypeContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public GenericArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_genericArgumentList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterGenericArgumentList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitGenericArgumentList(this);
		}
	}

	[RuleVersion(0)]
	public GenericArgumentListContext genericArgumentList() {
		GenericArgumentListContext _localctx = new GenericArgumentListContext(Context, State);
		EnterRule(_localctx, 32, RULE_genericArgumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 446; Match(LT);
			State = 447; _localctx._datatype = datatype();
			_localctx._GenericArgs.Add(_localctx._datatype);
			State = 452;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 448; Match(COMMA);
				State = 449; _localctx._datatype = datatype();
				_localctx._GenericArgs.Add(_localctx._datatype);
				}
				}
				State = 454;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 455; Match(GT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierNameContext : ParserRuleContext {
		public IdentifierContext Id;
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public IdentifierNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterIdentifierName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitIdentifierName(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierNameContext identifierName() {
		IdentifierNameContext _localctx = new IdentifierNameContext(Context, State);
		EnterRule(_localctx, 34, RULE_identifierName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 457; _localctx.Id = identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatatypeContext : ParserRuleContext {
		public DatatypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_datatype; } }
	 
		public DatatypeContext() { }
		public virtual void CopyFrom(DatatypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class PtrDatatypeContext : DatatypeContext {
		public TypeNameContext TypeName;
		public ITerminalNode PTR() { return GetToken(XSharpParser.PTR, 0); }
		public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		public PtrDatatypeContext(DatatypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterPtrDatatype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitPtrDatatype(this);
		}
	}
	public partial class ArrayDatatypeContext : DatatypeContext {
		public TypeNameContext TypeName;
		public ArrayRankContext _arrayRank;
		public IList<ArrayRankContext> _Ranks = new List<ArrayRankContext>();
		public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		public ArrayRankContext[] arrayRank() {
			return GetRuleContexts<ArrayRankContext>();
		}
		public ArrayRankContext arrayRank(int i) {
			return GetRuleContext<ArrayRankContext>(i);
		}
		public ArrayDatatypeContext(DatatypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterArrayDatatype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitArrayDatatype(this);
		}
	}
	public partial class SimpleDatatypeContext : DatatypeContext {
		public TypeNameContext TypeName;
		public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		public SimpleDatatypeContext(DatatypeContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterSimpleDatatype(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitSimpleDatatype(this);
		}
	}

	[RuleVersion(0)]
	public DatatypeContext datatype() {
		DatatypeContext _localctx = new DatatypeContext(Context, State);
		EnterRule(_localctx, 36, RULE_datatype);
		int _la;
		try {
			State = 470;
			switch ( Interpreter.AdaptivePredict(TokenStream,40,Context) ) {
			case 1:
				_localctx = new PtrDatatypeContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 459; ((PtrDatatypeContext)_localctx).TypeName = typeName();
				State = 460; Match(PTR);
				}
				break;
			case 2:
				_localctx = new ArrayDatatypeContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 462; ((ArrayDatatypeContext)_localctx).TypeName = typeName();
				State = 466;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
				while (_la==LBRKT) {
					{
					{
					State = 463; ((ArrayDatatypeContext)_localctx)._arrayRank = arrayRank();
					((ArrayDatatypeContext)_localctx)._Ranks.Add(((ArrayDatatypeContext)_localctx)._arrayRank);
					}
					}
					State = 468;
					ErrorHandler.Sync(this);
					_la = TokenStream.La(1);
				}
				}
				break;
			case 3:
				_localctx = new SimpleDatatypeContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 469; ((SimpleDatatypeContext)_localctx).TypeName = typeName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrayRankContext : ParserRuleContext {
		public ITerminalNode LBRKT() { return GetToken(XSharpParser.LBRKT, 0); }
		public ITerminalNode RBRKT() { return GetToken(XSharpParser.RBRKT, 0); }
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public ArrayRankContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrayRank; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterArrayRank(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitArrayRank(this);
		}
	}

	[RuleVersion(0)]
	public ArrayRankContext arrayRank() {
		ArrayRankContext _localctx = new ArrayRankContext(Context, State);
		EnterRule(_localctx, 38, RULE_arrayRank);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 472; Match(LBRKT);
			State = 476;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 473; Match(COMMA);
				}
				}
				State = 478;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			State = 479; Match(RBRKT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		public NameContext Name;
		public NativeTypeContext NativeType;
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public NativeTypeContext nativeType() {
			return GetRuleContext<NativeTypeContext>(0);
		}
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterTypeName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitTypeName(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 40, RULE_typeName);
		try {
			State = 483;
			switch (TokenStream.La(1)) {
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 481; _localctx.Name = name(0);
				}
				break;
			case ARRAY:
			case BYTE:
			case CODEBLOCK:
			case DATE:
			case DWORD:
			case FLOAT:
			case INT:
			case INT64:
			case LOGIC:
			case LONGINT:
			case OBJECT:
			case PSZ:
			case PTR:
			case REAL4:
			case REAL8:
			case SHORTINT:
			case STRING:
			case SYMBOL:
			case USUAL:
			case UINT64:
			case VOID:
			case WORD:
				EnterOuterAlt(_localctx, 2);
				{
				State = 482; _localctx.NativeType = nativeType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralArrayContext : ParserRuleContext {
		public DatatypeContext Type;
		public ExpressionListContext ExprList;
		public ITerminalNode LCURLY() { return GetToken(XSharpParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(XSharpParser.RCURLY, 0); }
		public ITerminalNode LT() { return GetToken(XSharpParser.LT, 0); }
		public ITerminalNode GT() { return GetToken(XSharpParser.GT, 0); }
		public DatatypeContext datatype() {
			return GetRuleContext<DatatypeContext>(0);
		}
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public LiteralArrayContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalArray; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterLiteralArray(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitLiteralArray(this);
		}
	}

	[RuleVersion(0)]
	public LiteralArrayContext literalArray() {
		LiteralArrayContext _localctx = new LiteralArrayContext(Context, State);
		EnterRule(_localctx, 42, RULE_literalArray);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 489;
			_la = TokenStream.La(1);
			if (_la==LT) {
				{
				State = 485; Match(LT);
				State = 486; _localctx.Type = datatype();
				State = 487; Match(GT);
				}
			}

			State = 491; Match(LCURLY);
			State = 493;
			_la = TokenStream.La(1);
			if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
				{
				State = 492; _localctx.ExprList = expressionList();
				}
			}

			State = 495; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CodeblockContext : ParserRuleContext {
		public CodeblockParamListContext CbParamList;
		public ExpressionContext Expr;
		public ITerminalNode LCURLY() { return GetToken(XSharpParser.LCURLY, 0); }
		public ITerminalNode RCURLY() { return GetToken(XSharpParser.RCURLY, 0); }
		public ITerminalNode OR() { return GetToken(XSharpParser.OR, 0); }
		public ITerminalNode[] PIPE() { return GetTokens(XSharpParser.PIPE); }
		public ITerminalNode PIPE(int i) {
			return GetToken(XSharpParser.PIPE, i);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CodeblockParamListContext codeblockParamList() {
			return GetRuleContext<CodeblockParamListContext>(0);
		}
		public CodeblockContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_codeblock; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterCodeblock(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitCodeblock(this);
		}
	}

	[RuleVersion(0)]
	public CodeblockContext codeblock() {
		CodeblockContext _localctx = new CodeblockContext(Context, State);
		EnterRule(_localctx, 44, RULE_codeblock);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 497; Match(LCURLY);
			State = 504;
			switch (TokenStream.La(1)) {
			case OR:
				{
				State = 498; Match(OR);
				}
				break;
			case PIPE:
				{
				State = 499; Match(PIPE);
				State = 501;
				_la = TokenStream.La(1);
				if (_la==ID) {
					{
					State = 500; _localctx.CbParamList = codeblockParamList();
					}
				}

				State = 503; Match(PIPE);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 507;
			_la = TokenStream.La(1);
			if (_la==IIF || ((((_la - 80)) & ~0x3f) == 0 && ((1L << (_la - 80)) & ((1L << (SIZEOF - 80)) | (1L << (TYPEOF - 80)) | (1L << (ARRAY - 80)) | (1L << (BYTE - 80)) | (1L << (CODEBLOCK - 80)) | (1L << (DATE - 80)) | (1L << (DWORD - 80)) | (1L << (FLOAT - 80)) | (1L << (INT - 80)) | (1L << (INT64 - 80)) | (1L << (LOGIC - 80)) | (1L << (LONGINT - 80)) | (1L << (OBJECT - 80)) | (1L << (PSZ - 80)) | (1L << (PTR - 80)) | (1L << (REAL4 - 80)) | (1L << (REAL8 - 80)) | (1L << (SHORTINT - 80)) | (1L << (STRING - 80)) | (1L << (SYMBOL - 80)) | (1L << (USUAL - 80)) | (1L << (UINT64 - 80)) | (1L << (VOID - 80)) | (1L << (WORD - 80)) | (1L << (NIL - 80)) | (1L << (NULL - 80)) | (1L << (NULL_ARRAY - 80)) | (1L << (NULL_CODEBLOCK - 80)) | (1L << (NULL_DATE - 80)) | (1L << (NULL_OBJECT - 80)) | (1L << (NULL_PSZ - 80)) | (1L << (NULL_PTR - 80)) | (1L << (NULL_STRING - 80)) | (1L << (NULL_SYMBOL - 80)) | (1L << (FALSE_CONST - 80)) | (1L << (TRUE_CONST - 80)) | (1L << (LOGIC_NOT - 80)) | (1L << (LOGIC_XOR - 80)) | (1L << (INC - 80)) | (1L << (DEC - 80)) | (1L << (NOT - 80)) | (1L << (PLUS - 80)) | (1L << (MINUS - 80)))) != 0) || ((((_la - 149)) & ~0x3f) == 0 && ((1L << (_la - 149)) & ((1L << (TILDE - 149)) | (1L << (LT - 149)) | (1L << (LPAREN - 149)) | (1L << (LCURLY - 149)) | (1L << (ADDROF - 149)) | (1L << (HEX_CONST - 149)) | (1L << (BIN_CONST - 149)) | (1L << (INT_CONST - 149)) | (1L << (DATE_CONST - 149)) | (1L << (REAL_CONST - 149)) | (1L << (SYMBOL_CONST - 149)) | (1L << (STRING_CONST - 149)) | (1L << (ID - 149)))) != 0)) {
				{
				State = 506; _localctx.Expr = expression(0);
				}
			}

			State = 509; Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CodeblockParamListContext : ParserRuleContext {
		public IdentifierContext _identifier;
		public IList<IdentifierContext> _Ids = new List<IdentifierContext>();
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(XSharpParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(XSharpParser.COMMA, i);
		}
		public CodeblockParamListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_codeblockParamList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterCodeblockParamList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitCodeblockParamList(this);
		}
	}

	[RuleVersion(0)]
	public CodeblockParamListContext codeblockParamList() {
		CodeblockParamListContext _localctx = new CodeblockParamListContext(Context, State);
		EnterRule(_localctx, 46, RULE_codeblockParamList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 511; _localctx._identifier = identifier();
			_localctx._Ids.Add(_localctx._identifier);
			State = 516;
			ErrorHandler.Sync(this);
			_la = TokenStream.La(1);
			while (_la==COMMA) {
				{
				{
				State = 512; Match(COMMA);
				State = 513; _localctx._identifier = identifier();
				_localctx._Ids.Add(_localctx._identifier);
				}
				}
				State = 518;
				ErrorHandler.Sync(this);
				_la = TokenStream.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public IToken Token;
		public ITerminalNode ID() { return GetToken(XSharpParser.ID, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(Context, State);
		EnterRule(_localctx, 48, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 519; _localctx.Token = Match(ID);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NativeTypeContext : ParserRuleContext {
		public IToken Token;
		public ITerminalNode ARRAY() { return GetToken(XSharpParser.ARRAY, 0); }
		public ITerminalNode BYTE() { return GetToken(XSharpParser.BYTE, 0); }
		public ITerminalNode CODEBLOCK() { return GetToken(XSharpParser.CODEBLOCK, 0); }
		public ITerminalNode DATE() { return GetToken(XSharpParser.DATE, 0); }
		public ITerminalNode DWORD() { return GetToken(XSharpParser.DWORD, 0); }
		public ITerminalNode FLOAT() { return GetToken(XSharpParser.FLOAT, 0); }
		public ITerminalNode SHORTINT() { return GetToken(XSharpParser.SHORTINT, 0); }
		public ITerminalNode INT() { return GetToken(XSharpParser.INT, 0); }
		public ITerminalNode INT64() { return GetToken(XSharpParser.INT64, 0); }
		public ITerminalNode LOGIC() { return GetToken(XSharpParser.LOGIC, 0); }
		public ITerminalNode LONGINT() { return GetToken(XSharpParser.LONGINT, 0); }
		public ITerminalNode OBJECT() { return GetToken(XSharpParser.OBJECT, 0); }
		public ITerminalNode PSZ() { return GetToken(XSharpParser.PSZ, 0); }
		public ITerminalNode PTR() { return GetToken(XSharpParser.PTR, 0); }
		public ITerminalNode REAL4() { return GetToken(XSharpParser.REAL4, 0); }
		public ITerminalNode REAL8() { return GetToken(XSharpParser.REAL8, 0); }
		public ITerminalNode STRING() { return GetToken(XSharpParser.STRING, 0); }
		public ITerminalNode SYMBOL() { return GetToken(XSharpParser.SYMBOL, 0); }
		public ITerminalNode USUAL() { return GetToken(XSharpParser.USUAL, 0); }
		public ITerminalNode UINT64() { return GetToken(XSharpParser.UINT64, 0); }
		public ITerminalNode WORD() { return GetToken(XSharpParser.WORD, 0); }
		public ITerminalNode VOID() { return GetToken(XSharpParser.VOID, 0); }
		public NativeTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nativeType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterNativeType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitNativeType(this);
		}
	}

	[RuleVersion(0)]
	public NativeTypeContext nativeType() {
		NativeTypeContext _localctx = new NativeTypeContext(Context, State);
		EnterRule(_localctx, 50, RULE_nativeType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 521;
			_localctx.Token = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !(((((_la - 97)) & ~0x3f) == 0 && ((1L << (_la - 97)) & ((1L << (ARRAY - 97)) | (1L << (BYTE - 97)) | (1L << (CODEBLOCK - 97)) | (1L << (DATE - 97)) | (1L << (DWORD - 97)) | (1L << (FLOAT - 97)) | (1L << (INT - 97)) | (1L << (INT64 - 97)) | (1L << (LOGIC - 97)) | (1L << (LONGINT - 97)) | (1L << (OBJECT - 97)) | (1L << (PSZ - 97)) | (1L << (PTR - 97)) | (1L << (REAL4 - 97)) | (1L << (REAL8 - 97)) | (1L << (SHORTINT - 97)) | (1L << (STRING - 97)) | (1L << (SYMBOL - 97)) | (1L << (USUAL - 97)) | (1L << (UINT64 - 97)) | (1L << (VOID - 97)) | (1L << (WORD - 97)))) != 0)) ) {
				_localctx.Token = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralValueContext : ParserRuleContext {
		public IToken Token;
		public ITerminalNode TRUE_CONST() { return GetToken(XSharpParser.TRUE_CONST, 0); }
		public ITerminalNode FALSE_CONST() { return GetToken(XSharpParser.FALSE_CONST, 0); }
		public ITerminalNode STRING_CONST() { return GetToken(XSharpParser.STRING_CONST, 0); }
		public ITerminalNode SYMBOL_CONST() { return GetToken(XSharpParser.SYMBOL_CONST, 0); }
		public ITerminalNode HEX_CONST() { return GetToken(XSharpParser.HEX_CONST, 0); }
		public ITerminalNode BIN_CONST() { return GetToken(XSharpParser.BIN_CONST, 0); }
		public ITerminalNode REAL_CONST() { return GetToken(XSharpParser.REAL_CONST, 0); }
		public ITerminalNode INT_CONST() { return GetToken(XSharpParser.INT_CONST, 0); }
		public ITerminalNode DATE_CONST() { return GetToken(XSharpParser.DATE_CONST, 0); }
		public ITerminalNode NIL() { return GetToken(XSharpParser.NIL, 0); }
		public ITerminalNode NULL() { return GetToken(XSharpParser.NULL, 0); }
		public ITerminalNode NULL_ARRAY() { return GetToken(XSharpParser.NULL_ARRAY, 0); }
		public ITerminalNode NULL_CODEBLOCK() { return GetToken(XSharpParser.NULL_CODEBLOCK, 0); }
		public ITerminalNode NULL_DATE() { return GetToken(XSharpParser.NULL_DATE, 0); }
		public ITerminalNode NULL_OBJECT() { return GetToken(XSharpParser.NULL_OBJECT, 0); }
		public ITerminalNode NULL_PSZ() { return GetToken(XSharpParser.NULL_PSZ, 0); }
		public ITerminalNode NULL_PTR() { return GetToken(XSharpParser.NULL_PTR, 0); }
		public ITerminalNode NULL_STRING() { return GetToken(XSharpParser.NULL_STRING, 0); }
		public ITerminalNode NULL_SYMBOL() { return GetToken(XSharpParser.NULL_SYMBOL, 0); }
		public LiteralValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literalValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterLiteralValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitLiteralValue(this);
		}
	}

	[RuleVersion(0)]
	public LiteralValueContext literalValue() {
		LiteralValueContext _localctx = new LiteralValueContext(Context, State);
		EnterRule(_localctx, 52, RULE_literalValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 523;
			_localctx.Token = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !(((((_la - 121)) & ~0x3f) == 0 && ((1L << (_la - 121)) & ((1L << (NIL - 121)) | (1L << (NULL - 121)) | (1L << (NULL_ARRAY - 121)) | (1L << (NULL_CODEBLOCK - 121)) | (1L << (NULL_DATE - 121)) | (1L << (NULL_OBJECT - 121)) | (1L << (NULL_PSZ - 121)) | (1L << (NULL_PTR - 121)) | (1L << (NULL_STRING - 121)) | (1L << (NULL_SYMBOL - 121)) | (1L << (FALSE_CONST - 121)) | (1L << (TRUE_CONST - 121)) | (1L << (HEX_CONST - 121)))) != 0) || ((((_la - 185)) & ~0x3f) == 0 && ((1L << (_la - 185)) & ((1L << (BIN_CONST - 185)) | (1L << (INT_CONST - 185)) | (1L << (DATE_CONST - 185)) | (1L << (REAL_CONST - 185)) | (1L << (SYMBOL_CONST - 185)) | (1L << (STRING_CONST - 185)))) != 0)) ) {
				_localctx.Token = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AccessModifierContext : ParserRuleContext {
		public IToken Token;
		public ITerminalNode PUBLIC() { return GetToken(XSharpParser.PUBLIC, 0); }
		public ITerminalNode PRIVATE() { return GetToken(XSharpParser.PRIVATE, 0); }
		public ITerminalNode INTERNAL() { return GetToken(XSharpParser.INTERNAL, 0); }
		public ITerminalNode PROTECTED() { return GetToken(XSharpParser.PROTECTED, 0); }
		public ITerminalNode EXPORT() { return GetToken(XSharpParser.EXPORT, 0); }
		public ITerminalNode HIDDEN() { return GetToken(XSharpParser.HIDDEN, 0); }
		public AccessModifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_accessModifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterAccessModifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitAccessModifier(this);
		}
	}

	[RuleVersion(0)]
	public AccessModifierContext accessModifier() {
		AccessModifierContext _localctx = new AccessModifierContext(Context, State);
		EnterRule(_localctx, 54, RULE_accessModifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 525;
			_localctx.Token = TokenStream.Lt(1);
			_la = TokenStream.La(1);
			if ( !(((((_la - 32)) & ~0x3f) == 0 && ((1L << (_la - 32)) & ((1L << (EXPORT - 32)) | (1L << (HIDDEN - 32)) | (1L << (INTERNAL - 32)) | (1L << (PRIVATE - 32)) | (1L << (PROTECTED - 32)) | (1L << (PUBLIC - 32)))) != 0)) ) {
				_localctx.Token = ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EosContext : ParserRuleContext {
		public ITerminalNode[] NL() { return GetTokens(XSharpParser.NL); }
		public ITerminalNode NL(int i) {
			return GetToken(XSharpParser.NL, i);
		}
		public ITerminalNode Eof() { return GetToken(XSharpParser.Eof, 0); }
		public EosContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eos; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterEos(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitEos(this);
		}
	}

	[RuleVersion(0)]
	public EosContext eos() {
		EosContext _localctx = new EosContext(Context, State);
		EnterRule(_localctx, 56, RULE_eos);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 530;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 527; Match(NL);
					}
					} 
				}
				State = 532;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,49,Context);
			}
			State = 533;
			_la = TokenStream.La(1);
			if ( !(_la==Eof || _la==NL) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EofContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(XSharpParser.Eof, 0); }
		public EofContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_eof; } }
		public override void EnterRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.EnterEof(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IXSharpListener typedListener = listener as IXSharpListener;
			if (typedListener != null) typedListener.ExitEof(this);
		}
	}

	[RuleVersion(0)]
	public EofContext eof() {
		EofContext _localctx = new EofContext(Context, State);
		EnterRule(_localctx, 58, RULE_eof);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 535; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 10: return expression_sempred((ExpressionContext)_localctx, predIndex);
		case 15: return name_sempred((NameContext)_localctx, predIndex);
		}
		return true;
	}
	private bool expression_sempred(ExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(Context, 26);
		case 1: return Precpred(Context, 25);
		case 2: return Precpred(Context, 24);
		case 3: return Precpred(Context, 23);
		case 4: return Precpred(Context, 22);
		case 5: return Precpred(Context, 21);
		case 6: return Precpred(Context, 20);
		case 7: return Precpred(Context, 19);
		case 8: return Precpred(Context, 17);
		case 9: return Precpred(Context, 16);
		case 10: return Precpred(Context, 15);
		case 11: return Precpred(Context, 14);
		case 12: return Precpred(Context, 29);
		case 13: return Precpred(Context, 28);
		case 14: return Precpred(Context, 13);
		case 15: return Precpred(Context, 12);
		}
		return true;
	}
	private bool name_sempred(NameContext _localctx, int predIndex) {
		switch (predIndex) {
		case 16: return Precpred(Context, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\x430\xD6D1\x8206\xAD2D\x4417\xAEF1\x8D80\xAADD\x3\xC5\x21C\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x3\x2\x5\x2"+
		"@\n\x2\x3\x2\a\x2\x43\n\x2\f\x2\xE\x2\x46\v\x2\x3\x2\x3\x2\x3\x3\x3\x3"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3"+
		"\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6\a\x6^\n\x6\f\x6\xE\x6\x61\v\x6"+
		"\x5\x6\x63\n\x6\x3\x6\x3\x6\x3\a\x3\a\x3\a\x5\aj\n\a\x3\a\x3\a\x5\an\n"+
		"\a\x3\a\x3\a\x3\b\a\bs\n\b\f\b\xE\bv\v\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t"+
		"\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t"+
		"\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x97\n\t\x3"+
		"\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\xA5\n\t"+
		"\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\xB2\n\t\f"+
		"\t\xE\t\xB5\v\t\x3\t\x3\t\x3\t\x3\t\x5\t\xBB\n\t\x3\t\x3\t\x5\t\xBF\n"+
		"\t\x3\t\x5\t\xC2\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\xCB\n\t\f"+
		"\t\xE\t\xCE\v\t\x3\t\x3\t\x3\t\x3\t\x5\t\xD4\n\t\x3\t\x3\t\x5\t\xD8\n"+
		"\t\x3\t\x5\t\xDB\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t"+
		"\xE6\n\t\f\t\xE\t\xE9\v\t\x3\t\x3\t\x3\t\x3\t\x5\t\xEF\n\t\x3\t\x3\t\x3"+
		"\t\x5\t\xF4\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\a\t\xFC\n\t\f\t\xE\t\xFF"+
		"\v\t\x3\t\x3\t\x3\t\x3\t\x5\t\x105\n\t\x3\t\x3\t\x5\t\x109\n\t\x3\t\x3"+
		"\t\x3\t\x3\t\x3\t\x5\t\x110\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3"+
		"\t\x5\t\x11A\n\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x5\t\x124\n\t"+
		"\x3\t\x3\t\x5\t\x128\n\t\x3\n\x3\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v"+
		"\x3\v\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f"+
		"\x5\f\x141\n\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x5\f\x159\n\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f\x3\f"+
		"\x3\f\x3\f\x5\f\x187\n\f\x3\f\x3\f\x3\f\x3\f\x5\f\x18D\n\f\x3\f\a\f\x190"+
		"\n\f\f\f\xE\f\x193\v\f\x3\r\x3\r\x3\r\a\r\x198\n\r\f\r\xE\r\x19B\v\r\x3"+
		"\xE\x3\xE\x3\xE\x5\xE\x1A0\n\xE\a\xE\x1A2\n\xE\f\xE\xE\xE\x1A5\v\xE\x3"+
		"\xF\x3\xF\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10\x3\x10"+
		"\x3\x11\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\x1B7\n\x11\x3\x11\x3\x11\x3"+
		"\x11\a\x11\x1BC\n\x11\f\x11\xE\x11\x1BF\v\x11\x3\x12\x3\x12\x3\x12\x3"+
		"\x12\a\x12\x1C5\n\x12\f\x12\xE\x12\x1C8\v\x12\x3\x12\x3\x12\x3\x13\x3"+
		"\x13\x3\x14\x3\x14\x3\x14\x3\x14\x3\x14\a\x14\x1D3\n\x14\f\x14\xE\x14"+
		"\x1D6\v\x14\x3\x14\x5\x14\x1D9\n\x14\x3\x15\x3\x15\a\x15\x1DD\n\x15\f"+
		"\x15\xE\x15\x1E0\v\x15\x3\x15\x3\x15\x3\x16\x3\x16\x5\x16\x1E6\n\x16\x3"+
		"\x17\x3\x17\x3\x17\x3\x17\x5\x17\x1EC\n\x17\x3\x17\x3\x17\x5\x17\x1F0"+
		"\n\x17\x3\x17\x3\x17\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\x1F8\n\x18\x3"+
		"\x18\x5\x18\x1FB\n\x18\x3\x18\x5\x18\x1FE\n\x18\x3\x18\x3\x18\x3\x19\x3"+
		"\x19\x3\x19\a\x19\x205\n\x19\f\x19\xE\x19\x208\v\x19\x3\x1A\x3\x1A\x3"+
		"\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1D\x3\x1D\x3\x1E\a\x1E\x213\n\x1E\f\x1E"+
		"\xE\x1E\x216\v\x1E\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3\x1F\x2\x4\x16  \x2\x4"+
		"\x6\b\n\f\xE\x10\x12\x14\x16\x18\x1A\x1C\x1E \"$&(*,.\x30\x32\x34\x36"+
		"\x38:<\x2\x11\x5\x2\x6\x6\x42\x42ss\x5\x2\x17\x17ZZ__\x6\x2\x8B\x8C\x90"+
		"\x91\x97\x97\xB7\xB7\x4\x2\x89\x8A\x8D\x8D\x4\x2\x92\x93\x98\x98\x3\x2"+
		"\x90\x91\x3\x2\x95\x96\x3\x2\xA5\xAC\x4\x2\x99\x9A\x9C\xA4\x4\x2\xB3\xB3"+
		"\xB9\xB9\x3\x2\x8B\x8C\x5\x2\x63\x64\x66rtz\x4\x2{\x86\xBA\xC0\b\x2\""+
		"\"++\x35\x35\x45\x45GGII\x3\x3\xC3\xC3\x258\x2?\x3\x2\x2\x2\x4I\x3\x2"+
		"\x2\x2\x6K\x3\x2\x2\x2\bS\x3\x2\x2\x2\nY\x3\x2\x2\x2\f\x66\x3\x2\x2\x2"+
		"\xEt\x3\x2\x2\x2\x10\x127\x3\x2\x2\x2\x12\x129\x3\x2\x2\x2\x14\x12D\x3"+
		"\x2\x2\x2\x16\x158\x3\x2\x2\x2\x18\x194\x3\x2\x2\x2\x1A\x19C\x3\x2\x2"+
		"\x2\x1C\x1A6\x3\x2\x2\x2\x1E\x1A8\x3\x2\x2\x2 \x1B6\x3\x2\x2\x2\"\x1C0"+
		"\x3\x2\x2\x2$\x1CB\x3\x2\x2\x2&\x1D8\x3\x2\x2\x2(\x1DA\x3\x2\x2\x2*\x1E5"+
		"\x3\x2\x2\x2,\x1EB\x3\x2\x2\x2.\x1F3\x3\x2\x2\x2\x30\x201\x3\x2\x2\x2"+
		"\x32\x209\x3\x2\x2\x2\x34\x20B\x3\x2\x2\x2\x36\x20D\x3\x2\x2\x2\x38\x20F"+
		"\x3\x2\x2\x2:\x214\x3\x2\x2\x2<\x219\x3\x2\x2\x2>@\x5:\x1E\x2?>\x3\x2"+
		"\x2\x2?@\x3\x2\x2\x2@\x44\x3\x2\x2\x2\x41\x43\x5\x4\x3\x2\x42\x41\x3\x2"+
		"\x2\x2\x43\x46\x3\x2\x2\x2\x44\x42\x3\x2\x2\x2\x44\x45\x3\x2\x2\x2\x45"+
		"G\x3\x2\x2\x2\x46\x44\x3\x2\x2\x2GH\x5<\x1F\x2H\x3\x3\x2\x2\x2IJ\x5\x6"+
		"\x4\x2J\x5\x3\x2\x2\x2KL\a(\x2\x2LM\x5\x32\x1A\x2MN\x5\n\x6\x2NO\a\x6"+
		"\x2\x2OP\x5&\x14\x2PQ\x5:\x1E\x2QR\x5\xE\b\x2R\a\x3\x2\x2\x2ST\a\x46\x2"+
		"\x2TU\x5\x32\x1A\x2UV\x5\n\x6\x2VW\x5:\x1E\x2WX\x5\xE\b\x2X\t\x3\x2\x2"+
		"\x2Y\x62\a\xAD\x2\x2Z_\x5\f\a\x2[\\\a\xB4\x2\x2\\^\x5\f\a\x2][\x3\x2\x2"+
		"\x2^\x61\x3\x2\x2\x2_]\x3\x2\x2\x2_`\x3\x2\x2\x2`\x63\x3\x2\x2\x2\x61"+
		"_\x3\x2\x2\x2\x62Z\x3\x2\x2\x2\x62\x63\x3\x2\x2\x2\x63\x64\x3\x2\x2\x2"+
		"\x64\x65\a\xAE\x2\x2\x65\v\x3\x2\x2\x2\x66i\x5\x32\x1A\x2gh\a\x99\x2\x2"+
		"hj\x5\x16\f\x2ig\x3\x2\x2\x2ij\x3\x2\x2\x2jk\x3\x2\x2\x2km\t\x2\x2\x2"+
		"ln\a\x11\x2\x2ml\x3\x2\x2\x2mn\x3\x2\x2\x2no\x3\x2\x2\x2op\x5&\x14\x2"+
		"p\r\x3\x2\x2\x2qs\x5\x10\t\x2rq\x3\x2\x2\x2sv\x3\x2\x2\x2tr\x3\x2\x2\x2"+
		"tu\x3\x2\x2\x2u\xF\x3\x2\x2\x2vt\x3\x2\x2\x2wx\a\x16\x2\x2xy\a\x62\x2"+
		"\x2yz\x5\x16\f\x2z{\x5:\x1E\x2{|\x5\xE\b\x2|}\a\x1A\x2\x2}~\a\x16\x2\x2"+
		"~\x7F\x5:\x1E\x2\x7F\x128\x3\x2\x2\x2\x80\x81\a\x62\x2\x2\x81\x82\x5\x16"+
		"\f\x2\x82\x83\x5:\x1E\x2\x83\x84\x5\xE\b\x2\x84\x85\a\x1A\x2\x2\x85\x86"+
		"\x5:\x1E\x2\x86\x128\x3\x2\x2\x2\x87\x88\aK\x2\x2\x88\x89\x5:\x1E\x2\x89"+
		"\x8A\x5\xE\b\x2\x8A\x8B\a^\x2\x2\x8B\x8C\x5\x16\f\x2\x8C\x8D\x5:\x1E\x2"+
		"\x8D\x128\x3\x2\x2\x2\x8E\x8F\a&\x2\x2\x8F\x90\x5\x16\f\x2\x90\x91\a\x99"+
		"\x2\x2\x91\x92\x5\x16\f\x2\x92\x93\t\x3\x2\x2\x93\x96\x5\x16\f\x2\x94"+
		"\x95\aT\x2\x2\x95\x97\x5\x16\f\x2\x96\x94\x3\x2\x2\x2\x96\x97\x3\x2\x2"+
		"\x2\x97\x98\x3\x2\x2\x2\x98\x99\x5:\x1E\x2\x99\x9A\x5\xE\b\x2\x9A\x9B"+
		"\a?\x2\x2\x9B\x9C\x5:\x1E\x2\x9C\x128\x3\x2\x2\x2\x9D\xA4\a\'\x2\x2\x9E"+
		"\x9F\a\x30\x2\x2\x9F\xA5\x5\x32\x1A\x2\xA0\xA1\x5\x32\x1A\x2\xA1\xA2\a"+
		"\x6\x2\x2\xA2\xA3\x5&\x14\x2\xA3\xA5\x3\x2\x2\x2\xA4\x9E\x3\x2\x2\x2\xA4"+
		"\xA0\x3\x2\x2\x2\xA5\xA6\x3\x2\x2\x2\xA6\xA7\a\x36\x2\x2\xA7\xA8\x5\x16"+
		"\f\x2\xA8\xA9\x5:\x1E\x2\xA9\xAA\x5\xE\b\x2\xAA\xAB\a?\x2\x2\xAB\xAC\x5"+
		":\x1E\x2\xAC\x128\x3\x2\x2\x2\xAD\xAE\a,\x2\x2\xAE\xB3\x5\x12\n\x2\xAF"+
		"\xB0\a\x19\x2\x2\xB0\xB2\x5\x12\n\x2\xB1\xAF\x3\x2\x2\x2\xB2\xB5\x3\x2"+
		"\x2\x2\xB3\xB1\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xBA\x3\x2\x2\x2\xB5"+
		"\xB3\x3\x2\x2\x2\xB6\xB7\a\x18\x2\x2\xB7\xB8\x5:\x1E\x2\xB8\xB9\x5\xE"+
		"\b\x2\xB9\xBB\x3\x2\x2\x2\xBA\xB6\x3\x2\x2\x2\xBA\xBB\x3\x2\x2\x2\xBB"+
		"\xC1\x3\x2\x2\x2\xBC\xBE\a\x1A\x2\x2\xBD\xBF\a,\x2\x2\xBE\xBD\x3\x2\x2"+
		"\x2\xBE\xBF\x3\x2\x2\x2\xBF\xC2\x3\x2\x2\x2\xC0\xC2\a\x1D\x2\x2\xC1\xBC"+
		"\x3\x2\x2\x2\xC1\xC0\x3\x2\x2\x2\xC2\xC3\x3\x2\x2\x2\xC3\xC4\x5:\x1E\x2"+
		"\xC4\x128\x3\x2\x2\x2\xC5\xC6\a\x16\x2\x2\xC6\xC7\a\v\x2\x2\xC7\xCC\x5"+
		":\x1E\x2\xC8\xC9\a\v\x2\x2\xC9\xCB\x5\x12\n\x2\xCA\xC8\x3\x2\x2\x2\xCB"+
		"\xCE\x3\x2\x2\x2\xCC\xCA\x3\x2\x2\x2\xCC\xCD\x3\x2\x2\x2\xCD\xD3\x3\x2"+
		"\x2\x2\xCE\xCC\x3\x2\x2\x2\xCF\xD0\a\x41\x2\x2\xD0\xD1\x5:\x1E\x2\xD1"+
		"\xD2\x5\xE\b\x2\xD2\xD4\x3\x2\x2\x2\xD3\xCF\x3\x2\x2\x2\xD3\xD4\x3\x2"+
		"\x2\x2\xD4\xDA\x3\x2\x2\x2\xD5\xD7\a\x1A\x2\x2\xD6\xD8\a\v\x2\x2\xD7\xD6"+
		"\x3\x2\x2\x2\xD7\xD8\x3\x2\x2\x2\xD8\xDB\x3\x2\x2\x2\xD9\xDB\a\x1B\x2"+
		"\x2\xDA\xD5\x3\x2\x2\x2\xDA\xD9\x3\x2\x2\x2\xDB\xDC\x3\x2\x2\x2\xDC\xDD"+
		"\x5:\x1E\x2\xDD\x128\x3\x2\x2\x2\xDE\xDF\a \x2\x2\xDF\x128\x5:\x1E\x2"+
		"\xE0\xE1\a:\x2\x2\xE1\x128\x5:\x1E\x2\xE2\xE7\x5\x16\f\x2\xE3\xE4\a\xB4"+
		"\x2\x2\xE4\xE6\x5\x16\f\x2\xE5\xE3\x3\x2\x2\x2\xE6\xE9\x3\x2\x2\x2\xE7"+
		"\xE5\x3\x2\x2\x2\xE7\xE8\x3\x2\x2\x2\xE8\xEA\x3\x2\x2\x2\xE9\xE7\x3\x2"+
		"\x2\x2\xEA\xEB\x5:\x1E\x2\xEB\x128\x3\x2\x2\x2\xEC\xEE\a\n\x2\x2\xED\xEF"+
		"\x5\x16\f\x2\xEE\xED\x3\x2\x2\x2\xEE\xEF\x3\x2\x2\x2\xEF\xF0\x3\x2\x2"+
		"\x2\xF0\x128\x5:\x1E\x2\xF1\xF3\aY\x2\x2\xF2\xF4\x5\x16\f\x2\xF3\xF2\x3"+
		"\x2\x2\x2\xF3\xF4\x3\x2\x2\x2\xF4\xF5\x3\x2\x2\x2\xF5\x128\x5:\x1E\x2"+
		"\xF6\xF7\a[\x2\x2\xF7\xF8\x5:\x1E\x2\xF8\xFD\x5\xE\b\x2\xF9\xFA\a\r\x2"+
		"\x2\xFA\xFC\x5\x14\v\x2\xFB\xF9\x3\x2\x2\x2\xFC\xFF\x3\x2\x2\x2\xFD\xFB"+
		"\x3\x2\x2\x2\xFD\xFE\x3\x2\x2\x2\xFE\x104\x3\x2\x2\x2\xFF\xFD\x3\x2\x2"+
		"\x2\x100\x101\a%\x2\x2\x101\x102\x5:\x1E\x2\x102\x103\x5\xE\b\x2\x103"+
		"\x105\x3\x2\x2\x2\x104\x100\x3\x2\x2\x2\x104\x105\x3\x2\x2\x2\x105\x106"+
		"\x3\x2\x2\x2\x106\x108\a\x1A\x2\x2\x107\x109\a[\x2\x2\x108\x107\x3\x2"+
		"\x2\x2\x108\x109\x3\x2\x2\x2\x109\x10A\x3\x2\x2\x2\x10A\x10B\x5:\x1E\x2"+
		"\x10B\x128\x3\x2\x2\x2\x10C\x10F\aL\x2\x2\x10D\x110\ay\x2\x2\x10E\x110"+
		"\x5\x16\f\x2\x10F\x10D\x3\x2\x2\x2\x10F\x10E\x3\x2\x2\x2\x10F\x110\x3"+
		"\x2\x2\x2\x110\x111\x3\x2\x2\x2\x111\x128\x5:\x1E\x2\x112\x113\a\t\x2"+
		"\x2\x113\x114\a\x39\x2\x2\x114\x115\x5\x16\f\x2\x115\x116\x5:\x1E\x2\x116"+
		"\x117\x5\xE\b\x2\x117\x119\a\x1A\x2\x2\x118\x11A\a\x39\x2\x2\x119\x118"+
		"\x3\x2\x2\x2\x119\x11A\x3\x2\x2\x2\x11A\x11B\x3\x2\x2\x2\x11B\x11C\x5"+
		":\x1E\x2\x11C\x128\x3\x2\x2\x2\x11D\x11E\a\t\x2\x2\x11E\x11F\aM\x2\x2"+
		"\x11F\x120\x5:\x1E\x2\x120\x121\x5\xE\b\x2\x121\x123\a\x1A\x2\x2\x122"+
		"\x124\aM\x2\x2\x123\x122\x3\x2\x2\x2\x123\x124\x3\x2\x2\x2\x124\x125\x3"+
		"\x2\x2\x2\x125\x126\x5:\x1E\x2\x126\x128\x3\x2\x2\x2\x127w\x3\x2\x2\x2"+
		"\x127\x80\x3\x2\x2\x2\x127\x87\x3\x2\x2\x2\x127\x8E\x3\x2\x2\x2\x127\x9D"+
		"\x3\x2\x2\x2\x127\xAD\x3\x2\x2\x2\x127\xC5\x3\x2\x2\x2\x127\xDE\x3\x2"+
		"\x2\x2\x127\xE0\x3\x2\x2\x2\x127\xE2\x3\x2\x2\x2\x127\xEC\x3\x2\x2\x2"+
		"\x127\xF1\x3\x2\x2\x2\x127\xF6\x3\x2\x2\x2\x127\x10C\x3\x2\x2\x2\x127"+
		"\x112\x3\x2\x2\x2\x127\x11D\x3\x2\x2\x2\x128\x11\x3\x2\x2\x2\x129\x12A"+
		"\x5\x16\f\x2\x12A\x12B\x5:\x1E\x2\x12B\x12C\x5\xE\b\x2\x12C\x13\x3\x2"+
		"\x2\x2\x12D\x12E\x5\x32\x1A\x2\x12E\x12F\a\x6\x2\x2\x12F\x130\x5&\x14"+
		"\x2\x130\x131\x5:\x1E\x2\x131\x132\x5\xE\b\x2\x132\x15\x3\x2\x2\x2\x133"+
		"\x134\b\f\x1\x2\x134\x135\t\x4\x2\x2\x135\x159\x5\x16\f\x1D\x136\x137"+
		"\t\x5\x2\x2\x137\x159\x5\x16\f\x14\x138\x139\a\xAD\x2\x2\x139\x13A\x5"+
		"&\x14\x2\x13A\x13B\a\xAE\x2\x2\x13B\x13C\x5\x16\f\t\x13C\x159\x3\x2\x2"+
		"\x2\x13D\x13E\x5&\x14\x2\x13E\x140\a\xAF\x2\x2\x13F\x141\x5\x1A\xE\x2"+
		"\x140\x13F\x3\x2\x2\x2\x140\x141\x3\x2\x2\x2\x141\x142\x3\x2\x2\x2\x142"+
		"\x143\a\xB0\x2\x2\x143\x159\x3\x2\x2\x2\x144\x159\x5\x36\x1C\x2\x145\x159"+
		"\x5,\x17\x2\x146\x159\x5.\x18\x2\x147\x148\a\\\x2\x2\x148\x149\a\xAD\x2"+
		"\x2\x149\x14A\x5&\x14\x2\x14A\x14B\a\xAE\x2\x2\x14B\x159\x3\x2\x2\x2\x14C"+
		"\x14D\aR\x2\x2\x14D\x14E\a\xAD\x2\x2\x14E\x14F\x5&\x14\x2\x14F\x150\a"+
		"\xAE\x2\x2\x150\x159\x3\x2\x2\x2\x151\x159\x5 \x11\x2\x152\x159\x5\x34"+
		"\x1B\x2\x153\x159\x5\x1E\x10\x2\x154\x155\a\xAD\x2\x2\x155\x156\x5\x16"+
		"\f\x2\x156\x157\a\xAE\x2\x2\x157\x159\x3\x2\x2\x2\x158\x133\x3\x2\x2\x2"+
		"\x158\x136\x3\x2\x2\x2\x158\x138\x3\x2\x2\x2\x158\x13D\x3\x2\x2\x2\x158"+
		"\x144\x3\x2\x2\x2\x158\x145\x3\x2\x2\x2\x158\x146\x3\x2\x2\x2\x158\x147"+
		"\x3\x2\x2\x2\x158\x14C\x3\x2\x2\x2\x158\x151\x3\x2\x2\x2\x158\x152\x3"+
		"\x2\x2\x2\x158\x153\x3\x2\x2\x2\x158\x154\x3\x2\x2\x2\x159\x191\x3\x2"+
		"\x2\x2\x15A\x15B\f\x1C\x2\x2\x15B\x15C\a\x94\x2\x2\x15C\x190\x5\x16\f"+
		"\x1D\x15D\x15E\f\x1B\x2\x2\x15E\x15F\t\x6\x2\x2\x15F\x190\x5\x16\f\x1C"+
		"\x160\x161\f\x1A\x2\x2\x161\x162\t\a\x2\x2\x162\x190\x5\x16\f\x1B\x163"+
		"\x164\f\x19\x2\x2\x164\x165\t\b\x2\x2\x165\x190\x5\x16\f\x1A\x166\x167"+
		"\f\x18\x2\x2\x167\x168\t\t\x2\x2\x168\x190\x5\x16\f\x19\x169\x16A\f\x17"+
		"\x2\x2\x16A\x16B\a\xB6\x2\x2\x16B\x190\x5\x16\f\x18\x16C\x16D\f\x16\x2"+
		"\x2\x16D\x16E\a\x97\x2\x2\x16E\x190\x5\x16\f\x17\x16F\x170\f\x15\x2\x2"+
		"\x170\x171\a\xB5\x2\x2\x171\x190\x5\x16\f\x16\x172\x173\f\x13\x2\x2\x173"+
		"\x174\a\x87\x2\x2\x174\x190\x5\x16\f\x14\x175\x176\f\x12\x2\x2\x176\x177"+
		"\a\x8A\x2\x2\x177\x190\x5\x16\f\x13\x178\x179\f\x11\x2\x2\x179\x17A\a"+
		"\x88\x2\x2\x17A\x190\x5\x16\f\x12\x17B\x17C\f\x10\x2\x2\x17C\x17D\t\n"+
		"\x2\x2\x17D\x190\x5\x16\f\x11\x17E\x17F\f\x1F\x2\x2\x17F\x180\t\v\x2\x2"+
		"\x180\x190\x5$\x13\x2\x181\x182\f\x1E\x2\x2\x182\x190\t\f\x2\x2\x183\x184"+
		"\f\xF\x2\x2\x184\x186\a\xAD\x2\x2\x185\x187\x5\x1A\xE\x2\x186\x185\x3"+
		"\x2\x2\x2\x186\x187\x3\x2\x2\x2\x187\x188\x3\x2\x2\x2\x188\x190\a\xAE"+
		"\x2\x2\x189\x18A\f\xE\x2\x2\x18A\x18C\a\xB1\x2\x2\x18B\x18D\x5\x18\r\x2"+
		"\x18C\x18B\x3\x2\x2\x2\x18C\x18D\x3\x2\x2\x2\x18D\x18E\x3\x2\x2\x2\x18E"+
		"\x190\a\xB2\x2\x2\x18F\x15A\x3\x2\x2\x2\x18F\x15D\x3\x2\x2\x2\x18F\x160"+
		"\x3\x2\x2\x2\x18F\x163\x3\x2\x2\x2\x18F\x166\x3\x2\x2\x2\x18F\x169\x3"+
		"\x2\x2\x2\x18F\x16C\x3\x2\x2\x2\x18F\x16F\x3\x2\x2\x2\x18F\x172\x3\x2"+
		"\x2\x2\x18F\x175\x3\x2\x2\x2\x18F\x178\x3\x2\x2\x2\x18F\x17B\x3\x2\x2"+
		"\x2\x18F\x17E\x3\x2\x2\x2\x18F\x181\x3\x2\x2\x2\x18F\x183\x3\x2\x2\x2"+
		"\x18F\x189\x3\x2\x2\x2\x190\x193\x3\x2\x2\x2\x191\x18F\x3\x2\x2\x2\x191"+
		"\x192\x3\x2\x2\x2\x192\x17\x3\x2\x2\x2\x193\x191\x3\x2\x2\x2\x194\x199"+
		"\x5\x16\f\x2\x195\x196\a\xB4\x2\x2\x196\x198\x5\x16\f\x2\x197\x195\x3"+
		"\x2\x2\x2\x198\x19B\x3\x2\x2\x2\x199\x197\x3\x2\x2\x2\x199\x19A\x3\x2"+
		"\x2\x2\x19A\x19\x3\x2\x2\x2\x19B\x199\x3\x2\x2\x2\x19C\x1A3\x5\x1C\xF"+
		"\x2\x19D\x19F\a\xB4\x2\x2\x19E\x1A0\x5\x1C\xF\x2\x19F\x19E\x3\x2\x2\x2"+
		"\x19F\x1A0\x3\x2\x2\x2\x1A0\x1A2\x3\x2\x2\x2\x1A1\x19D\x3\x2\x2\x2\x1A2"+
		"\x1A5\x3\x2\x2\x2\x1A3\x1A1\x3\x2\x2\x2\x1A3\x1A4\x3\x2\x2\x2\x1A4\x1B"+
		"\x3\x2\x2\x2\x1A5\x1A3\x3\x2\x2\x2\x1A6\x1A7\x5\x16\f\x2\x1A7\x1D\x3\x2"+
		"\x2\x2\x1A8\x1A9\a-\x2\x2\x1A9\x1AA\a\xAD\x2\x2\x1AA\x1AB\x5\x16\f\x2"+
		"\x1AB\x1AC\a\xB4\x2\x2\x1AC\x1AD\x5\x16\f\x2\x1AD\x1AE\a\xB4\x2\x2\x1AE"+
		"\x1AF\x5\x16\f\x2\x1AF\x1B0\a\xAE\x2\x2\x1B0\x1F\x3\x2\x2\x2\x1B1\x1B2"+
		"\b\x11\x1\x2\x1B2\x1B3\x5\x32\x1A\x2\x1B3\x1B4\x5\"\x12\x2\x1B4\x1B7\x3"+
		"\x2\x2\x2\x1B5\x1B7\x5\x32\x1A\x2\x1B6\x1B1\x3\x2\x2\x2\x1B6\x1B5\x3\x2"+
		"\x2\x2\x1B7\x1BD\x3\x2\x2\x2\x1B8\x1B9\f\x5\x2\x2\x1B9\x1BA\a\xB9\x2\x2"+
		"\x1BA\x1BC\x5\x32\x1A\x2\x1BB\x1B8\x3\x2\x2\x2\x1BC\x1BF\x3\x2\x2\x2\x1BD"+
		"\x1BB\x3\x2\x2\x2\x1BD\x1BE\x3\x2\x2\x2\x1BE!\x3\x2\x2\x2\x1BF\x1BD\x3"+
		"\x2\x2\x2\x1C0\x1C1\a\xA5\x2\x2\x1C1\x1C6\x5&\x14\x2\x1C2\x1C3\a\xB4\x2"+
		"\x2\x1C3\x1C5\x5&\x14\x2\x1C4\x1C2\x3\x2\x2\x2\x1C5\x1C8\x3\x2\x2\x2\x1C6"+
		"\x1C4\x3\x2\x2\x2\x1C6\x1C7\x3\x2\x2\x2\x1C7\x1C9\x3\x2\x2\x2\x1C8\x1C6"+
		"\x3\x2\x2\x2\x1C9\x1CA\a\xA7\x2\x2\x1CA#\x3\x2\x2\x2\x1CB\x1CC\x5\x32"+
		"\x1A\x2\x1CC%\x3\x2\x2\x2\x1CD\x1CE\x5*\x16\x2\x1CE\x1CF\ap\x2\x2\x1CF"+
		"\x1D9\x3\x2\x2\x2\x1D0\x1D4\x5*\x16\x2\x1D1\x1D3\x5(\x15\x2\x1D2\x1D1"+
		"\x3\x2\x2\x2\x1D3\x1D6\x3\x2\x2\x2\x1D4\x1D2\x3\x2\x2\x2\x1D4\x1D5\x3"+
		"\x2\x2\x2\x1D5\x1D9\x3\x2\x2\x2\x1D6\x1D4\x3\x2\x2\x2\x1D7\x1D9\x5*\x16"+
		"\x2\x1D8\x1CD\x3\x2\x2\x2\x1D8\x1D0\x3\x2\x2\x2\x1D8\x1D7\x3\x2\x2\x2"+
		"\x1D9\'\x3\x2\x2\x2\x1DA\x1DE\a\xB1\x2\x2\x1DB\x1DD\a\xB4\x2\x2\x1DC\x1DB"+
		"\x3\x2\x2\x2\x1DD\x1E0\x3\x2\x2\x2\x1DE\x1DC\x3\x2\x2\x2\x1DE\x1DF\x3"+
		"\x2\x2\x2\x1DF\x1E1\x3\x2\x2\x2\x1E0\x1DE\x3\x2\x2\x2\x1E1\x1E2\a\xB2"+
		"\x2\x2\x1E2)\x3\x2\x2\x2\x1E3\x1E6\x5 \x11\x2\x1E4\x1E6\x5\x34\x1B\x2"+
		"\x1E5\x1E3\x3\x2\x2\x2\x1E5\x1E4\x3\x2\x2\x2\x1E6+\x3\x2\x2\x2\x1E7\x1E8"+
		"\a\xA5\x2\x2\x1E8\x1E9\x5&\x14\x2\x1E9\x1EA\a\xA7\x2\x2\x1EA\x1EC\x3\x2"+
		"\x2\x2\x1EB\x1E7\x3\x2\x2\x2\x1EB\x1EC\x3\x2\x2\x2\x1EC\x1ED\x3\x2\x2"+
		"\x2\x1ED\x1EF\a\xAF\x2\x2\x1EE\x1F0\x5\x18\r\x2\x1EF\x1EE\x3\x2\x2\x2"+
		"\x1EF\x1F0\x3\x2\x2\x2\x1F0\x1F1\x3\x2\x2\x2\x1F1\x1F2\a\xB0\x2\x2\x1F2"+
		"-\x3\x2\x2\x2\x1F3\x1FA\a\xAF\x2\x2\x1F4\x1FB\a\x8F\x2\x2\x1F5\x1F7\a"+
		"\xB5\x2\x2\x1F6\x1F8\x5\x30\x19\x2\x1F7\x1F6\x3\x2\x2\x2\x1F7\x1F8\x3"+
		"\x2\x2\x2\x1F8\x1F9\x3\x2\x2\x2\x1F9\x1FB\a\xB5\x2\x2\x1FA\x1F4\x3\x2"+
		"\x2\x2\x1FA\x1F5\x3\x2\x2\x2\x1FB\x1FD\x3\x2\x2\x2\x1FC\x1FE\x5\x16\f"+
		"\x2\x1FD\x1FC\x3\x2\x2\x2\x1FD\x1FE\x3\x2\x2\x2\x1FE\x1FF\x3\x2\x2\x2"+
		"\x1FF\x200\a\xB0\x2\x2\x200/\x3\x2\x2\x2\x201\x206\x5\x32\x1A\x2\x202"+
		"\x203\a\xB4\x2\x2\x203\x205\x5\x32\x1A\x2\x204\x202\x3\x2\x2\x2\x205\x208"+
		"\x3\x2\x2\x2\x206\x204\x3\x2\x2\x2\x206\x207\x3\x2\x2\x2\x207\x31\x3\x2"+
		"\x2\x2\x208\x206\x3\x2\x2\x2\x209\x20A\a\xC4\x2\x2\x20A\x33\x3\x2\x2\x2"+
		"\x20B\x20C\t\r\x2\x2\x20C\x35\x3\x2\x2\x2\x20D\x20E\t\xE\x2\x2\x20E\x37"+
		"\x3\x2\x2\x2\x20F\x210\t\xF\x2\x2\x210\x39\x3\x2\x2\x2\x211\x213\a\xC3"+
		"\x2\x2\x212\x211\x3\x2\x2\x2\x213\x216\x3\x2\x2\x2\x214\x212\x3\x2\x2"+
		"\x2\x214\x215\x3\x2\x2\x2\x215\x217\x3\x2\x2\x2\x216\x214\x3\x2\x2\x2"+
		"\x217\x218\t\x10\x2\x2\x218;\x3\x2\x2\x2\x219\x21A\a\x2\x2\x3\x21A=\x3"+
		"\x2\x2\x2\x34?\x44_\x62imt\x96\xA4\xB3\xBA\xBE\xC1\xCC\xD3\xD7\xDA\xE7"+
		"\xEE\xF3\xFD\x104\x108\x10F\x119\x123\x127\x140\x158\x186\x18C\x18F\x191"+
		"\x199\x19F\x1A3\x1B6\x1BD\x1C6\x1D4\x1D8\x1DE\x1E5\x1EB\x1EF\x1F7\x1FA"+
		"\x1FD\x206\x214";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace LanguageService.CodeAnalysis.XSharp.SyntaxParser
