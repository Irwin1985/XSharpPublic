<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" modified="2023-12-15T20:19:37.779+02:00" lasteditedby="cpc" version="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title>Classes and Structures</title>
  <body>
    <header>
      <para styleclass="Heading1">Classes and Structures</para>
    </header>
    <para styleclass="Normal">In .Net, there are two kind of types that hold data, reference types (or classes) and value types (or structures). The two of them have different semantics in the way they are used, but both can contain themselves other reference and/or value types.</para>
    <para styleclass="Heading2">Classes</para>
    <para styleclass="Normal">A class (or a <text style="font-weight:bold;">reference type)</text>, is the most common way of storing data. Its name comes from the fact that a variable of a reference type (commonly referred to as an <text style="font-weight:bold;">instance</text> of the type) does not contain the data directly, but instead points to (references) a memory location where the actual data is stored. A class in X# is defined through the <link displaytype="text" defaultstyle="true" type="topiclink" href="command_CLASS">CLASS...END CLASS statement</link> and can INHERIT from another reference type, implement one or more <link displaytype="text" defaultstyle="true" type="topiclink" href="command_INTERFACE">INTERFACES</link> and may contain fields, properties, constructors, methods, events and other items:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Customer</para>
    <para styleclass="Normal"><tab />EXPORT name AS INT // exported (public) field</para>
    <para styleclass="Normal"><tab />PROTECT age AS INT // protected field, not visible to code outside the class</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Typically classes and all their members are defined in a single file of code. If it&apos;s necessary for class members to be defined in multiple files (for example when the amount of class members is very big), then the class must be defined <text style="font-weight:bold;">in every file</text> as PARTIAL:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">PARTIAL CLASS Customer</para>
    <para styleclass="Normal">// class members</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Since an instance of a class is only storing a pointer to the data, one or more variables can point to the exact same object in memory. Assigning a variable of a reference type to another variable of the same type results to both representing the same data. Updating data using one reference automatically updates the other reference as well:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL one, two AS Customer</para>
    <para styleclass="Normal"><tab />one := Customer{}</para>
    <para styleclass="Normal"><tab />two := one // now both vars point to the same object in memory</para>
    <para styleclass="Normal"><tab />two:name := &quot;Robert&quot;</para>
    <para styleclass="Normal"><tab />? one:name // also &quot;Robert&quot;</para>
    <para styleclass="Heading2">Nested Classes</para>
    <para styleclass="Normal">A class can even contain other types (classes or structures). In this case the type inside the main type is called a <text style="font-weight:bold;">nested type</text>. Nested types can be used by using the name of their container class and their own name, connected by a dot:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Customer</para>
    <para styleclass="Normal"><tab />CLASS NestedClass</para>
    <para styleclass="Normal"><tab /><tab />EXPORT FieldInNestedClass AS INT</para>
    <para styleclass="Normal"><tab />END CLASS</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oNested AS Customer.NestedClass</para>
    <para styleclass="Normal"><tab />oNested := Customer.NestedClass{}</para>
    <para styleclass="Normal"><tab />oNested:FieldInNestedClass := 100</para>
    <para styleclass="Normal"><tab />? oNested:FieldInNestedClass</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Nested classes are useful in particular for defining <text style="font-style:italic;">helper</text> classes, a class that is only used in the context of the parent class, for holding information only relevant to that class. Creating a nested class for this data, instead of using a regular class results to better structured code.</para>
    <para styleclass="Normal"></para>
    <para styleclass="Heading2">Structures</para>
    <para styleclass="Normal">A structure (or a <text style="font-weight:bold;">value type)</text>, in contrast to reference types, stores its data directly. It has some similarities to the Visual Objects STRUCTURE feature (renamed in X# to <link displaytype="text" defaultstyle="true" type="topiclink" href="command_VOSTRUCT">VOSTRUCT</link>), but it is a lot more powerful than in VO, as it can contain most items that also reference types have, like properties, constructors, methods etc. Unlike reference types though, value types cannot inherit from other types or implement interfaces. They can contain nested classes or structures though. Value types can be defined with the <link displaytype="text" defaultstyle="true" type="topiclink" href="command_STRUCTURE">STRUCTURE Statement</link>:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">STRUCTURE Vector2D</para>
    <para styleclass="Normal"><tab />EXPORT x AS INT</para>
    <para styleclass="Normal"><tab />EXPORT y AS INT</para>
    <para styleclass="Normal"><tab />METHOD Invert() AS VOID</para>
    <para styleclass="Normal"><tab /><tab />SELF:x := - SELF:x</para>
    <para styleclass="Normal"><tab /><tab />SELF:y := - SELF:y</para>
    <para styleclass="Normal">END STRUCTURE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Since structures hold their data directly, instantiating them does not involve any additional memory consumption than the memory needed for their data itself (reference types need memory for the data and also for the pointer to the data) or garbage collector activity. They are mostly suitable as light weight data containers, usually hold a small amount of fields, typically 2-4, but can even contain a single element, like the System.Int32 (INT) or System.Boolean (LOGIC) data types which simply define the INT and LOGIC data types, including several methods for manipulating their data. Other very commonly used system defined structures are System.Drawing.Point, System.Drawing.Rectangle etc, all containing a small amount of data fields.</para>
    <para styleclass="Heading2">Structure semantics</para>
    <para styleclass="Normal">Structures also have different semantics when using them compared to regular classes. It is not necessary to instantiate such a variable to use it, since declaring a var of a value type results to its data being allocated directly:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL vector AS Vector2D</para>
    <para styleclass="Normal"><tab />vector:x := 10</para>
    <para styleclass="Normal"><tab />vector:y := 20</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Although, for convenience, it&apos;s possible to also define constructors in value types and instantiate them as with regular classes:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">STRUCTURE Vector2D</para>
    <para styleclass="Normal"><tab />EXPORT x AS INT</para>
    <para styleclass="Normal"><tab />EXPORT y AS INT</para>
    <para styleclass="Normal"><tab />CONSTRUCTOR(vec_x AS INT, vec_y AS INT)</para>
    <para styleclass="Normal"><tab /><tab />SELF:x := vec_x</para>
    <para styleclass="Normal"><tab /><tab />SELF:y := vec_y</para>
    <para styleclass="Normal">END STRUCTURE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL vector AS Vector2D</para>
    <para styleclass="Normal"><tab />vector := Vector2D{10,20}</para>
    <para styleclass="Normal"><tab />? vector:x // 10</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">The most important difference that must always be taken under consideration, is that assigning a value type to another one results to the data of the source being <text style="font-weight:bold;">copied</text> to the destination, so unlike what happens with reference types, the data of the two variables are stored in separate memory locations and any changes to one variable will not affect the other:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL vec_1,vec_2 AS Vector2D</para>
    <para styleclass="Normal"><tab />vec_1:x := 10 ; vec_1:y := 20</para>
    <para styleclass="Normal"><tab />vec_2 := vec_1</para>
    <para styleclass="Normal"><tab />? vec_2:x // 10, value was copied from first vector</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />vec_2:x := 40 // put a new value to second vector</para>
    <para styleclass="Normal"><tab />? vec_1:x // 10 again, first vector value still has its original value</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">For this reason structures are not suitable for very large objects, since assigning one to another or passing one as an argument to a method involves copying all data from the source to the destination. On the other hand, with regular classes, only the pointer to the data is passed as an argument to a method.</para>
    <para styleclass="Heading2">Equals operator</para>
    <para styleclass="Normal">Another important difference between reference and value types, is the behavior of the equals operator (==). For reference types, the equals operator between two variables only compares the pointers themselves, not the data of the objects. So it returns TRUE only when both variables point to the same object and in all other cases it returns FALSE, even if the data both objects contain is the same:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS ReferenceType</para>
    <para styleclass="Normal"><tab />EXPORT data AS STRING</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL o1,o2 AS ReferenceType</para>
    <para styleclass="Normal"><tab />o1 := ReferenceType{}</para>
    <para styleclass="Normal"><tab />o1:data := &quot;test&quot;</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />o2 := ReferenceType{}</para>
    <para styleclass="Normal"><tab />o2:data := &quot;test&quot;</para>
    <para styleclass="Normal"><tab /></para>
    <para styleclass="Normal"><tab />? o1 == o2 // FALSE, because o1 and o2 point to different memory locations</para>
    <para styleclass="Normal"><tab /></para>
    <para styleclass="Normal"><tab />o2 := o1</para>
    <para styleclass="Normal"><tab />? o1 == o2 // TRUE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">On the other hand, by default the == operator cannot be used on structures and the compiler will report an error if you try to do so. It can be made possible to use it though, by defining an <link displaytype="text" defaultstyle="true" type="topiclink" href="command_OPERATOR">OPERATOR</link> method in the structure that implements how the comparison with == should be done. In the sample below, the == operator is implemented to compare the actual data that the two compared structures hold, so that it returns TRUE, when the data is equal:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">STRUCTURE ValueType</para>
    <para styleclass="Normal"><tab />EXPORT data AS STRING</para>
    <para styleclass="Normal"><tab />OPERATOR == (a AS ValueType, b AS ValueType) AS LOGIC</para>
    <para styleclass="Normal"><tab />RETURN a:data == b:data // let the equals == operator return true when the data of the two arguments is the same</para>
    <para styleclass="Normal">END STRUCTURE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL o1,o2 AS ValueType</para>
    <para styleclass="Normal"><tab />o1:data := &quot;test&quot;</para>
    <para styleclass="Normal"><tab />o2:data := &quot;nothing&quot;</para>
    <para styleclass="Normal"><tab />? o1 == o2 // FALSE</para>
    <para styleclass="Normal"><tab />o2:data := &quot;test&quot;</para>
    <para styleclass="Normal"><tab />? o1 == o2 // TRUE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Note that it is possible to compare values of most common system defined structures like System.Int32, System.Boolean, System.Double, because they also have defined equals operator methods like the one in the code above.</para>
    <para styleclass="Heading2">Which one to use</para>
    <para styleclass="Normal">Weather to use a class or a structure for holding data depends on the specific needs related to the particular data. For data holding a lot of information (for example a customer object) you would typically use a reference type, as such objects usually don&apos;t get instantiated very often, but usually &quot;live&quot; long for the duration of the program. For smaller objects, that are being a created, manipulated and copied between variables a lot of times and in particular in tight loops (like for example an object representing a Complex number, consisting of a real and an imaginary part, which can be used in a lot of calculations), it is&apos; more suitable to use a structure, as this will typically lead to faster execution, with a lot less memory consumption and garbage collector activity. In any case, it&apos;s very important to carefully consider their differences in semantics when using value vs reference types.</para>
    <para styleclass="Normal"></para>
  </body>
</topic>
