<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" modified="2023-12-08T19:37:58.193+02:00" lasteditedby="cpc" version="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title>Codeblock, Lambda and Anonymous Method Expressions</title>
  <body>
    <header>
      <para styleclass="Heading1">Tuples</para>
    </header>
    <para styleclass="Heading2">Tuple generic data type</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">A tuple is a data structure that groups multiple data elements in a lightweight data structure. Tuples can be used as an easy way to represent multiple data elements, pass them as argument(s) or receive them as a return value, without the need to declare a complete new class or structure for holding the data set.</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">For example, the following code uses the generic System.Collections.Generic.Tuple type to receive multiple values from a function, without the need to declare multiple REF/OUT parameters or to create a new dedicated type for holding them:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">USING System.Collections.Generic</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION GetCustomerData() AS Tuple&lt;STRING, INT, LOGIC&gt;</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS Tuple&lt;STRING, INT, LOGIC&gt;</para>
    <para styleclass="Normal"><tab />oCustomer := Tuple&lt;STRING, INT, LOGIC&gt;{&quot;Nikos&quot;, 47, TRUE}</para>
    <para styleclass="Normal">RETURN oCustomer</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS Tuple&lt;STRING, INT, LOGIC&gt;</para>
    <para styleclass="Normal"><tab />oCustomer := GetCustomerData()</para>
    <para styleclass="Normal"><tab />? &quot;Customer name:&quot;, oCustomer:Item1</para>
    <para styleclass="Normal"><tab />? &quot;Age:&quot;, oCustomer:Item2</para>
    <para styleclass="Normal"><tab />? &quot;Is active:&quot;, oCustomer:Item3</para>
    <para styleclass="Normal"></para>
    <para styleclass="Heading2">TUPLE keyword</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">X# also supports the dedicated keyword TUPLE, which offers an easier syntax for declaring and working with tuples. The above code can be written in a simpler way with the TUPLE keyword syntax: </para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION GetCustomerData() AS TUPLE(STRING, INT, LOGIC)</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS TUPLE(STRING, INT, LOGIC) // defining the tuple</para>
    <para styleclass="Normal"><tab />oCustomer := TUPLE{&quot;Nikos&quot;, 47, TRUE} // tuple item types must match the types in the Tuple definition</para>
    <para styleclass="Normal">RETURN oCustomer</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS (STRING, INT, LOGIC) // the TUPLE keyword in the tuple definition can even be omitted!</para>
    <para styleclass="Normal"><tab />oCustomer := GetCustomerData()</para>
    <para styleclass="Normal"><tab />? &quot;Customer name:&quot;, oCustomer:Item1</para>
    <para styleclass="Normal"><tab />? &quot;Age:&quot;, oCustomer:Item2</para>
    <para styleclass="Normal"><tab />? &quot;Is active:&quot;, oCustomer:Item3</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Note that when using the TUPLE keyword, the compiler internally uses the type System.ValueTuple, instead of the generic type System.Collections.Generic.Tuple. Also when defining the tuple, the TUPLE keyword can be omitted, thus using the more c#-like syntax (type1, type2, ...)</para>
    <para styleclass="Normal"></para>
    <para styleclass="Heading2">Named tuples</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">The dedicated TUPLE keyword syntax supports also specifying custom names for the tuple items, instead of using the generic names Item1, Item2 etc. So the code can become much more readable and close to what it would be like if using a separate new class for the data:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS TUPLE(Name AS STRING, Age AS INT, IsActive AS LOGIC) // provide names for each item of the tuple</para>
    <para styleclass="Normal"><tab />oCustomer := GetCustomerData()</para>
    <para styleclass="Normal"><tab />? &quot;Customer name:&quot;, oCustomer:Name</para>
    <para styleclass="Normal"><tab />? &quot;Age:&quot;, oCustomer:Age</para>
    <para styleclass="Normal"><tab />? &quot;Is active:&quot;, oCustomer:IsActive</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">to make code even more self-explanatory, a named tuple can also be instantiated by using named arguments:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION GetCustomerData() AS Tuple(STRING, INT, LOGIC)</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS Tuple(Name AS STRING, Age AS INT, IsActive AS LOGIC) // defining the named tuple with custom item names</para>
    <para styleclass="Normal"><tab />oCustomer := TUPLE{Name := &quot;Nikos&quot;, Age := 47, IsActive := TRUE} // including tuple item names in the tuple instantiation</para>
    <para styleclass="Normal">RETURN oCustomer</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Heading2">Defining tuples with VAR</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Tuples can also be defined and instantiated at the same time using the VAR keyword:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />VAR oTuple := TUPLE{&quot;Nikos&quot;, 47, FALSE}</para>
    <para styleclass="Normal"><tab />? oTuple:Item1, oTuple:Item2, oTuple:Item3 // &quot;Nikos&quot;, 47, FALSE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">In this case, the data type of each tuple item is inferred from the item types supplied in the code. In the above sample, the item types are (STRING, INT, LOGIC).</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Tuples with the same item types can be assigned to each other (thus copying the item values from the source tuple to the destination tuple), and the same can be done for tuples defined with either LOCAL or VAR:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />VAR oTuple := TUPLE{&quot;Nikos&quot;, 47, FALSE}</para>
    <para styleclass="Normal"><tab />LOCAL oNew AS TUPLE(STRING, INT, LOGIC)</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />oNew := oTuple</para>
    <para styleclass="Normal"><tab />? oNew:Item1, oNew:Item2, oNew:Item3 // &quot;Nikos&quot;, 47, FALSE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">When defining a tuple with the VAR keyword, item names can be provided as well:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />VAR oTuple := TUPLE{Name := &quot;Nikos&quot;, Age := 47, IsActive := FALSE}</para>
    <para styleclass="Normal"><tab />? oTuple:Name, oTuple:Age, oTuple:IsActive // &quot;Nikos&quot;, 47, FALSE</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Finally, when defining a tuple with VAR by using identifiers for the item values, instead of using literal values, then each item automatically gets a name by the identifier name used for it:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS CustomerInfo</para>
    <para styleclass="Normal"><tab />EXPORT Description := &quot;Customer description&quot; AS STRING</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL name := &quot;Unknown Customer&quot; AS STRING</para>
    <para styleclass="Normal"><tab />LOCAL oInfo := CustomerInfo{} AS CustomerInfo</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />VAR oTuple := TUPLE{name, oInfo:Description}</para>
    <para styleclass="Normal"><tab />? oTuple:name // &quot;Unknown Customer&quot;</para>
    <para styleclass="Normal"><tab />? oTuple:description // &quot;Customer description&quot;</para>
    <para styleclass="Normal"></para>
    <para styleclass="Heading2">Tuple deconstruction</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">A tuple can be deconstructed to multiple plain variables in one line of code, using the (var1, var2, ...) syntax:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS TUPLE(Name AS STRING, Age AS INT)</para>
    <para styleclass="Normal"><tab />oCustomer := TUPLE{&quot;Nikos&quot;, 47}</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />LOCAL name AS STRING</para>
    <para styleclass="Normal"><tab />LOCAL age AS INT</para>
    <para styleclass="Normal"><tab /></para>
    <para styleclass="Normal"><tab />(name, age) := oCustomer</para>
    <para styleclass="Normal"><tab />? name, age // &quot;Nikos&quot;, 47</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">The local variables can also be defined and assigned to the tuple item values in a single line, with a special LOCAL syntax for tuples:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS TUPLE(Name AS STRING, Age AS INT)</para>
    <para styleclass="Normal"><tab />oCustomer := TUPLE{&quot;Nikos&quot;, 47}</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />LOCAL (name AS STRING, age AS INT) := oCustomer</para>
    <para styleclass="Normal"><tab />? name, age // &quot;Nikos&quot;, 47</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Also the VAR keyword can be used for the tuple deconstruction, in which case the variable types are inferred from the tuple item types:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oCustomer AS TUPLE(Name AS STRING, Age AS INT)</para>
    <para styleclass="Normal"><tab />oCustomer := TUPLE{&quot;Nikos&quot;, 47}</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><tab />VAR (name, age) := oCustomer</para>
    <para styleclass="Normal"><tab />? name, age // &quot;Nikos&quot;, 47</para>
    <para styleclass="Normal"></para>
  </body>
</topic>
