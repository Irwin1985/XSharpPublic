<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../helpproject.xsl" ?>
<topic template="Default" modified="2024-02-09T11:38:01.490+02:00" lasteditedby="cpc" version="2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="../helpproject.xsd">
  <title>Modifiers</title>
  <body>
    <header>
      <para styleclass="Heading1">Modifiers</para>
    </header>
    <para styleclass="Normal">Modifiers are language keywords that are used to modify the visibility of a program element (function, global, class, property etc), or the way they operate within a type hierarchy.</para>
    <para styleclass="Heading2">Access modifiers</para>
    <para styleclass="Normal">Access modifiers restrict the visibility of program elements:</para>
    <para styleclass="Normal"></para>
    <list id="0" type="ul" listtype="bullet" formatstring="&#183;" format-charset="SYMBOL_CHARSET" levelreset="true" legalstyle="false" startfrom="1" styleclass="Normal" style="font-family:Symbol; font-size:11pt; color:#000000;">
      <li styleclass="Normal">PUBLIC/EXPORT: A public function, global, type (class, structure, delegate etc) or type member (field, method, property, event etc) is visible to all code withing the same assembly (exe or dll) where it is declared and assemblies references by the declaring assembly. This is the default in X#.</li>
      <li styleclass="Normal">PROTECT/PROTECTED: The PROTECT(ED) keyword can be applied only to type members and restrict their visibility to code within the same type and classes that inherit from that type</li>
      <li styleclass="Normal">INSTANCE: A unique keyword to X# (and Visual Objects), very similar to PROTECT, but applies only to class fields and has different semantics to PROTECT, on the way it is used by code within the same class (see sample below)</li>
      <li styleclass="Normal">PRIVATE/HIDDEN: Also applies to type members and is more restrictive than PROTECT, as it limits the member visibility to only code within the type where it is declared (not to classes inheriting that type)</li>
      <li styleclass="Normal">INTERNAL: Restricts the visibility of a type or member only to code from the same assembly (dll or exe). An internal member is not visible to any code outside the defining assembly, not even to classes inheriting from this class declared in other assemblies. Can be combined with PROTECTED, so that an INTERNAL PROTECTED member can be seen only form within the same class and also from inheriting classes that are defined in the same assembly, but not from inheriting classes that are defined in other assemblies.</li>
    </list>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Note: It is still possible to explicitly specify certain assemblies where internal types and members of an assembly are visible, y using the InternalsVisibleTo attribute. See documentation for System.Runtime.CompilerServices.InternalsVisibleToAttribute for more information.</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">INTERNAL PROCEDURE InternalProc() // procedure accessible only from within the same assembly</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">PUBLIC CLASS TestClass // accessible from everywhere</para>
    <para styleclass="Normal"><tab />EXPORT Export_field AS INT // accessible from everywhere</para>
    <para styleclass="Normal"><tab />PROTECT Protected_field AS INT // accessible to this class and classes inherited from it</para>
    <para styleclass="Normal"><tab />INTERNAL PROTECT Internal_Protected_field AS INT // accessible to this class and classes inherited from it, defined in this same assembly only</para>
    <para styleclass="Normal"><tab />PRIVATE METHOD Private_Method() AS VOID // accessible only from code inside this particular class</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text style="font-weight:bold;">PROTECTED vs HIDDEN</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">A compatibility feature for code derived from Visual Objects, INSTANCE applies to fields and is similar to PROTECT, but has different semantics when a property (or ACCESS) is defined with the same name. When using a PROTECT field and an ACCESS/ASSIGN pair (or PROPERTY) is defined with the same name in the type, then any code within that class that tries to access this member, always refers to the field. But when the member is declared with the INSTANCE keyword, then the compiler binds the name to the ACCESS instead:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />TestClass{}:DoTest()</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS TestClass</para>
    <para styleclass="Normal"><tab />PROTECT Protected_member := &quot;field&quot; AS STRING</para>
    <para styleclass="Normal"><tab />INSTANCE Instance_member := &quot;field&quot; AS STRING</para>
    <para styleclass="Normal"><tab />ACCESS Protected_member AS STRING</para>
    <para styleclass="Normal"><tab />RETURN &quot;access&quot;</para>
    <para styleclass="Normal"><tab />ACCESS Instance_member AS STRING</para>
    <para styleclass="Normal"><tab />RETURN &quot;access&quot;</para>
    <para styleclass="Normal"><tab />METHOD DoTest() AS VOID</para>
    <para styleclass="Normal"><tab /><tab />? SELF:Protected_member // field</para>
    <para styleclass="Normal"><tab /><tab />? SELF:Instance_member // access, because the field is defined with the INSTANCE keyword</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">This feature is a left over from old Visual Objects versions that were emitting INSTANCE members for every control in the Window Editor and is depreciated in X#, but still available for compatibility reasons.</para>
    <para styleclass="Heading2">Hierarchy modifiers</para>
    <para styleclass="Normal">Hierarchy modifiers control the way elements of a type (class or structure) behave with the class hierarchy.</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"><text style="font-weight:bold;">VIRTUAL/OVERRIDE/NEW:</text></para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">By default, all methods in .Net are non-VIRUAL, meaning they cannot be overridden by same named methods in descendant classes. In the following example, calling a method from code inside the Parent class, results to calling he version of the method defined in this particular class in the class hierarchy, not the method with the same name defined in the Child class (even though the object we are testing with is an instance of the Child class):</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">FUNCTION Start() AS VOID</para>
    <para styleclass="Normal"><tab />LOCAL oTest AS Child</para>
    <para styleclass="Normal"><tab />oTest := Child{}</para>
    <para styleclass="Normal"><tab />oTest:DoTest()</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Parent</para>
    <para styleclass="Normal"><tab />METHOD SomeMethod() AS VOID</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Parent method was called&quot;</para>
    <para styleclass="Normal"><tab />METHOD DoTest() AS VOID</para>
    <para styleclass="Normal"><tab /><tab />SELF:SomeMethod() // calls the method of this Parent class, not the same named one defined in the Child class</para>
    <para styleclass="Normal"><tab />RETURN</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Child INHERIT Parent</para>
    <para styleclass="Normal"><tab />METHOD SomeMethod() AS VOID</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Child method was called&quot;</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">This behavior is different to that of Visual Objects, where ALL methods are always considered VIRTUAL. In order to make a method overridable from descendant classes, it needs to be defined as VIRTUAL. In the following code, calling a VIRTUAL method from code in the Parent class, results to calling the version of the method defined in the Child class, since it has overridden the parent method:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Parent</para>
    <para styleclass="Normal"><tab />METHOD NonVirtualMethod() AS VOID // cannot be overriden in child class</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Parent non virtual method was called&quot;</para>
    <para styleclass="Normal"><tab />VIRTUAL METHOD VirtualMethod() AS VOID // can be overriden</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Parent virtual method was called&quot;</para>
    <para styleclass="Normal"><tab />METHOD DoTest() AS VOID</para>
    <para styleclass="Normal"><tab /><tab />SELF:NonVirtualMethod() // calls method in parent</para>
    <para styleclass="Normal"><tab /><tab />SELF:VirtualMethod() // calls method in child</para>
    <para styleclass="Normal"><tab />RETURN</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Child INHERIT Parent</para>
    <para styleclass="Normal"><tab />METHOD NonVirtualMethod() AS VOID // this is completely different method to the parent one, even though it has the same name</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Child non virtual method was called&quot;</para>
    <para styleclass="Normal"><tab />OVERRIDE METHOD VirtualMethod() AS VOID // overrides the same named method of the parent class</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Child virtual method was called&quot;</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">Note that VirtualMethod() in the child class is declared with the OVERRIDE modifier, this tells the compiler that we have on purpose overridden a parent method with the same name. The OVERRIDE modifier is not mandatory in X# and can be omitted, but it makes the code more self-explanatory and allows the compiler to make additional compile time checks. If OVERRIDE is used on a method to override a parent method that is not VIRTUAL, or it does not even exist (or is spelled with a different name in the parent class), then a compiler error will be reported. For this reason, it is recommended &#160;to explicitly declare methods overriding parent methods with the OVERRIDE keyword. It is also possible to enforce the use of the OVERRIDE keyword in the compiler, by enabling the compiler option &quot;Enforce OVERRIDE&quot; (/enforceoverride).</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">In the above code, the compiler does report a warning on the NonVirtualMethod() defined in the child class: warning XS0108: &apos;Child.NonVirtualMethod()&apos; hides inherited member &apos;Parent.NonVirtualMethod()&apos;. Use the new keyword if hiding was intended. This warns about the definition of a method in the child class that has the same name with a non-virtual method in the parent class, as this could had been done by accident (either accidentally using the same name, or forgetting to define the base method as virtual). In order to tell the compiler that the use of the same name in a child method was intentional, the NEW modifier keyword can be used, which explicitly marks the method as one that does override the base one:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">CLASS Child INHERIT Parent</para>
    <para styleclass="Normal"><tab />NEW METHOD NonVirtualMethod() AS VOID // explicitly mark the method as new one, different to the parent method</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Child non virtual method was called&quot;</para>
    <para styleclass="Normal"><tab />OVERRIDE METHOD VirtualMethod() AS VOID // overrides the same named method of the parent class</para>
    <para styleclass="Normal"><tab /><tab />? &quot;Child virtual method was called&quot;</para>
    <para styleclass="Normal">END CLASS</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">For already existing code ported from older systems like Visual Objects where methods are always VIRTUAL, it can be tiresome to manually add the VIRTUAL modifier keyword in all methods that needed. For this reason, it is possible for convenience to instruct the compiler to automatically treat ALL methods as virtual, with the use of the &quot;All instance methods virtual&quot; (/vo3) compiler option. But is highly recommended to instead review the code and manually add the VIRTUAL modifier where it is really needed.</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal">The VIRTUAL/OVERRIDE/NEW modifiers do not apply to methods only, but can be used also for other class members like properties, fields, events etc:</para>
    <para styleclass="Normal"></para>
    <para styleclass="Normal"></para>
  </body>
</topic>
